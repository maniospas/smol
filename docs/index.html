<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>smoλ</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
  <style>
    html {scroll-behavior: smooth;}
    h1 {scroll-margin-top: 60px;}
    h2 {scroll-margin-top: 60px;}
    body {font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;margin: 0;background-color: #f9f9f9;color: #333;line-height: 1.7;}
    .navbar {background-color: #333;padding: 2px;position: sticky;top: 0;z-index: 1000;display: flex;flex-wrap: wrap;justify-content: center;}
    .navbar a {color: white;text-decoration: none;padding: 5px 10px;font-weight: bold;}
    .navbar a:hover {background-color: #555;}//{text-decoration: underline;}
    .container {max-width: 800px;margin: 40px auto;padding: 0 20px;}
    h1, h2, h3 {color: #222;}
    table {width: 100%;border-collapse: collapse;margin-bottom: 2em;background-color: white;}
    th, td {border: 1px solid #ccc;padding: 10px;text-align: left;vertical-align: top;}
    th {background-color: #eee;}
    code {background: #eee;padding: 2px 0px;border-radius: 4px;font-family: 'Courier New', Courier, monospace;font-size: 95%;}
    pre {background: #272822;padding: 15px;border-radius: 8px;overflow-x: auto;font-size: 90%;margin-bottom: 2em;}
    pre code {background: none;font-family: 'Courier New', Courier, monospace;font-size: 90%;}
    p strong {color: #444;}
  </style>
</head>
<body>


<div class="navbar">
  <a href="#home">Home</a>
  <a href="#quickstart">Quickstart</a>
  <a href="#smo">Runtypes</a>
  <a href="#buffers">Buffers</a>
  <a href="#std">Std</a>
</div>

<div class="container">

<h1 id="home">smoλ</h1>

<p><em>A safe & fast low-level language.</em></p>

<p><i>Smoλ</i> creates zero-cost abstractions for managing data and functions.
Its core is tiny — really tiny! So tiny, in fact, that functions like printing and basic
arithmetic operators are part of the standard library.
There's a direct-to-C++ interface for extensible functionality
beyond few basic keywords.</p></p>

<p><strong>Dependencies:</strong> GCC<br>
<strong>Contact:</strong> Emmanouil (Manios) Krasanakis<br>
<strong>License:</strong> Apache 2.0</p>

<h1 id="quickstart">Quickstart</h1>

<p>Look at an example program:</p>

<pre><code class="language-smolambda">@include std

smo Point(i64 x, i64 y) -> @new
smo Field(Point start, Point end) -> @new

service main()
    p = Point(3,4)
    f = Field(1,2,p)
    print(f.start.x)
    print(f.end.y)
    i = add(f.start.x, f.start.y)
    print(i)
    --
</code></pre>

<p>The <code class="language-smolambda">@include</code> directive includes
files directly. For safety, this cannot occur within definitions.
Circular dependencies or re-imports are not allowed either. We use the
<a href="#std">standard library</a>, but you may create your own flavor.</p>

<p>Next are some so-called <i>runtype</i> definitions, indicated by the <code class="language-smolambda">smo</code>
keyword. These merge the concept of ypes of functions, where the keyword <code class="language-smolambda">-></code>
returns a value or tuple. If variable names are part of the returned tuple, this can be accessed as fields
from the result. <code class="language-smolambda">@new</code> is a shorthand for
returning a tuple of all internal declarations.</p>

<p>Once you write something like <code class="language-smolambda">p = Point(...)</code>,
you can access all returned name values using
<code class="language-smolambda">p.x</code> and <code class="language-smolambda">p.y</code>.
You can also unpack the result as part of a tuple.
For example, <code class="language-smolambda">p1 = Point(p)</code> is equivalent to
<code class="language-smolambda">Point p1(p.x, p.y)</code>.
Unpacking creates a flat tuple (not a tuple of tuples) that can be reinterpreted in various ways
as long as primitive types match.</p>

<p>Put all main business logic inside a <code class="language-smolambda">service main()</code> definition.
Being a service means that
errors occuring inside are "caught", perform safe allocation and deallocation, and do not
escape to the any services calling it other than changing the result. More on this later.
The main service is the entry point of all programs and returns no value, as indicated by
the <code class="language-smolambda">--</code> at its end. More on accepting arguments
later.</p>

<h1 id="smo">Runtypes</h1>

<p>Types and functions are the same thing in <i>smoλ</i>
and marked as <code class="language-smolambda">smo</code> followed by a name
and a parenthesis with some arguments.
We call the merged concept <i>runtypes</i>.
Let's start with a definition from the standard library:</p>

<pre><code class="language-smolambda">smo add(i64 x, i64 y)
    @body{i64 z=x+y;}
    -> z
</code></pre>

<p>This tells us that we are defining an integer addition runtype with the corresponding arguments.
The definition is inlined when used, which is more optimization-friendly than simple C++. This is achieved
because, despite the illusion of typing, everything is direct variable operations. For example
<code class="language-smolambda">f.start.x</code> is represented by <code class="language-smolambda">f__start__x</code>
under the hood.</p>

<p>Return a value or tuple of values with <code class="language-smolambda">-&gt;</code>,
and use <code class="language-smolambda">@body</code> to write C++ code directly.
If you don't want to return anything, use <code class="language-smolambda">--</code>.
These symbols form visual barriers that are easy to spot while remaining, well, small.
Note that <i>smoλ</i> does not require semicolons becase boundaries are unique:
everything ends at return statements, at the end of file, or resides in between
parentheses and commas.</p>

<h3>Mutability</h3>


<p>Local variables are overwritten as code runs. However, runtypes are called by value,
<!-- that is, without affecting their arguments. You can change this by prepending -->
<code class="language-smolambda">&</code> to the variable name in the signature,
in which case internal modifications are retained. Below is an example.</p>

<pre><code class="language-smolambda">@include std

smo inc(i64 &x)
    x = add(x,1)
    --

service main()
    x = 1
    inc(x)
    print(x) // 2
</code></pre>


<h3>Currying</h3>
<p>Runtypes accept currying notation that transfers a computed value to the arguments of the next call.
This can be chained. The curry operator is <code class="language-smolambda">|</code>.
If you have multiple calls in the currying chain, preffer placing those at separate lines. This is only
a stylistic choice, as currying maintains the language's deterministic understanding of where expressions end.
</p>

<p>This feature lets <i>smoλ</i> avoid having methods as fields, as the notation <code class="language-smolambda">obj|rt(args)</code>
can do this. Recall that mutability should be explicitly declared if you want <i>rt</i> to have side-effects.
</p>

<pre><code class="language-smolambda">@include std

service main()
    1
    | add(2)
    | mul(3)
    | print()
    // equivalent to print(mul(add(1,2), 3))
</code></pre>


<h3>Fields</h3>

<p>The assignment operator copies the outcome of function calls to variables.
However, only returned symbols can be accessed as fields.
For example, below the input variable <code class="language-smolambda">x</code>
cannot be accessed after computations conclude. If you return the outcome of some
computations, this is not exposed either.
</p>

<p>We already saw that it may be convenient to unpack all runtype inputs with
<code class="language-smolambda">@new</code> to directly declare a structural type
without internal implementation.
</p>

<pre><code class="language-smolambda">@include std

smo Test(i64 x)
    incx = add(x,1)
    -> incx

service main()
    p = Test(1)
    print(p.incx)
    print(p.x) // CREATES AN ERROR
</code></pre>


<h3>Overloading</h3>

<p>Overload runtypes that are structurally
different when converted to a flat representation of primitives.
After overloading, runtypes cannot be used as part of
function signatures due to ambiguity, but their usage is substituted dynamically.
The following definitions come from the standard library.</p>

<pre><code class="language-smolambda">smo print(f64 message)
    @head{#include &lt;stdio.h>}
    @body{printf("%.6f\n", message);}
    --
smo print(i64 message)
    @head{#include &lt;stdio.h>}
    @body{printf("%ld\n", message);}
    --
smo add(i64 x, i64 y) @body{i64 z=x+y;} -> z
smo add(f64 x, f64 y) @body{f64 z=x+y;} -> z

service main()
    print(add(1,1)) // 2
    print(add(0.2,0.3)) // 0.5
</code></pre>

<h1 id="buffers">Buffers</h1>

<p>Handle dynamic memory with the special <code class="language-smolambda">buffer</code> runtype.
Think of this as a list where new data are pushed to the back and popped from the front. The
definition is part of the language and it is how one would handle functions with variadic inputs too.
</p>

<p>Buffers are unpacked into other runtypes by consuming elements from their start.
However, unpacking feasibility is checked at runtime. Memory deallocation is safe, occurs
always -even if runtime errors occur to terminate a service-
and is injected automatically by <i>smoλ</i>. That said, data are stored in buffers without
even primitive types and unpacking relies solely on the programmer.</p>

<p>Buffer elements are unpacked from the front until no
more entries are required for desired runtype calls.
Popping is memory safe in that it smoothly fails any service
(e.g., <code class="language-smolambda">main</code>)
with an appropriate error messages.
</p>

<pre><code class="language-smolambda">@include std

smo Point(i64 x, i64 y) -> @new
smo Field(Point start, Point end) -> @new

service main()
    buf = buffer(1,2,3,4,5)
    f = Field(buf)
    print(f.start.x) // 1
    print(i64(buf)) // 5
</code></pre>

<h3>Slicing</h3>

Buffers can be sliced to obtain a sub-view of elements. This happens irrespectively
of other operations applied on the original. Slices use square brackets and either contain a
<code class="language-smolambda">u64</code> number indicating a starting element to be followed
to the end, or contain starting and non-inclusive end elements separated by a double colon.
Below is an example that demonstrates element access.
<i>All operations are near-zero-cost abstractions, with the exception that a slice with specified
end checks for bounds.</i>


<pre><code class="language-smolambda">@include std

service main()
    buf = buffer(0,1,2,3,4,5)
    slice = buf[u64(1):u64(3)]
    print(i64(slice))        // 1 (pops front from slice)
    print(i64(buf[u64(0)]))  // 0 (buf[0] is also a slice)
    print(i64(buf))          // 0
    print(i64(slice))        // 2 (slice remains unaffected)
    print(i64(slice))        // CREATES RUNTIME ERROR
</code></pre>

<h3>Concatenation</h3>

<p>Normally, you can have a buffer as the last argument so that popping knows how many elements
it needs to consume. However, you can have several buffer arguments if you are creating a new one.
This operation moves all corresponding memory.
An example follows.</p>


<pre><code class="language-smolambda">@include std

smo Point(i64 x, i64 y) -> @new

service main()
    buf1 = buffer(1,2)
    buf2 = buffer(3,4)
    buf = buf1
          | copy()
          | push(buf2)
    // buf1 and buf2 are empty now
    p1 = Point(buf)
    p2 = Point(buf)
    print(p1.x) // 1
    print(p2.y) // 4
</code></pre>

<h1 id="std">Std</h1>

<p>Conditional <code class="language-smolambda">if</code> statements are second-class citizens in <i>smoλ</i>
and are manually implemented in the standard library.
They do no accept an alternative branch.
Either run multiple of those, or enclose them in the <code class="language-smolambda">scope</code>
runtype. The latter creates an independent scope from which you can return. An example follows.
</p>


<pre><code class="language-smolambda">@include std

smo print_sign(i64 i)
    sgn = do
      if(i|gt(0)) -> 1
      if(i|lt(0)) -> -1
      -> 0
    print(sgn)
    --

service main()
    print_sign(100)
    print_sign(-42)
</code></pre>

<p>Like all runtypes, you can return values from conditional statements. If the condition
does not run, variables are zeroed out as default behavior.
</p>

<pre><code class="language-smolambda">@include std

service sign(i64 i)
    if(gt(i,0)) --> 1
    if(lt(i,0)) --> -1
    -> 0

service main()
    x = sign(100)
    y = sign(-42)
    print(x)
    print(y)
</code></pre>


</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script>
Prism.languages.smolambda = {
  'comment': /\/\/.*/,
  'directive': {
    pattern: /@\w+/,
    alias: 'important'
  },
  'keyword': [
    {
      pattern: /\b(?:smo|service|if|else|include|do|while)\b/,
      greedy: true
    },
    {
      pattern: /(?:-->|->|--|\||\=)/,
      greedy: true
    }
  ],
  'builtin': /\b(?:i64|u64|f64|ptr|str|buffer|main|copy|push)\b/,
  'punctuation': /[{}();,\[\]]/,
  'number': /\b\d+\b/,
  'string': {
    pattern: /"(?:\\.|[^"\\])*"/,
    greedy: true
  }
};
</script>


</body>
</html>
