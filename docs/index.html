<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>smoλ</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
  <style>
    html {scroll-behavior: smooth;}
    h1 {scroll-margin-top: 60px;}
    h2 {scroll-margin-top: 60px;}
    body {font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;margin: 0;background-color: #f9f9f9;color: #333;line-height: 1.7;}
    .navbar {background-color: #333;padding: 2px;position: sticky;top: 0;z-index: 1000;display: flex;flex-wrap: wrap;justify-content: center;}
    .navbar a {color: white;text-decoration: none;padding: 5px 10px;font-weight: bold;}
    .navbar a:hover {background-color: #555;}//{text-decoration: underline;}
    .container {max-width: 800px;margin: 40px auto;padding: 0 20px;}
    h1, h2, h3 {color: #222;}
    table {width: 100%;border-collapse: collapse;margin-bottom: 2em;background-color: white;}
    th, td {border: 1px solid #ccc;padding: 10px;text-align: left;vertical-align: top;}
    th {background-color: #eee;}
    code {background: #eee;padding: 2px 0px;border-radius: 4px;font-family: 'Courier New', Courier, monospace;font-size: 95%;}
    pre {background: #272822;padding: 15px;border-radius: 8px;overflow-x: auto;font-size: 90%;margin-bottom: 2em;}
    pre code {background: none;font-family: 'Courier New', Courier, monospace;font-size: 90%;}
    p strong {color: #444;}
  </style>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
</head>
<body>


<div class="navbar">
  <a href="#home">Home</a>
  <a href="#quickstart">Quickstart</a>
  <a href="#smo">Runtypes</a>
  <a href="#service">Services</a>
  <a href="#buffers">Buffers</a>
  <a href="#std">Std</a>
</div>

<div class="container">

<h1 id="home">smoλ <a href="https://github.com/maniospas/smol" target="_blank" title="GitHub">
<i class="fab fa-github"></i>
</a></h1>

<p><em>A safe & fast low-level language.</em>
</p>

<p><i>Smoλ</i> creates zero-cost abstractions for managing data and functions.
Its core is tiny — really tiny! So tiny, in fact, that functions like printing and basic
arithmetic operators are part of the standard library.
There's a direct-to-C++ interface for extensible functionality.</p></p>


<h1 id="quickstart">Quickstart</h1>

<p>Look at an example program:</p>

<pre><code class="language-smolambda">@include std

smo Point(i64 x, i64 y) -> @new
smo Field(Point start, Point end) -> @new

service main()
    p = Point(3,4)
    f = Field(1,2,p)
    print(f.start.x)
    print(f.end.y)
    i = add(f.start.x, f.start.y)
    print(i)
    --
</code></pre>

<p>First, <code class="language-smolambda">@include</code> brings code from
other files with the <i>.s</i> extension. Paths are separated by dots.
For safety, includes cannot occur within definitions.
Circular dependencies or re-imports are not allowed either. Here we use the
<a href="#std">standard library</a>, but you may create your own flavor.</p>

<p>Next are some so-called <i>runtype</i> definitions, indicated by the <code class="language-smolambda">smo</code>
keyword. These merge the concept of types and functions, where the keyword <code class="language-smolambda">-></code>
returns a value or tuple. If variable names are part of the returned tuple, they can be accessed as fields
from the result. <code class="language-smolambda">@new</code> is a shorthand for
returning a tuple of all arguments, which is useful for declaring structural data without any functionality.</p>

<p>Once you write something like <code class="language-smolambda">p = Point(...)</code>,
you can access all returned named variables using notation like
<code class="language-smolambda">p.x</code> and <code class="language-smolambda">p.y</code>.
You can also unpack the result as part of arguments to other runtypes. Arguments are always flat
(there is no tuple of tuples) and can be reinterpreted in various ways
as long as primitive types match. Safety options for this appear later.</p>

<p>Put all main business logic inside a <code class="language-smolambda">service main()</code> definition.
Being a service means that errors occuring inside are "caught", perform safe allocation and deallocation,
and do not escape to any code calling it. More on services also later.
For now, know that the main service is the entry point of programs and returns no value, as indicated by
the <code class="language-smolambda">--</code> symbol at its end.</p>

<h1 id="smo">Runtypes</h1>

<p>Types and functions are the same thing in <i>smoλ</i>
and marked as <code class="language-smolambda">smo</code> followed by a name
and a parenthesis with some arguments.
We call the merged concept <i>runtypes</i>.
As an example, look at a definition from the standard library,
which also gives a taste of the C++ ABI:</p>

<pre><code class="language-smolambda">smo add(i64 x, i64 y)
    @body{i64 z=x+y;}
    -> z
</code></pre>

<p>This tells us that we are defining an integer addition runtype with the corresponding arguments.
When called from other code, the definition is inlined in an optimization-friendly way. For example,
despite the illusion of typing, everything consists of direct variable operations; under the hood, field access like
<code class="language-smolambda">f.start.x</code> is replaced with variables like <code class="language-smolambda">f__start__x</code>.</p>

<p>Return a value or tuple of values with <code class="language-smolambda">-&gt;</code>,
and use <code class="language-smolambda">@body</code> to write C++ code. The ABI is described
later, but for now notice that a perfunctory scan is also made in that code to expose primitive
types.
</p>
<p>
If you don't want to return anything, use <code class="language-smolambda">--</code>.
Return symbols form visual barriers that are easy to spot while remaining ... small.
Note that <i>smoλ</i> does not require semicolons becase boundaries are unique:
everything ends at return statements, at the end of file, or resides in-between
parentheses and commas.</p>


<h3>Mutability (call by reference)</h3>

<p>Runtypes are called by value,
that is, without internal computations affecting external arguments. You can make
calls occur by reference by prepending
<code class="language-smolambda">&</code> to variable names in the signature. In this case,
internal modifications are retained. Below is an example.</p>

<pre><code class="language-smolambda">@include std

smo inc(i64 &x)
    x = add(x,1)
    --

service main()
    x = 1
    inc(x)
    print(x) // 2
</code></pre>


<h3>Currying</h3>
<p>Runtype calls accept currying notation that transfers a precomputed value to the first argument.
The curry operator is <code class="language-smolambda">|</code> and can be chained.
If you have multiple calls in the currying chain, preffer placing those at separate lines. This is only
a stylistic choice.
</p>

<p>Currying feature lets <i>smoλ</i> avoid methods as fields, as the notation <code class="language-smolambda">obj|rt(args)</code>
is conceptually similar. Note that mutability should be explicitly declared if you want <code class="language-smolambda">rt</code>
to have side-effects.
</p>

<pre><code class="language-smolambda">@include std

service main()
    1
    | add(2)
    | mul(3)
    | print()
    // equivalent to print(mul(add(1,2), 3))
</code></pre>


<h3>Fields</h3>

<p>The assignment operator copies the outcome of function calls to variables.
However, only returned symbols can be accessed as fields.
For example, below the input variable <code class="language-smolambda">x</code>
cannot be accessed after computations conclude. If you return the outcome of some
computations without packing it into a comma-separated tuple, this is not exposed either.
</p>

<p>We already saw that it may be convenient to unpack all runtype inputs with
<code class="language-smolambda">@new</code> to directly declare a structural type
without internal implementation.
</p>

<pre><code class="language-smolambda">@include std

smo Test(i64 x)
    incx = add(x,1)
    -> incx

service main()
    p = Test(1)
    print(p.incx)
    print(p.x) // CREATES AN ERROR
</code></pre>


<h3>Overloading</h3>

<p>Overload runtypes that are structurally
different when converted to a flat representation of primitives.
Runtypes equivalent in terms of primitives cannot be used as part of
function signatures due to ambiguity. More on circumventing this issue later.
As an example, the following definitions come from the standard library.</p>

<pre><code class="language-smolambda">smo print(f64 message)
    @head{#include &lt;stdio.h>}
    @body{printf("%.6f\n", message);}
    --
smo print(i64 message)
    @head{#include &lt;stdio.h>}
    @body{printf("%ld\n", message);}
    --
smo add(i64 x, i64 y) @body{i64 z=x+y;} -> z
smo add(f64 x, f64 y) @body{f64 z=x+y;} -> z

service main()
    print(add(1,1)) // 2
    print(add(0.2,0.3)) // 0.5
</code></pre>


<h3>Call by type</h3>

<p>
You might want to choose a runtype's version based on another without actually passing data. For example,
something different should be called based on the expected outcome. In those cases, you can skip
declaring variable names in signatures, and you can ommit parenthesis-based argumets that would create dummy data.
</p>
<p>
Below is a segment of the standard library that shows how the correct version of
an evoked method is applied. Runtypes without
parentheses refer to zeroed out input data.
You can also use a value as reference - that would be ignored.</p>

<pre><code class="language-smolambda">smo not(bool x) @body{bool z=!x;} -> z
smo print(f64 message)
    @head{#include &lt;stdio.h>}
    @body{printf("%.6f\n", message);}
    --
smo read(i64)
    @head{#include &lt;stdio.h>}
    @body{i64 number = 0; bool success = scanf("%ld", &number);}
    if(success|not()) @fail{printf("Invalid integer\n");} --
    -> number
smo read(f64)
    @head{#include &lt;stdio.h>}
    @body{f64 number = 0; bool success = scanf("%lf", &number);}
    if(success|not()) @fail{printf("Invalid number\n");} --
    -> number

service main()
    x = read(f64)
    print(x)
</code></pre>



<h3>Unions</h3>
<p>Sometimes, you want to define code that is automatically adjusted to different runtypes.
This can be achieved by declaring runtype unions, which are resolved to one of their
options. The resolution persists to dependent calls, so yo can create different ones for independence.
Unions are resolved during compilation and, like many features of <i>smoλ</i>, are zero-cost
abstractions. They can also unpack unions provided as arguments.</p>

<p>
For example, the <code class="language-smolambda">Type</code> union
below is determined to be <code class="language-smolambda">f64</code> while
calling <code class="language-smolambda">inc</code> to match the <code class="language-smolambda">Point</code>
argument and carries over to the internal
implementation. Therefore, the <code class="language-smolambda">f64</code> primitive is used for reading, constructing
a two-dimensional point, for casting the value of <i>1</i> to the appropriate type,
and calling the corresponding overloaded addition.
Unions account for overloads of their options up to the point
where they are defined.</p>

<pre><code class="language-smolambda">@include std

union Type(i64, f64, u64)
smo Point(Type x, Type y) -> @new
smo inc(Point &p)
    p.x = add(p.x, Type(1))
    p.y = add(p.y, Type(1))
    --

service main()
    value = f64|read()
    p = Point(value, value)
    p|inc()
    print(p.x)

</code></pre>


<h1 id="service">Services</h1>

<p>So far we have been writting <code class="language-smolambda">service main()</code> as the entrant
point of programs. Armed with the basics, we can now look at what that <i>service</i> keyword is all about. 
Functionally, services as runtypes with nameless returned values. That is, their returns are unpacked and 
can be parts of arguments normally, but do not accept field access because it would be either unsafe or create
too many hidden computational costs. More on why later</p>
<p>
Below is an example of declaring and calling a service. Syntactially, this is near-identical to working
with runtypes so that it's easy to change your mind as you write code. 
You will often not notice anything different in most code containing service calls.
</p>

<pre><code class="language-smolambda">@include std

service square(f64 x) -> mul(x,x)
service main()
    y = square(2.0)
    print(y)
</code></pre>

<h3>Why services?</h3>

<p>
From the viewpoint of merging types and functions, services are a step backwards in that they are basically 
functions with multiple returns. They further incur a cost of a few operations per call, as well as pushing the
call to the stack - if GCC determines they should not be inlined. So it is not advised
to call them millions of time per per second.
</p>
<p>
That said, they have three distinct advantages:
a) they run independently and in parallel, b) they can call each other regardless of definitions order, 
and even allow recursion (by comparison, simpler runtypes can only "see" previous runtype and service declarations), 
and c) they provide a compartmenized execution environment that does not let internal errors escape.
</p>

<h3>Error handling</h3>

<p>
The last point means that, after calling a service within another one,
you need to think of how to handle prospective errors. The pattern discussed 
so far is to blindly unpacking results into further service and runtime calls.
This elegantly fails if an error was previously returned by cascading that error
through the call stack. All those services fail safely by deallocating resources. 
</p>


<pre><code class="language-smolambda">@include std

service square(f64 x) 
    fail("Don't wanna!") // manually fail
    -> mul(x,x)
service main()
    y = square(2.0)
    print(y)
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
Don't wanna!
Runtime error: `square y` contains an error
</pre>

<p>
You can check for the error code of errors by accessing them from the service's result per
<code class="language-smolambda">result.err</code>. By convention, error codes are skipped
when unpacking services, essentially reserving field access for error handling but retaining
usage in further code.
</p>

<pre><code class="language-smolambda">@include std
    
service square(f64 x) 
    fail("Don't wanna!") // manually fail
    -> mul(x,x)
service main()
    y = square(2.0)
    if(y.err|bool())
        print("Something went wrong")
        y = 0
        --
    print(y)
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
Don't wanna!
Something went wrong
0
</pre>


<h1 id="buffers">Buffers</h1>

<p>Handle dynamic memory with the special <code class="language-smolambda">buffer</code> runtype.
Think of this as a list where new data are pushed to the back and popped from the front. The
definition is part of the language and it is how one would handle functions with variadic inputs too.
</p>

<p>Buffers are unpacked into other runtypes by consuming elements from their start.
However, unpacking feasibility is checked at runtime. Memory deallocation is safe, occurs
always -even if runtime errors occur to terminate a service-
and is injected automatically by <i>smoλ</i>. That said, data are stored in buffers without
even primitive types and unpacking relies solely on the programmer.</p>

<p>Buffer elements are unpacked from the front until no
more entries are required for desired runtype calls.
Popping is memory safe in that it smoothly fails any service
(e.g., <code class="language-smolambda">main</code>)
with an appropriate error message.
</p>

<pre><code class="language-smolambda">@include std

smo Point(i64 x, i64 y) -> @new
smo Field(Point start, Point end) -> @new

service main()
    buf = buffer(1,2,3,4,5)
    f = Field(buf)
    print(f.start.x) // 1
    print(i64(buf)) // 5
</code></pre>

<h3>Slicing</h3>

Buffers can be sliced to obtain a sub-view of elements. This happens irrespectively
of other operations applied on the original. Slices use square brackets and either contain a
<code class="language-smolambda">u64</code> number indicating a starting element to be followed
to the end, or contain starting and non-inclusive end elements separated by a double colon.
Below is an example that demonstrates element access.
<i>All operations are near-zero-cost abstractions, with the exception that a slice with specified
end checks for bounds.</i>


<pre><code class="language-smolambda">@include std

service main()
    buf = buffer(0,1,2,3,4,5)
    slice = buf[u64(1):u64(3)]
    print(i64(slice))        // 1 (pops front from slice)
    print(i64(buf[u64(0)]))  // 0 (buf[0] is also a slice)
    print(i64(buf))          // 0
    print(i64(slice))        // 2 (slice remains unaffected)
    print(i64(slice))        // CREATES RUNTIME ERROR
</code></pre>

<h3>Concatenation</h3>

<p>Normally, you can have a buffer as the last argument so that popping knows how many elements
it needs to consume. The language offers three operations for buffers:
<code class="language-smolambda">reserve</code> preallocates memory
(for optimization, otherwise size is doubled when needed),
<code class="language-smolambda">push</code> adds data at the end,
<code class="language-smolambda">copy</code> copies contents without
altering the original, and
assigning inserts data at the beginning as long as the size is compatible</p>


<pre><code class="language-smolambda">@include std

smo Point(i64 x, i64 y) -> @new

service main()
    buf1 = buffer(1,2)
    buf2 = buffer()|reserve(2)|push(3,4)
    buf = buf1
          | copy()
          | push(buf2.copy())
    // buf1 and buf2 are empty now
    p1 = Point(buf)
    p2 = Point(buf)
    print(p1.x) // 1
    print(p2.y) // 4
</code></pre>

<h1 id="std">Std</h1>

<p>Conditional <code class="language-smolambda">if</code> statements are second-class citizens in <i>smoλ</i>
and are manually implemented in the standard library.
They do no accept an alternative branch.
Either run multiple of those, or enclose them in the <code class="language-smolambda">scope</code>
runtype. The latter creates an independent scope from which you can return. An example follows.
</p>


<pre><code class="language-smolambda">@include std

smo print_sign(i64 i)
    sgn = do
      if(i|gt(0)) -> 1
      if(i|lt(0)) -> -1
      -> 0
    print(sgn)
    --

service main()
    print_sign(100)
    print_sign(-42)
</code></pre>

<p>Like all runtypes, you can return values from conditional statements. If the condition
does not run, variables are zeroed out as default behavior.
</p>

<pre><code class="language-smolambda">@include std

service sign(i64 i)
    if(gt(i,0)) --> 1
    if(lt(i,0)) --> -1
    -> 0

service main()
    x = sign(100)
    y = sign(-42)
    print(x)
    print(y)
</code></pre>


</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script>
Prism.languages.smolambda = {
  'comment': /\/\/.*/,
  'directive': {
    pattern: /@\w+/,
    alias: 'important'
  },
  'keyword': [
    {
      pattern: /\b(?:smo|service|if|else|include|do|while|union)\b/,
      greedy: true
    },
    {
      pattern: /(?:-->|->|--|\||\=)/,
      greedy: true
    }
  ],
  'builtin': /\b(?:i64|u64|f64|ptr|str|buffer|main|copy|push)\b/,
  'punctuation': /[{}();,\[\]]/,
  'number': /\b\d+\b/,
  'string': {
    pattern: /"(?:\\.|[^"\\])*"/,
    greedy: true
  }
};
</script>


</body>
</html>
