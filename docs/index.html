<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>smoλ</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
  <style>
    html {scroll-behavior: smooth;}
    h1 {scroll-margin-top: 60px;}
    h2 {scroll-margin-top: 60px;}
    body {font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;margin: 0;background-color: #f9f9f9;color: #333;line-height: 1.7;}
    .navbar {background-color: #333;padding: 2px;position: sticky;top: 0;z-index: 1000;display: flex;flex-wrap: wrap;justify-content: center;}
    .navbar a {color: white;text-decoration: none;padding: 5px 10px;font-weight: bold;}
    .navbar a:hover {background-color: #555;}//{text-decoration: underline;}
    .container {max-width: 800px;margin: 40px auto;padding: 0 20px;}
    h1, h2, h3 {color: #222;}
    table {width: 100%;border-collapse: collapse;margin-bottom: 2em;background-color: white;}
    th, td {border: 1px solid #ccc;padding: 10px;text-align: left;vertical-align: top;}
    th {background-color: #eee;}
    code {background: #eee;padding: 2px 0px;border-radius: 4px;font-family: 'Courier New', Courier, monospace;font-size: 95%;}
    pre {background: #272822;padding: 15px;border-radius: 8px;overflow-x: auto;font-size: 90%;margin-bottom: 2em;}
    pre code {background: none;font-family: 'Courier New', Courier, monospace;font-size: 90%;}
    p strong {color: #444;}
  </style>
</head>
<body>


<div class="navbar">
  <a href="#home">Home</a>
  <a href="#quickstart">Quickstart</a>
  <a href="#smo">Runtypes</a>
  <a href="#buffers">Buffers</a>
  <a href="#std">Std</a>
</div>

<div class="container">

<h1 id="home">smoλ</h1>

<p><em>A safe & fast low-level language.</em></p>

<p><i>Smoλ</i> creates zero-cost abstractions for managing data and functions.
Its core is tiny — really tiny! So tiny, in fact, that print functions, conditions,
and basic arithmetic operators are part of the standard library.
But there's a direct-to-C++ interface for extensible functionality.
The only built-in elements are a few basic keywords.</p></p>

<p><strong>Dependencies:</strong> GCC<br>
<strong>Contact:</strong> Emmanouil (Manios) Krasanakis<br>
<strong>License:</strong> Apache 2.0</p>

<h1 id="quickstart">Quickstart</h1>

<p>Look at an example program:</p>

<pre><code class="language-smolambda">@include std

smo Point(i64 x, i64 y) -> @new
smo Field(Point start, Point end) -> @new

smo main()
    p = Point(3,4)
    f = Field(1,2,p)
    print(f.start.x)
    print(f.end.y)
    i = add(f.start.x, f.start.y)
    print(i)
</code></pre>

<p>The <code class="language-smolambda">@include</code> directive includes
files directly. For safety, this cannot occur within definitions.
Circular dependencies or re-imports are not allowed either. We use the
<a href="#std">standard library</a>, but you may create your own flavor.</p>

<p>Next are some so-called <i>runtype</i> definitions, indicated by the <code class="language-smolambda">smo</code>
keyword. These merge the concept of ypes of functions, where the keyword <code class="language-smolambda">-></code>
returns a value or tuple. If variable names are part of the returned tuple, this can be accessed as fields
from the result. <code class="language-smolambda">@new</code> is a shorthand for
returning a tuple of all internal declarations.</p>

<p>Once you write something like <code class="language-smolambda">p = Point(...)</code>,
you can access all returned name values using
<code class="language-smolambda">p.x</code> and <code class="language-smolambda">p.y</code>.
You can also unpack the result as part of a tuple.
For example, <code class="language-smolambda">p1 = Point(p)</code> is equivalent to
<code class="language-smolambda">Point p1(p.x, p.y)</code>.
Unpacking creates a flat tuple (not a tuple of tuples) that can be reinterpreted in various ways
as long as primitive types match.</p>

<p>Put all main business logic inside a <code class="language-smolambda">main</code> definition.

<h1 id="smo">Runtypes</h1>

<p>Types and functions are the same thing in <i>smoλ</i>
and marked as <code class="language-smolambda">smo</code>. We call the merged concept <i>runtypes</i>.
Let's start with a definition from the standard library:</p>

<pre><code class="language-smolambda">smo add(i64 x, i64 y)
    @body{i64 z=x+y;}
    -> z
</code></pre>

<p>This tells us that we are defining an integer addition runtype with the corresponding arguments.
The definition is inlined when used, which is more optimization-friendly than simple C++ instructions because,
despite the illusion of typing, everything is direct variable operations. For example
<code class="language-smolambda">f.start.x</code> is represented by <code class="language-smolambda">f__start__x</code>
under the hood. As a result, much more aggressive optimizations than normal are applicable.</p>

<p>Return a value or tuple of values with <code class="language-smolambda">-&gt;</code>,
and use <code class="language-smolambda">@body</code> to write C++ code directly.
If you don't want to return anything, use <code class="language-smolambda">--</code>.
These symbols form visual barriers that are easy to spot while remaining, well, small.
Note that <i>smoλ</i> does not require semicolons becase boundaries are unique:
everything ends at return statements or at the end of file, or resides in a parenthesis.</p>

<h3>Locality</h3>

<p>The assignment operator copies the outcome of function calls to variables.
However, this grants access only to returned values and not intermediate ones.
For example, below the input variable is not preserved in the output.
</p>

<pre><code class="language-smolambda">@include std

smo Test(i64 x)
    incx = add(x,1)
    -> incx

smo main()
    p = Test(1)
    print(p.x) // CREATES AN ERROR
</code></pre>


<h3>Overloading</h3>

<p>Overload runtypes that are structurally
different when converted to a flat representation of primitives.
After overloading, types cannot be used in function signatures
due to ambiguity but their usage is subsituted dynamically.
The following definitions come from the standard library.</p>

<pre><code class="language-smolambda">smo print(f64 message)
    @head{#include &lt;stdio.h>}
    @body{printf("%.6f\n", message);}
    --
smo print(i64 message)
    @head{#include &lt;stdio.h>}
    @body{printf("%ld\n", message);}
    --
smo add(i64 x, i64 y) @body{i64 z=x+y;} -> z
smo add(f64 x, f64 y) @body{f64 z=x+y;} -> z

smo main()
    print(add(1,1)) // 2
    print(add(0.2,0.3)) // 0.5
</code></pre>

<h1 id="buffers">Buffers</h1>

<p>Handle dynamic memory with the special <code class="language-smolambda">buffer</code> runtype.
Think of this as a list where new data are pushed to the back and popped from the front. There is
no equivalent definition, and it is part of the language.
Buffers can be moved around normally, and stored in data types. Memory deallocation is safe, occurs
always -even if runtime errors occur to terminate a service-
and is injected automatically by <i>smoλ</i>. However,
<i>data are stored in buffers without their type</i>.
See next on how to also make this safe.</p>

<p>The front of buffers can be unpacked, which is equivalent to front-popping until no
more entries are required. This can be performed only by unpacking to a desired type.
Popping is memory safe in that it smoothly fails the service (e.g., <code class="language-smolambda">main</code>)
with an appropriate error message
</p>

<pre><code class="language-smolambda">@include std

smo Point(i64 x, i64 y) -> @new
smo Field(Point start, Point end) -> @new

smo main()
    buffer buf(1,2,3,4,5)
    Field f(buf)
    print(f.start.x) // 1
    print(i64(buf)) // 5
</code></pre>



<p>Normally, you can have a buffer as the large argument so that popping knows how many elements
it needs to consume. However, you can have several buffer arguments if you are creating a new one.
This operation moves all corresponding memory.
An example follows.</p>


<pre><code class="language-smolambda">@include std

smo Point(i64 x, i64 y) -> @new

smo main()
    buffer buf1(1,2)
    buffer buf2(3,4)
    buffer buf(buf1, buf2)
    // buf1 and buf2 are empty now
    Point p1(buf)
    Point p2(buf)
    print(p1.x) // 1
    print(p2.y) // 4
</code></pre>

<i>Buffers follow linear logic in that data stored in them cannot be copied or lost - only consumed.
This prevents exploding memory usage, as dynamic memory can only be explicitly allocated.</i>


<h1 id="std">Std</h1>

<p>Conditional <code class="language-smolambda">if</code> statements are second-class citizens in <i>smoλ</i>
and are manually implemented in the standard library.
They do no accept an alternative branch.
Either run multiple of those, or enclose them in the <code class="language-smolambda">scope</code>
runtype. The latter creates an independent scope from which you can return. An example follows.
</p>


<pre><code class="language-smolambda">@include std
smo sgn(i64 i)
    scope()
      if(gt(i,0)) ->> 1
      if(lt(i,0)) ->> -1
      -> 0
</code></pre>

<p>Like all runtypes, you can return values from conditional statements. If the condition
does not run, variables obtain a default <code class="language-smolambda">0</code> value.
The language offers <code class="language-smolambda">@else</code> followed by a primitive
as a way to set default values for primitives. Below is an example:
</p>

<pre><code class="language-smolambda">@include std
smo main()
    i = 0
    value = if(ge(i,0)) -> 1 else -1
    print(value)
</code></pre>


</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script>
Prism.languages.smolambda = {
  'comment': /\/\/.*/,
  'directive': {
    pattern: /@\w+/,
    alias: 'important'
  },
  'keyword': [
    {
      pattern: /\b(?:smo|service|if|else|include)\b/,
      greedy: true
    },
    {
      pattern: /(?:->>|->|--)/,
      greedy: true
    }
  ],
  'builtin': /\b(?:i64|u64|f64|ptr|str|buffer|main)\b/,
  'punctuation': /[{}();,]/,
  'number': /\b\d+\b/,
  'string': {
    pattern: /"(?:\\.|[^"\\])*"/,
    greedy: true
  }
};
</script>


</body>
</html>
