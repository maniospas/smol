<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Smoλ is a low-level language with fast zero-cost abstractions that are organized into failsafe services.">
  <meta name="keywords" content="smolambda, low-level language, smoλ, programming language, runtype, safe language, systems programming, DSL">
  <meta name="author" content="Emmanouil (Manios) Krasanakis">
  <meta name="robots" content="index, follow">


  <title>smoλ</title>
  <link href="vendor/prism/prism.min.css" rel="stylesheet" />
  <style>
    html {scroll-behavior: smooth;}
    h1 {scroll-margin-top: 60px;}
    h2 {scroll-margin-top: 60px;}
    body {font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;margin: 0;background-color: #f9f9f9;color: #333;line-height: 1.7;}
    .navbar {background-color: #333;padding: 2px;position: sticky;top: 0;z-index: 1000;display: flex;flex-wrap: wrap;justify-content: center;}
    .navbar a {color: white;text-decoration: none;padding: 5px 10px;font-weight: bold;}
    .navbar a:hover {background-color: #555;}
    .container {max-width: 800px;margin: 40px auto;padding: 0 20px;}
    h1, h2, h3 {color: #222;}
    table {width: 100%;border-collapse: collapse;margin-bottom: 2em;background-color: white;}
    th, td {border: 1px solid #ccc;padding: 10px;text-align: left;vertical-align: top;}
    th {background-color: #eee;}
    code {background: #eee;padding: 2px 0px;border-radius: 4px;font-family: 'Courier New', Courier, monospace;font-size: 95%;}
    pre {background: #272822;padding: 15px;border-radius: 8px;overflow-x: auto;font-size: 90%;margin-bottom: 2em;}
    pre code {background: none;font-family: 'Courier New', Courier, monospace;font-size: 90%;}
    p strong {color: #444;}
  </style>
</head>
<body>


<div class="navbar">
  <a href="#home">Home</a>
  <a href="#quickstart">Quickstart</a>
  <a href="#flow">Flow</a>
  <a href="#smo">Runtypes</a>
  <a href="#service">Services</a>
  <a href="#buffers">Buffers</a>
  <a href="#std">Std</a>
</div>

<div class="container">

<h1 id="home">smoλ</h1>

<p><em>A safe & fast low-level language.</em></p>

<p><i>Smoλ</i>  (pronounced like "small" but with "o" instead of "a") is a low-level language with fast zero-cost abstractions that are organized 
into failsafe services.
Its core is tiny — really tiny! So tiny, in fact, that printing and basic
arithmetics are externally implemented in the standard library with a direct-to-C++ interface.
Follow on <a href="https://github.com/maniospas/smol" target="_blank" title="repository">GitHub</a> to track progress.</p>


<p>As an overview, there are two main constructs: a) runtypes denoted by <code class="language-smolambda">smo</code>
and which behave like both structs and functions, and b) services that functions executed in parallel and handle internal failures gracefully.</p>

<h1 id="quickstart">Quickstart</h1>

<h3>Setup</h3>

<p>Download <i>smoλ</i> from its <a href="https://github.com/maniospas/smol/releases/latest">latest release</a>
or build it from source by cloning the repository and running <code class="bash">g++ smolang.cpp -o smol -O2 -std=c++23</code>.
As you can see, the language is so lightweight that there is no need for a build system and its main executable consumes less than 300kB
... plus a GCC distribution. Ensure that both the <i>smol</i> executable and GCC are in your system path.
</p>

<p>
A language server is provided as a VSCode extension named <i>smoλ (smolambda)</i>;
search for the symbolic transcription in the parenthesis in the extensions tab, or get it from 
<a href="https://marketplace.visualstudio.com/items?itemName=maniospas.smolambda">here</a>.</p>

<h3>What's interesting?</h3>
<p>Look at an example of how <i>smoλ</i> manages data structures:</p>

<pre><code class="language-smolambda">@include std.builtins

smo Point(i64 x, i64 y) -> @new
smo Field(Point start, Point end) -> @new

service main()
    p = Point(3,5)
    f = Field(1,2,p)
    print(f.start.x + f.end.y) // 6
    --
</code></pre>


<p>First, <code class="language-smolambda">@include</code> brings code from
other files with the <i>.s</i> extension. Paths are separated by dots.
For safety, includes cannot occur within definitions and make code directly accessible. Here we include 
builtins from the <a href="#std">standard library</a>, mainly arithmetic operations and printing. 
Nothing exciting yet.</p>

<p>Next are some so-called <i>runtypes</i>, declared by the <code class="language-smolambda">smo</code>
keyword. These merge the concept of types and functions, where <code class="language-smolambda">-></code>
returns a value or tuple. If variable names are part of the returned tuple, they can be accessed as fields
from the result. <code class="language-smolambda">@new</code> is a shorthand for
returning a tuple of all arguments. This is useful for declaring structural data without any functionality.</p>

<p>Write something like <code class="language-smolambda">p = Point(...)</code> 
to access all returned named variables using notation like
<code class="language-smolambda">p.x</code> and <code class="language-smolambda">p.y</code>.
Unpack the result directly in other runtype calls, provided that primitive types match. All arguments are flat
-tuples are unwrapped to more lements- and can be reinterpreted in various ways
as long as primitive types match. Safety options for this are presented later.</p>

<p>Put all main business logic inside a <code class="language-smolambda">service main()</code> definition.
Services "catch" internal errors, safely handling allocation and deallocation.
They are also intrinsically parallel, can call each other, and handle returned errors. But more on them later.
For now, the main service is the program and the <code class="language-smolambda">--</code> symbol at its end indicates no returns.</p>

<h1 id="flow">Flow</h1>

<p>
<i>smoλ</i> offers conditions and loops to control the flow of a program. 
These return values -or no values- to
designate an end of the loop body or block. Below is an example of those, 
where arguments to conditions and loops must always evaluate to booleans.
The <code class="language-smolambda">else</code> branch of conditions is optional. 
You can also optionally add parentheses for clarity in conditions, but this is not 
needed because the end of expressions is always unique.
</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    i = 0
    while i&lt;10
        if(i%2) print("Even "+str(i)) --
        else print("Odd "+str(i)) --
        i = i+1
    ---- // ends `while` then `main` 
</code></pre>


<h3>@next</h3>

<p>
It is often convenient to compute a value but assign it at the variable at the
end of the current control flow's body, for example to denote the next value
in a loop while retaining the current value until that point. 
This is achieved with the <code class="language-smolambda">@next</code> 
instruction. Note the <i>@</i> prefix to remind that it might affect
your code later.
</p>


<pre><code class="language-smolambda">@include std.builtins

service main()
    i=0 while i&lt;10 @next i = i+1
    j=0 while j&lt;10 @next j = j+1
        i:str:add(" "):add(j:str):print()
    ------
</code></pre>


<p>Aside from loops, the same mechanism is useful for scrambling values.
This is shown below, where <code class="language-smolambda">if(true)</code> 
is used to isolate the next values and intercept the internal return.
Thus, the always true condition is actually useful similarly how an always 
true loop condition is also useful.
</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    i = 1
    j = 2
    if(true) 
        @next i = j
        @next j = i
        --
    print(j) // 1
    --
</code></pre>
    



<h3>Uplifting (breaking with a return)</h3>


<p>
There are no break and continue statements for loops because these can be emulated with other notation.
First, as a styling choice, do not indent conditions that run from a position until the end of the loop's
body but instead put the end condition's and loop's ending together. An example is shown below. 
</p>
<p>
The example also demonstrates how to break loops by returning multiple
steps back. This operation is called <i>uplifting</i> of return values. 
The syntax for uplifting is to insert
<code class="language-smolambda">></code> in the middle of returns.
You can uplift several times to escape from nested control flow.
For example, <code class="language-smolambda">->-</code> breaks
from a condition within a loop and <code class="language-smolambda">->>></code>
to return a runtype result from a condition within a loop.
</p>


<pre><code class="language-smolambda">@include std.builtins

service main()
    i = 511 while i&lt;10 @next i = i+1
        if i%7==0 ->- // break
        if i%2==0
            print(i)
    ------ // ends `if`, then `while`, then `main`
</code></pre>

<p>
Below is an even more complicated example.
</p>


<pre><code class="language-smolambda">@include std.builtins

service main()
    i=0 while i&lt;10 @next i = i+1
    j=0 while j&lt;10 @next j = j+1
        i:str:add(" "):add(j:str):print()
        if 5==i+j
            print("done") 
            ->>>-
    ------
</code></pre>


<h1 id="smo">Runtypes</h1>

<p>Types and functions are the same thing in <i>smoλ</i>
and marked as <code class="language-smolambda">smo</code> followed by a name
and a parenthesis with some arguments.
We call the merged concept <i>runtypes</i>.
As an example, look at a definition from the standard library,
which also gives a taste of the C++ ABI:</p>

<pre><code class="language-smolambda">smo add(i64 x, i64 y)
    @body{i64 z=x+y;}
    -> z
</code></pre>

<p>This tells us that we are defining an integer addition runtype with the corresponding arguments.
When called from other code, the definition is inlined in an optimization-friendly way. For example,
despite the illusion of typing, everything consists of direct variable operations; under the hood, field access like
<code class="language-smolambda">f.start.x</code> is replaced with variables like <code class="language-smolambda">f__start__x</code>.</p>

<p>Return a value or tuple of values with <code class="language-smolambda">-&gt;</code>,
and use <code class="language-smolambda">@body</code> to write C++ code. The ABI is described
later, but for now notice that a basic scan is also made to expose primitive types from inside the ABI.
</p>
<p>
If you don't want to return anything, use <code class="language-smolambda">--</code>.
Return symbols act as visual barriers that are easy to spot while remaining ... small.
Note that <i>smoλ</i> does not require semicolons becase boundaries are unique:
everything ends at return statements, at the end of file, or resides in-between
parentheses and commas.</p>

<h3>Primitives</h3>
<p>
<i>smoλ</i> has several primitive types for building more complicated runtypes. 
The standard library implements several operations for primitives. The ones built in the language are 
64-bit integers, their unsigned version, and floats. These are respectively denoted by
<code class="language-smolambda">i64</code>, <code class="language-smolambda">u64</code>, and <code class="language-smolambda">f64</code>.
The last one is equivalent to C++'s <code class="language-smolambda">double</code> numbers.</p>

<p>In addition, <code class="language-smolambda">buffer</code> is a special primitive that safely interfaces with heap memory while remaining
performant. It is the preferred way for moving large chunks of data around and, in general, has enough bells and whistles that a separate
section is dedicate to describing it later. These previous types are curated to use
the same number of 64 bits so as not to create alignment issues when stored and retrieved from buffers.</p>

<p>The language also offers a <code class="language-smolambda">ptr</code> as a means to represent 64-bit address. 
In most situations you will not use addresses, but they are useful for interweaving more complicated C++ code in ways
that the compiler can understand (this requires <i>a lot</i> of casts, though you can pack complicated bits in <i>.cpp</i>
files if you want).
</p>

<p>For convenience, you can find the <code class="language-smolambda">char</code> and <code class="language-smolambda">bool</code> primitives, 
which are the C equivalents. If these are stored in buffers, they still use a forcefully imposed 64-bit alignment, unless special
runtypes, like strings, hand-craft more efficient computations through the C++ interface. Similarly, you can find the
<code class="language-smolambda">errcode</code> builtin
as a means of handling failing services. This has an unknown number of bits because it is implemented as a C++ int.</p> 

<h3>Fields and tail move</h3>
<p>Values returned from runtypes are always organized into a tuple. However, you can access named fields of that
tuple, given that internal variables are returned. In previous examples, this means that we could access fields like
<i>x,y,start,end</i> given that they have been internally assigned to variables.
</p>

<p>Field access works a little differently when there is only one value returned: in this case
the return is treated as if returning that value directly. That is, you access that value's fields.
An example of this concept is presented below, where the overloaded <i>Point</i>
runtype with no arguments directly returns a version constructed with two arguments. This mechanism
allows for wrapper runtypes that perform concise substitution of original functionality. For example,
you can overload multiple versions of the same runtype that yield the same result from different argumets, 
like in the example.
</p>

<pre><code class="language-smolambda">@include std.builtins

smo Point(f64 x, f64 y) -> @new
smo Point() 
    start = Point(0.0, 0.0)
    -> start // as a single argument it is directly unpacked


service main()
    s = Point()
    print(s.x) // not s.start.x
    --
</code></pre>


<h3>Mutability (call by reference)</h3>

<p>Runtypes are called by value,
that is, without internal computations affecting external arguments. You can make
calls occur by reference by prepending
<code class="language-smolambda">&</code> to variable names in the signature. In this case,
internal modifications are retained. Below is an example.</p>

<pre><code class="language-smolambda">@include std.builtins

smo inc(i64 &x)
    x = add(x,1)
    --

service main()
    x = 1
    inc(x)
    print(x) // 2
    --
</code></pre>


<h3>Currying</h3>
<p>Runtype calls accept currying notation that transfers a precomputed value to the first argument.
The curry operator is <code class="language-smolambda">:</code> and can be chained. Furthermore, you can omit
parentheses if there is only one argument and you curry it. Below is an example, where this notation is used to
have as little nesting as possible.
</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    1:add(2):mul(3):print
    // equivalent to print(mul(add(1,2), 3))
    --
</code></pre>

<p>In general, runtypes are all first-class citizens of the language in that they cannot be set as variables.
However, you can pass a known or type as an argument to denote dummy empty objects.
</p>


<p>Currying lets <i>smoλ</i> avoid methods as fields, as the notation <code class="language-smolambda">obj:rt(args)</code>
is conceptually similar. Note that mutability should be explicitly declared if you want <code class="language-smolambda">rt</code>
to have side-effects.
</p>

<h3>Fields</h3>

<p>The assignment operator copies the outcome of function calls to variables.
However, only returned symbols can be accessed as fields and only if there are 
multiple of them packed into a comma-separated tuple.
For example, below the input variable <code class="language-smolambda">x</code>
cannot be accessed after computations conclude.
</p>

<p>We already saw that it may be convenient to unpack all runtype inputs with
<code class="language-smolambda">@new</code> to directly declare a structural type
without internal implementation.
</p>

<pre><code class="language-smolambda">@include std.builtins
smo multi_out(i64 x)
    xinc = add(x,1)
    -> xinc, x
smo single_out(i64 x)
    x = add(x,1)
    -> x

service main()
    p1 = multi_out(1)
    print(p1.x)        // 1
    print(p1.incx)     // 2
    p2 = single_out(1)
    print(p2)          // 2
    print(p2.x)        // CREATES AN ERROR
    --
</code></pre>


<h3>Overloading</h3>

<p>Overload runtypes that are structurally
different when converted to a flat representation of primitives 
(<code class="language-smolambda">i64</code>, <code class="language-smolambda">f64</code>, etc).
Runtypes that are equivalent in their expansion into primitives cannot be used 
as part of function signatures due to ambiguity. More on circumventing this issue later.
As an example, the following definitions come from the standard library.</p>

<pre><code class="language-smolambda">smo print(f64 message)
    @head{#include &lt;stdio.h>}
    @body{printf("%.6f\n", message);}
    --
smo print(i64 message)
    @head{#include &lt;stdio.h>}
    @body{printf("%ld\n", message);}
    --
smo add(i64 x, i64 y) @body{i64 z=x+y;} -> z
smo add(f64 x, f64 y) @body{f64 z=x+y;} -> z

service main()
    print(add(1,1)) // 2
    print(add(0.2,0.3)) // 0.5
    --
</code></pre>


<h3>Call by type</h3>

<p>
You might want to choose a runtype's version based on another without actually passing data. For example,
something different should be called based on the expected outcome. In those cases, you can skip
declaring variable names in signatures, and you can omit parenthesis-based argumets that would create dummy data.
</p>
<p>
Below is a segment of the standard library that shows how the correct version of
an evoked method is applied. Runtypes without
parentheses refer to zeroed out input data.
You can also use a value as reference - that would be ignored.</p>

<pre><code class="language-smolambda">smo not(bool x) @body{bool z=!x;} -> z
smo print(f64 message)
    @head{#include &lt;stdio.h>}
    @body{printf("%.6f\n", message);}
    --
smo read(i64)
    @head{#include &lt;stdio.h>}
    @body{i64 number = 0; bool success = scanf("%ld", &number);}
    if(success:not) @fail{printf("Invalid integer\n");} --
    -> number
smo read(f64)
    @head{#include &lt;stdio.h>}
    @body{f64 number = 0; bool success = scanf("%lf", &number);}
    if(success:not) @fail{printf("Invalid number\n");} --
    -> number

service main()
    x = read(f64)
    print(x)
    --
</code></pre>



<h3>Unions</h3>
<p>Sometimes, you want to define code that is automatically adjusted to different runtypes.
This can be achieved by declaring runtype unions, which are resolved to one of their
options. The resolution persists to dependent calls, create different ones for independence.
Unions are resolved during compilation and, like many features of <i>smoλ</i>, are zero-cost
abstractions. They can also unpack unions provided as arguments.</p>

<p>
For example, the <code class="language-smolambda">Type</code> union
below is determined to be <code class="language-smolambda">f64</code> while
calling <code class="language-smolambda">inc</code> to match the <code class="language-smolambda">Point</code>
argument and carries over to the internal
implementation. Therefore, the <code class="language-smolambda">f64</code> primitive is used for reading, constructing
a two-dimensional point, for casting the value of <i>1</i> to the appropriate type,
and calling the corresponding overloaded addition.
Unions account for overloads of their options up to the point
where they are defined.</p>

<pre><code class="language-smolambda">@include std.builtins

union Type(i64, f64, u64)
smo Point(Type x, Type y) -> @new
smo inc(Point &p)
    p.x = add(p.x, Type(1))
    p.y = add(p.y, Type(1))
    --

service main()
    value = f64:read()
    p = Point(value, value)
    p:inc()
    print(p.x)
    --
</code></pre>


<h3>@new</h3>

<p>Till now we used <code class="language-smolambda">->@new</code> returns as a shorthand for returning
input values. However, this statement type of return helps disambiguate sitatuons where overloading and
unions may not be able to reach a clear resolution. In particular, if exactly one of the competing runtypes
has this kind of return declaration, that is used as the choice that breaks the stalemate.
</p>

<p>For example, consider the following very simple program that reads from the console and manipulates strings
with a standard library implementation. The <code class="language-smolambda">str</code> runtype is overloaded
to allow various conversions to other primitives. However, we are still able to identify a specific variation, 
which in turn is used to identify and call <code class="language-smolambda">str:read</code>.</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    print("What's your name?")
    name = str:read
    print("Hi "+name+"!")
    --
</code></pre>



<h1 id="service">Services</h1>

<p>So far we have been writing <code class="language-smolambda">service main()</code> as the entrant
point of programs. Armed with the basics, we can now look at what that <i>service</i> keyword is all about. 
Functionally, services are runtypes with nameless returned values. That is, their returns are unpacked and 
can be parts of arguments normally, but do not accept field access because it would be either unsafe or create
hidden computational costs. More on why later</p>
<p>
Below is an example of declaring and calling a service. Syntactically, this is near-identical to working
with runtypes so that it's easy to change your mind as you write code. 
You will often not notice anything different.
</p>

<pre><code class="language-smolambda">@include std.builtins

service square(f64 x) -> mul(x,x)
service main()
    y = square(2.0)
    print(y)
    --
</code></pre>

<h3>Why services?</h3>

<p>Semantically, services are equivalent to runtypes with error handling and the implementation restriction that they
do not accept arguments by reference. However, they cost some additional operations per call, 
as they need to actually push the call to the stack and cascade
unhandled errors. So they are less efficient if you, say, call them millions of times per second.
</p>
<p>
That said, they have three distinct advantages:
a) they run independently and in parallel, b) they can call each other regardless of definition order, 
and even allow recursion (by comparison, simpler runtypes can only "see" previous runtype and service declarations), 
and c) they provide a compartmentalized execution environment that does not let internal errors escape.
</p>

<h3>Error handling</h3>

<p>
The last point means that, after calling a service within another one,
you need to consider how to handle prospective errors. The pattern discussed 
so far blindly unpacks results into further service and runtime calls.
This elegantly fails if an error is returned: it is cascaded
through the service call stack until handled. Or it eventually terminates the 
main service. 
</p>


<pre><code class="language-smolambda">@include std.builtins

service square(f64 x) 
    fail("Don't wanna!") // manually fail
    -> mul(x,x)

service main()
    y = square(2.0)
    print(y)
    --
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
Don't wanna!
Runtime error: `square y` contains an error
</pre>

<p>
You can check for the error code of services by accessing it from the result per
<code class="language-smolambda">result.err</code>. By convention, error codes are skipped
when unpacking values, essentially reserving field access for error handling but retaining
usage in further code.
</p>

<pre><code class="language-smolambda">@include std.builtins

service square(f64 x) 
    fail("Don't wanna!") // manually fail
    -> mul(x,x)
service main()
    y = square(2.0)
    if(y.err:bool) print("Something went wrong") --
    else print(y) --
    --
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
Don't wanna!
Something went wrong
</pre>

<p>
Services fail safely by deallocating resources, and in fact
<i>smoλ</i> encourages letting services fail and retrying instead of 
creating hard-to-implement recovery. Below is an example, where a 
service is created to handle bug-prone inputs in an isolated environment.
You could also implement it as a runtype and then have the whole main
service fail too.
</p>


<pre><code class="language-smolambda">@include std.builtins

service get_age() 
    print("What's your age?")
    age = i64:read()
    if(age&lt;=1) fail("Too young for this stuff") --
    if(age>=140) fail("Too old for this stuff") --
    -> age

service main()
    age = get_age()
    while(age.err:bool) age = get_age() --
    print("You've seen at least "
            :add(age:sub(1):str)
            :add(" years gone by."))
    --
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
What's your age?
1000
Too old for this stuff
What's your age?
-10
Too young for this stuff
What's your age?
10
You've seen at least 9 years gone by.
</pre>


<h1 id="buffers">Buffers</h1>

<p>Handle dynamic memory with the special <code class="language-smolambda">buffer</code> runtype.
Think of this as a list where new data are pushed to the back and popped from the front. The
definition is part of the language and it is how one would handle functions with variadic inputs or outputs too. 
(<i>Variadic</i> is a fancy way of calling an arbitrary number of inputs or outputs.)
</p>

<p>Buffers are unpacked into other runtypes by consuming elements from their start.
However, unpacking feasibility is checked at runtime. Memory deallocation is safe, occurs
always -even if runtime errors terminate services-
and is injected automatically by <i>smoλ</i>. Data are stored in buffers without
even primitive types and correct unpacking either relies solely on the programmer or on
safe runtypes that will be discussed later.</p>

<h3>Local buffers</h3>

<p>Buffer elements are unpacked from the front until no
more entries are required for desired runtype calls.
Popping is memory safe in that buffer overflows smoothly fail any service
(such as <code class="language-smolambda">main</code>)
with an appropriate error message. You can check the number of remaining
elements with the <code class="language-smolambda">len</code> runtype.
</p>

<pre><code class="language-smolambda">@include std.builtins

smo Point(i64 x, i64 y) -> @new
smo Field(Point start, Point end) -> @new

service main()
    buf = buffer(1,2,3,4,5)
    print(buf:len)    // 5
    f = buf:Field     // pops front
    print(f.start.x)  // 1
    print(buf:i64)    // 5
    --
</code></pre>

<h3>Returning buffers</h3>

<p>Runtypes and services can return buffers, but only if this is the only thing returned.
The result is forcefully interpeted as a buffer again to maintain its spectial operations.
For example, services that return buffers do not return have an error field
<code class="language-smolambda">.err</code>  that you can check. Instead, identify failure 
by checking that the returned buffer has non-zero length. Below is an example.
</p>

<pre><code class="language-smolambda">@include std.builtins

service test()
    buf = buffer(0,1,2.0,3,4) // accidentally has an f64
    iterator = buf
    while iterator:len:bool
        print(iterator:i64)
        --
    return buf

service main()
    buf = test()
    if buf:len:bool:not print("failed to generate buffer")
    --
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
0
1
Runtime error: buffer element has different primitive type
failed to generate buffer
</pre>


<h3>Slicing</h3>

<p>
Buffers can be sliced to obtain a sub-view of elements. This happens irrespectively
of other operations applied on the original. Slices can be obtained from square brackets that either contain
their starting element as 
<code class="language-smolambda">u64</code> number,
or contain starting and non-inclusive end elements separated by <code class="language-smolambda">to</code>.
</p>

<p>
You can change the separating operator to <code class="language-smolambda">upto</code> to make the last element inclusive,
or <code class="language-smolambda">lento</code> to specify the number of elements in the slice.
Below is an example of slicing. <i>All operations are near-zero-cost abstractions, 
with the exception that specifying an end also checks for bounds compared to the enclosing slice.</i>
</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    buf = buffer(0,1,2,3,4,5)
    slice = buf[1:u64 to 3:u64]
    print(slice:i64)        // 1 (pops front from slice)
    print(buf[0:u64]:i64)   // 0 (buf[0] is also a slice)
    print(buf:i64)          // 0 (slice remains unaffected)
    print(slice:i64)        // 2 (continuing from where we left)
    print(slice:i64)        // CREATES RUNTIME ERROR
    --
</code></pre>

<h3>Concatenation</h3>

<p>Normally, you can have a buffer as the last argument so that popping knows how many elements
it needs to consume. The language offers four operations for buffers:
<code class="language-smolambda">reserve</code> preallocates memory
(for optimization, otherwise size is doubled when needed),
<code class="language-smolambda">push</code> adds data at the end,
<code class="language-smolambda">copy</code> copies contents without
altering the original. Finally, <code class="language-smolambda">put</code> 
assigns runtype values to buffers.
i</p>


<pre><code class="language-smolambda">@include std.builtins

smo Point(i64 x, i64 y) -> @new

service main()
    buf1 = buffer(1,2)
    buf2 = buffer():reserve(2):push(3,4)
    buf = buf1
          : copy()
          : push(buf2.copy())
    // buf1 and buf2 are empty now
    p1 = Point(buf)
    p2 = Point(buf)
    print(p1.x) // 1
    print(p2.y) // 4
    --
</code></pre>

<h1 id="std">Std</h1>

<p>The standard library contains implementations for common programming needs.
Besides overloading pairswise numerical and comparison operators for basic arithmetic types and booleans, 
it also supports string handling.
</p>

<h3>Console</h3>
<p>Basic functionalies are introduced for the console, namely reading and printing. These support all escape characters
C++ can support, including ANSI codes for colorization. They have also been overloaded for integers, floats, and -as seen in the next
segment- strings. Reading failure fails the current service under <i>smoλ</i>'s guidelines that services should fail completely and rerun
instead of trying to recover from invalid states. Here's an example:
</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    success = false
    x = f64:read()
    print(x)
    --
</code></pre>

<h3>Strings</h3>

<p>Below is an example that demonstrates conversion from
basic builtin types to strings. Similarly overload <code class="language-smolambda">str(Type obj)</code> 
for custom types. Strings admit the following two optimizations under the hood to enable
very fast handling without creating excessive bloat when passed around:
a) they retain c-style strings for quoted characters, and b) they keep track of the first character
to enable fast comparison without going through heap data.
</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    i = 0
    while(i&lt;=10) 
        if(0==i%2) print("Even "+str(i)) --
        else print("Odd  "+str(i)) --
        i = i+1
    ---- // end while and main with no return
</code></pre>


<p>Buffers and standard library implementations, like strings, are
safe to return from services. In that case, deallocation instructions
are transferred upwards, but still performed 
on failure. Note that the C++ interface is generally unsafe
and requires extensive tests to demonsrate correctness. However, once
safe implementations are provided, you can reuse those.
</p>

<pre><code class="language-smolambda">@include std.builtins

service add_service(str v1, str v2) 
    i = 0
    while(i&lt;10)
        v2 = v2:add("c")
        i = i+1
        --
    -> v1:add(v2)

service main()
    r1 = "aa":str
    r2 = "bb":str
    r1 = add_service(r1,r2)
    print(r1)
</code></pre>


<h3>Vectors</h3>
<b>Under construction.</b>

<h3>Vectors</h3>

<p>Below is an example that demonstrates 
vector computations. Thse include the generation
of vectors with uniformly random elements.
</p>

<pre><code class="language-smolambda">@include std.builtins
@include std.vec
@include std.time

service main()
    n = 100000:u64
    x1 = vec(n)
    x2 = vec(n)
    tic = time()
    z = dot(x1,x2)
    print("Elapsed \{time()-tic} sec")
    print(z)
    --
</code></pre>


    

</div>
<script src="vendor/prism/prism.min.js"></script>
<script>
Prism.languages.smolambda = {
  'comment': /\/\/.*/,
  'directive': {
    pattern: /@\w+/,
    alias: 'important'
  },
  'keyword': [
    {
      pattern: /\b(?:smo|service|if|else|include|do|while|union|to|upto|lento|len)\b/,
      greedy: true
    },
    {
      pattern: /(?:-->|->-|->>>|->>-|->>|->|--|\:|\=)/,
      greedy: true
    }
  ],
  'builtin': /\b(?:i64|u64|f64|ptr|str|buffer|main|copy|push)\b/,
  'punctuation': /[{}();,\[\]]/,
  'number': /\b\d+\b/,
  'string': {
    pattern: /"(?:\\.|[^"\\])*"/,
    greedy: true
  }
};
</script>


</body>
</html>
