<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="SmoÎ» is a low-level language with fast zero-cost abstractions that are organized into failsafe services.">
  <meta name="keywords" content="smolambda, low-level language, smoÎ», programming language, runtype, safe language, systems programming, DSL">
  <meta name="author" content="Emmanouil (Manios) Krasanakis">
  <meta name="robots" content="index, follow">


  <title>smoÎ»</title>
  <link href="vendor/prism/prism.min.css" rel="stylesheet" />
  <style>
    html {scroll-behavior: smooth;}
    h1 {scroll-margin-top: 60px;}
    h2 {scroll-margin-top: 60px;}
    h3 {scroll-margin-top: 60px;}
    h1[id], h2[id], h3[id] { position: relative; }
    .anchor-link {text-decoration: none;font-size: 0.9em;margin-left: 8px;opacity: 0;transition: opacity 0.2s;}
    h1:hover .anchor-link,
    h2:hover .anchor-link,
    h3:hover .anchor-link { opacity: 1; }

    body {font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;margin: 0;background-color: #f9f9f9;color: #333;line-height: 1.7;}
    .navbar {background-color: #333;padding: 2px;position: sticky;top: 0;z-index: 1000;display: flex;flex-wrap: wrap;justify-content: center;}
    .navbar a {color: white;text-decoration: none;padding: 5px 10px;font-weight: bold;}
    .navbar a:hover {background-color: #555;}
    .container {max-width: 800px;margin: 40px auto;padding: 0 20px;}
    h1, h2, h3 {color: #222;}
    table {width: 100%;border-collapse: collapse;margin-bottom: 2em;background-color: white;}
    th, td {border: 1px solid #ccc;padding: 10px;text-align: left;vertical-align: top;}
    th {background-color: #eee;}
    code {background: #eee;padding: 2px 0px;border-radius: 4px;font-family: 'Courier New', Courier, monospace;font-size: 95%;}
    pre {background: #272822;padding: 15px;border-radius: 8px;overflow-x: auto;font-size: 90%;margin-bottom: 2em;}
    pre code {background: none;font-family: 'Courier New', Courier, monospace;font-size: 90%;}
    p strong {color: #444;}
    .section-header {background-color: #eeb;font-weight: bold;color: #000;}
  </style>
</head>
<body>


<div class="navbar">
  <a href="#home">Home</a>
  <a href="#quickstart">Quickstart</a>
  <a href="#flow">Flow</a>
  <a href="#smo">Runtypes</a>
  <a href="#service">Services</a>
  <a href="#buffers">Buffers</a>
  <a href="#std">Std</a>
</div>

<div class="container">

<h1 id="home">smoÎ» <a href="#home" class="anchor-link">ðŸ”—</a></h1>

<p><em>A safe & fast low-level language.</em></p>

<img src="smol.png" alt="Logo" />


<p><i>SmoÎ»</i>  (pronounced like "small" but with "o" instead of "a") is a low-level language with fast zero-cost abstractions that are organized 
into failsafe services.
Its core is tiny â€” really tiny! So tiny, in fact, that printing and basic
arithmetics are externally implemented in the standard library with a C++ interface.
Follow on <a href="https://github.com/maniospas/smol" target="_blank" title="repository">GitHub</a> to track progress.</p>


<p>Overall, there are two main constructs: a) runtypes denoted by <code class="language-smolambda">smo</code>
that declare short inlined operations, and b) services that are executed in parallel and handle internal failures gracefully.
Use the former for speedy intermediate operations and the latter for error handling over large chunks of business logic.
The type system is algebraic, with runtype overloads and unions, as well as basic type inference - just enough magic to keep
code simple without hiding behavior. All code is fastly
executed on the stack, but there are heap buffers to handle variadic data.</p>

<h1 id="quickstart">Quickstart <a href="#quickstart" class="anchor-link">ðŸ”—</a></h1>

<h3>Setup <a href="#setup" class="anchor-link">ðŸ”—</a></h3>

<p>Download <i>smoÎ»</i> from its <a href="https://github.com/maniospas/smol/releases/latest">latest release</a>
or build it from source by cloning the repository and running <code class="bash">g++ smolang.cpp -o smol -O2 -std=c++23</code>.
The language is so lightweight that there is no need for a build system and its main executable consumes less than 300kB
... plus a GCC distribution. Ensure that both the <i>smol</i> executable and GCC are in your system path.
</p>

<p>
A language server is provided as a VSCode extension named <i>smoÎ» (smolambda)</i>;
search for the symbolic transcription in the parenthesis in the extensions tab, or get it from 
<a href="https://marketplace.visualstudio.com/items?itemName=maniospas.smolambda">here</a>.
The language server offers tooltips, error traces, and jumping to definitions.</p>

<h3 id="interesting">What's interesting? <a href="#interesting" class="anchor-link">ðŸ”—</a></h3>
<p>Look at an example of how <i>smoÎ»</i> manages data structures:</p>

<pre><code class="language-smolambda">@include std.builtins

smo Point(i64 x, i64 y) -> @new
smo Field(Point start, Point end) -> @new

service main()
    p = Point(3,5)
    f = Field(1,2,p)
    print(f.start.x + f.end.y) // 6
    --
</code></pre>


<p>First, <code class="language-smolambda">@include</code> brings code from
other files with the <i>.s</i> extension. Paths are separated by dots.
Here we include builtins from the <a href="#std">standard library</a> that we
are going to use, mainly arithmetic operations and printing. 
Nothing exciting yet.</p>

<p>Next are some so-called <i>runtypes</i>, declared by the <code class="language-smolambda">smo</code>
keyword. These merge the concept of types and functions, where <code class="language-smolambda">-></code>
returns a value or tuple. If variable names are part of the returned tuple, they can be accessed as fields
from the result. <code class="language-smolambda">@new</code> is a shorthand for
returning a tuple of all arguments. It is useful for declaring structural data without functionality - though
those data may make runtime assertions.</p>

<p>Write something like <code class="language-smolambda">p = Point(...)</code> 
to access all returned named variables using notation like
<code class="language-smolambda">p.x</code> and <code class="language-smolambda">p.y</code>.
Unpack the result directly in other runtype calls, provided that primitive types match. All arguments are flat
-tuples are unwrapped to more elements- and can be reinterpreted in various ways
as long as primitive types match. Safety options for this are presented later.</p>

<p>Put all main business logic inside a <code class="language-smolambda">service main()</code> definition.
Services "catch" internal errors, safely handling allocation and deallocation.
They are also intrinsically parallel, can call each other, and handle returned errors. But more on them later.
For now, the main service is the program and the <code class="language-smolambda">--</code> symbol at its end indicates no returns.</p>


<h3 id="cheatsheet">Cheatsheet <a href="#cheatsheet" class="anchor-link">ðŸ”—</a></h3>

<p>Here is a summary of the language's core. More operations are
available in the standard library.
</p>

<table>
  <thead>
    <tr>
      <th>Symbol</th>
      <th>Description</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr class="section-header"><td colspan="3"><u>Declarations</u></td></tr>
    <tr>
      <td><code class="language-smolambda">smo</code></td>
      <td>Runtype definition</td>
      <td>Defines an inlined type-function hybrid</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">service</code></td>
      <td>Service definition</td>
      <td>Parallel, safe, error-capturing function</td>
    </tr>
    <tr>
        <td><code class="language-smolambda">union</code></td>
        <td>Type alternatives</td>
        <td>Enables compile-time type matching</td>
    </tr>
    <tr>
        <td><code class="language-smolambda">Type(values)</code></td>
        <td>Call/cast</td>
        <td>Values expand into primitives</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@include</code></td>
      <td>Import external file</td>
      <td>Dot-path notation used for `.s` files</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">.</code></td>
      <td>Field access</td>
      <td>For named returns of runtypes</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">:</code></td>
      <td>Currying operator</td>
      <td>Passes value as first argument</td>
    </tr>
    <tr class="section-header"><td colspan="3"><u>Returns</u></td></tr>
    <tr>
      <td><code class="language-smolambda">-></code></td>
      <td>Return value(s)</td>
      <td>Used to return from runtype or service</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">--</code></td>
      <td>Return with no value</td>
      <td>No return value, is an explicit terminator</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">->-</code></td>
      <td>Uplift one level</td>
      <td>Break from a loop or if-block</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">->></code></td>
      <td>Uplift return one level</td>
      <td>Break from nested blocks</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">->>></code></td>
      <td>Uplift return two levels</td>
      <td>E.g., escape from loops inside conditions</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@new</code></td>
      <td>Return all inputs</td>
      <td>Prioritized on runtype conflicts</td>
    </tr>
    <tr>
        <td><code class="language-smolambda">value.err</code></td>
        <td>Check if service failed</td>
        <td>Omitted in tuple unpack</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">&amp;</code></td>
      <td>Call by reference</td>
      <td>Before name in signature, mutates values</td>
    </tr>
    <tr class="section-header"><td colspan="3"><u>Control flow</u></td></tr>
    <tr>
      <td><code class="language-smolambda">if</code></td>
      <td>Condition</td>
      <td>Can be used with <code class="language-smolambda">else</code>, can yield value</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">while</code></td>
      <td>Loop</td>
      <td>Can yield a buffer of internal returns</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">with</code></td>
      <td>Type conditioning</td>
      <td>Needs <code class="language-smolambda">else</code>, runs first compilable branch</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">fail(str message)</code></td>
      <td>Manual error trigger</td>
      <td>Causes service to fail and propagate error</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@next</code></td>
      <td>Deferred assignment</td>
      <td>Evaluated now, assigned at end of block</td>
    </tr>
    <tr class="section-header"><td colspan="3"><u>Builtins</u></td></tr>
    <tr>
      <td><code class="language-smolambda">nom, ...</code></td>
      <td>Nominal type checking</td>
      <td>Automatic unique value in arguments</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">i64, u64, f64, ...</code></td>
      <td>Builtin runtypes</td>
      <td>Can be called to convert to each other</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">buffer(...)</code></td>
      <td>Dynamic heap list</td>
      <td>Variadic input/output</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">[start to end]</code></td>
      <td>Slicing (exclusive end)</td>
      <td>Returns a view of buffer contents</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">[start upto end]</code></td>
      <td>Slicing with inclusive end</td>
      <td>Variant of range slicing</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">[start lento count]</code></td>
      <td>Slicing by length</td>
      <td>Number of elements instead of end</td>
    </tr>
    <tr class="section-header"><td colspan="3"><u>C++ ABI</u></td></tr>
    <tr>
      <td><code class="language-smolambda">@body{...}</code></td>
      <td>Inline C++ code</td>
      <td>ABI-level logic inside runtypes</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@head{...}</code></td>
      <td>Include C++ headers</td>
      <td>Prepended once per program</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@fail{...}</code></td>
      <td>C++ for error handling</td>
      <td>Prefer <code class="language-smolambda">fail(str message)</code></td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@finally{...}</code></td>
      <td>C++ to free resources</td>
      <td>Can also tie the resources to a variable</td>
    </tr>
  </tbody>
</table>




<h1 id="flow">Flow <a href="#flow" class="anchor-link">ðŸ”—</a></h1>

<p>
<i>smoÎ»</i> offers if-statements and loops. These return values -or no values- to
designate the end of code blocks and are used to execute code blocks conditionally
and repeatedly. In addition to those base structures, there is also the option
to defer assignments for later to have more elegant loops, as well as a structure for
compile-time typechecking to perform conditional execution. One of the language's
goals is to give the illusion of developing on a higher-level counterpart despite
providing fast zero cost abstractions over machine code.</p>

<p><strong>Jump to:</strong>
  <a href="#conditions">Conditions &amp; loops</a> Â·
  <a href="#next">@next</a> Â·
  <a href="#uplifting">Uplifting</a> Â·
  <a href="#typechecking">Conditional typechecking</a>
</p>
<br>

<h3 id="conditions">Conditions &amp; loops <a href="#conditions" class="anchor-link">ðŸ”—</a></h3>

<p>Since these concepts are widely known, below is an example.
Conditions must always evaluate to booleans. That is, there 
are no implicit casts.
The <code class="language-smolambda">else</code> branch of ifs is optional. 
You can also add parentheses for clarity, but this is not 
required; the end of expressions is always unique.
</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    i = 0
    while i&lt;10
        if i%2==0 -> print("Even "+i:str))
        else      -> print("Odd "+i:str)
        i = i+1
    ---- // ends `while` then `main` 
</code></pre>

<p>To better organize conditions or loops of only one statement,
return a parsed expression like the variation below. There, prints
do not return values.
</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    i = 0
    while i&lt;10
        if i%2==0 -> print("Even "+i:str)
        else      -> print("Odd "+i:str)
        i = i+1
    ----
</code></pre>

<p>It is required that all <i>if</i> statements return
the same type of value -or no value- and that this is 
a runtype. Below is an exampe that demonstrates chained
if-else statements using the above basic syntax.</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    x = i64:read // more on this syntax later
    sgn = 
        if x>0        -> 1
        else->if x==0 -> 0
        else          -> 0-1
    print(sgn)
    --
</code></pre>

<p>Equivalently, replace the pattern <code class="language-smolambda">else->if</code> with the <code class="language-smolambda">elif</code>
keyword; that is more ergonomic. Below is the same example rewritten more concisely.</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    x = i64:read
    print(if x>0 -> 1 elif x==0 -> 0 else -> 0-1)
    --
</code></pre>


<h3 id="next">@next <a href="#next" class="anchor-link">ðŸ”—</a></h3>

<p>
You may want to compute a value but assign it at the variable at the
end of the current control flow's body, for example to denote the next value
in a loop. This is achieved with the <code class="language-smolambda">@next</code> 
instruction. Note the <i>@</i> prefix to indicate that it might affect
your code later.
</p>


<pre><code class="language-smolambda">@include std.builtins

service main()
    i=0 while i&lt;10 @next i = i+1
    j=0 while j&lt;10 @next j = j+1
        print(i:str+" "+j:str)
    ------
</code></pre>


<p>Aside from loops, the same mechanism is useful for scrambling values;
below  <code class="language-smolambda">if true</code> 
is used to isolate the next values and intercept the internal return.
</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    i = 1
    j = 2
    if true
        @next i = j
        @next j = i
        --
    print(j) // 1
    --
</code></pre>
    



<h3 id="uplifting">Uplifting (breaking with a return) <a href="#uplifting" class="anchor-link">ðŸ”—</a></h3>


<p>
There are no break and continue statements for loops because these can be emulated.
First, as a styling choice, do not indent conditions that run from a position until the end of the loop's
body but instead put the end condition's and loop's ending together. An example is shown below. 
</p>
<p>
The example also demonstrates how to break loops by returning multiple
steps back. This operation is called <i>uplifting</i> and its syntax 
is to insert <code class="language-smolambda">></code> in the middle of returns.
You can uplift several times to escape from nested control flow.
For example, <code class="language-smolambda">->-</code> breaks
from a condition within a loop and <code class="language-smolambda">->>></code>
to return a runtype result from a condition within a loop.
</p>


<pre><code class="language-smolambda">@include std.builtins

service main()
    i = 511 while i&lt;10 @next i = i+1
        if i%7==0 ->- // break
        if i%2==0 -> print(i)
    ---- // ends `while`, then `main`
</code></pre>

<p>
Below is an example where uplifting returns even more steps back.
Note that print returns no value, which would only create an error if
one tried to assign the value returned by the top loop to a variable.
</p>


<pre><code class="language-smolambda">@include std.builtins

service main()
    i=0 while i&lt;10 @next i = i+1
    j=0 while j&lt;10 @next j = j+1
        print(i:str+" "+j:str)
        if 5==i+j ->>>> print("done") 
    ------
</code></pre>

<h3 id="typechecking">Conditional typechecking <a href="#typechecking" class="anchor-link">ðŸ”—</a></h3>

<p>Before closing this secion on control flow, we will take quick peek
at a feature that also gives the illusion of altering control flow, 
namely compile-time typechecking. This effectively tries to execute
an alternative across several code blocks.
</p>
<p>The syntax designates the
start of a code block with  <code class="language-smolambda">with</code>
and has at least one follow-up code blocks designated by <code class="language-smolambda">else</code>.
The first block that compiles without creating an error about invalid runtypes
is the one selected each time.
</p>

<p>This feature is particularly useful with <code class="language-smolambda">union</code> types
that let you write the same generic code once and call it with various kinds of data. In those
cases, you might want to have code behave differently depending on the obtained data. Below
is a first glimpse on this dynamism, where <i>first</i> employs a different pattern depending on
the data it is called with. The implementation could also be overloaded, but this provides a shorthand to change
only how part of the code behaves. More on overloading later.</p>

<pre><code class="language-smolambda">@include std.builtins
@include std.vec

smo point(f64 x, f64 y) -> @new
union Elements (vec, point, f64, i64)
smo first(Elements elements)
    with ->> elements:vec:at(0:u64)
    else ->> elements:point.x
    else ->> elements:f64
    --

service main()
    x1 = vec:rand(10)
    print(x1:first)
    print(z:first)
    print(point(1.0,2.0):first)
    --
</code></pre>



<h1 id="smo">Runtypes <a href="#smo" class="anchor-link">ðŸ”—</a></h1>

<p>Types and functions are the same thing in <i>smoÎ»</i>
and marked as <code class="language-smolambda">smo</code> followed by a name
and a parenthesis with some arguments.
We call the merged concept <i>runtypes</i>.
As an example, look at a definition from the standard library,
which also gives a taste of the C++ ABI:</p>

<pre><code class="language-smolambda">smo add(i64 x, i64 y)
    @body{i64 z=x+y;}
    -> z
</code></pre>

<p>This tells us that we are defining an integer addition runtype with the corresponding arguments.
When called from other code, the definition is inlined in an optimization-friendly way. For example,
despite the illusion of typing, everything consists of direct variable operations; under the hood, field access like
<code class="language-smolambda">f.start.x</code> is replaced with variables like <code class="language-smolambda">f__start__x</code>.</p>

<p>Return a value or tuple of values with <code class="language-smolambda">-&gt;</code>,
and use <code class="language-smolambda">@body</code> to write C++ code. The ABI is described
later, but for now notice that a basic scan is also made to expose primitive types from inside the ABI.
</p>
<p>
If you don't want to return anything, use <code class="language-smolambda">--</code>.
Return symbols act as visual barriers that are easy to spot while remaining ... small.
Note that <i>smoÎ»</i> does not require semicolons becase boundaries are unique:
everything ends at return statements, at the end of file, or resides in-between
parentheses and commas.</p>


<p><strong>Jump to:</strong>
  <a href="#primitives">Primitives</a> Â·
  <a href="#fields">Fields</a> Â·
  <a href="#mutability">Mutability</a> Â·
  <a href="#currying">Currying</a> Â·
  <a href="#overloading">Overloading</a> Â·
  <a href="#callbytype">Call by type</a> Â·
  <a href="#unions">Unions</a> Â·
  <a href="#new">@new</a>
</p>
<br>

<h3 id="primitives">Primitives <a href="#primitives" class="anchor-link">ðŸ”—</a></h3>
<p>
<i>smoÎ»</i> has several primitive types for building more complicated runtypes. 
The standard library implements several operations for primitives. The ones built in the language are 
64-bit integers, their unsigned version, and floats. These are respectively denoted by
<code class="language-smolambda">i64</code>, <code class="language-smolambda">u64</code>, and <code class="language-smolambda">f64</code>.
The last one is equivalent to C++'s <code class="language-smolambda">double</code> numbers.</p>

<p>In addition, <code class="language-smolambda">buffer</code> is a special primitive that safely interfaces with heap memory while remaining
performant. It is the preferred way for moving large chunks of data around and, in general, has enough bells and whistles that a separate
section is dedicate to describing it later. These previous types are curated to use
the same number of 64 bits so as not to create alignment issues when stored and retrieved from buffers.</p>

<p>The language also offers a <code class="language-smolambda">ptr</code> type as a means to represent 64-bit address. 
In most situations you will not use addresses, but they are useful for interweaving more complicated C++ code in ways
that the compiler can understand (this requires <i>a lot</i> of casts, though you can pack complicated bits in <i>.cpp</i>
files if you want).
</p>

<p>For convenience, you can find the <code class="language-smolambda">char</code> and <code class="language-smolambda">bool</code> primitives, 
which are the C equivalents. If these are stored in buffers, they still use a forcefully imposed 64-bit alignment, unless special
runtypes, like strings, hand-craft more efficient computations through the C++ interface. Similarly, you can find the
<code class="language-smolambda">errcode</code> builtin
as a means of handling failing services. This has an unknown number of bits because it is implemented as a C++ int.</p> 

<h3 id="fields">Fields and tail move <a href="#fields" class="anchor-link">ðŸ”—</a></h3>

<p>Values returned from runtypes are always organized into a tuple. However, you can access named fields of that
tuple, given that internal variables are returned. In previous examples, this means that we could access fields like
<i>x,y,start,end</i> given that they have been internally assigned to variables.
</p>

<p>Field access works a little differently when there is only one value returned: in this case
the return is treated as if returning that value directly. That is, you access that value's fields.
An example of this concept is presented below, where the overloaded <i>Point</i>
runtype with no arguments directly returns a version constructed with two arguments.</p>
<p>
This mechanism
allows for wrapper runtypes that perform concise substitution of original functionality. For example,
you can overload multiple versions of the same runtype that yield the same result from different argumets, 
like in the example.
</p>

<pre><code class="language-smolambda">@include std.builtins

smo Point(f64 x, f64 y) -> @new
smo Point() 
    start = Point(0.0, 0.0)
    -> start // as a single argument it is directly unpacked


service main()
    s = Point()
    print(s.x) // not s.start.x
    --
</code></pre>


<h3 id="mutability">Mutability (call by reference) <a href="#mutability" class="anchor-link">ðŸ”—</a></h3>

<p>Runtypes are called by value,
that is, without internal computations affecting external arguments. You can make
calls occur by reference by prepending
<code class="language-smolambda">&</code> to variable names in the signature. In this case,
internal modifications are retained. Below is an example.</p>

<pre><code class="language-smolambda">@include std.builtins

smo inc(i64 &x)
    x = add(x,1)
    --

service main()
    x = 1
    inc(x)
    print(x) // 2
    --
</code></pre>


<h3 id="currying">Currying <a href="#currying" class="anchor-link">ðŸ”—</a></h3>
<p>Runtype calls accept currying notation that transfers a precomputed value to the first argument.
The curry operator is <code class="language-smolambda">:</code> and can be chained. Furthermore, you can omit
parentheses if there is only one argument and you curry it. Below is an example, where this notation is used to
have as little nesting as possible.
</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    1:add(2):mul(3):print
    // equivalent to print(mul(add(1,2), 3))
    --
</code></pre>

<p>In general, runtypes are all first-class citizens of the language in that they cannot be set as variables.
However, you can pass a known or type as an argument to denote dummy empty objects.
</p>


<p>Currying lets <i>smoÎ»</i> avoid methods as fields, as the notation <code class="language-smolambda">obj:rt(args)</code>
is conceptually similar. Note that mutability should be explicitly declared if you want <code class="language-smolambda">rt</code>
to have side-effects.
</p>

<h3 id="fields">Fields <a href="#fields" class="anchor-link">ðŸ”—</a></h3>

<p>The assignment operator copies the outcome of function calls to variables.
However, only returned symbols can be accessed as fields and only if there are 
multiple of them packed into a comma-separated tuple.
For example, below the input variable <code class="language-smolambda">x</code>
cannot be accessed after computations conclude.
</p>

<p>We already saw that it may be convenient to unpack all runtype inputs with
<code class="language-smolambda">@new</code> to directly declare a structural type
without internal implementation.
</p>

<pre><code class="language-smolambda">@include std.builtins
smo multi_out(i64 x)
    xinc = add(x,1)
    -> xinc, x
smo single_out(i64 x)
    x = add(x,1)
    -> x

service main()
    p1 = multi_out(1)
    print(p1.x)        // 1
    print(p1.incx)     // 2
    p2 = single_out(1)
    print(p2)          // 2
    print(p2.x)        // CREATES AN ERROR
    --
</code></pre>


<h3 id="overloading">Overloading <a href="#overloading" class="anchor-link">ðŸ”—</a></h3>

<p>Overload runtypes that are structurally
different when converted to a flat representation of primitives 
(<code class="language-smolambda">i64</code>, <code class="language-smolambda">f64</code>, etc).
Runtypes that are equivalent in their expansion into primitives cannot be used 
as part of function signatures due to ambiguity. More on circumventing this issue later.
As an example, the following definitions come from the standard library.</p>

<pre><code class="language-smolambda">smo print(f64 message)
    @head{#include &lt;stdio.h>}
    @body{printf("%.6f\n", message);}
    --
smo print(i64 message)
    @head{#include &lt;stdio.h>}
    @body{printf("%ld\n", message);}
    --
smo add(i64 x, i64 y) @body{i64 z=x+y;} -> z
smo add(f64 x, f64 y) @body{f64 z=x+y;} -> z

service main()
    print(add(1,1)) // 2
    print(add(0.2,0.3)) // 0.5
    --
</code></pre>


<h3 id="callbytype">Call by type <a href="#callbytype" class="anchor-link">ðŸ”—</a></h3>

<p>
You might want to choose a runtype's version based on another without actually passing data. For example,
something different should be called based on the expected outcome. In those cases, you can skip
declaring variable names in signatures, and you can omit parenthesis-based argumets that would create dummy data.
</p>
<p>
Below is a segment of the standard library that shows how the correct version of
an evoked method is applied. Runtypes without
parentheses refer to zeroed out input data.
You can also use a value as reference - that would be ignored.</p>

<pre><code class="language-smolambda">smo not(bool x) @body{bool z=!x;} -> z
smo print(f64 message)
    @head{#include &lt;stdio.h>}
    @body{printf("%.6f\n", message);}
    --
smo read(i64)
    @head{#include &lt;stdio.h>}
    @body{i64 number = 0; bool success = scanf("%ld", &number);}
    if success:not @fail{printf("Invalid integer\n");} --
    -> number
smo read(f64)
    @head{#include &lt;stdio.h>}
    @body{f64 number = 0; bool success = scanf("%lf", &number);}
    if success:not @fail{printf("Invalid number\n");} --
    -> number

service main()
    x = read(f64)
    print(x)
    --
</code></pre>



<h3 id="unions">Unions <a href="#unions" class="anchor-link">ðŸ”—</a></h3>
<p>Sometimes, you want to define code that is automatically adjusted to different runtypes.
This can be achieved by declaring runtype unions, which are resolved to one of their
options. The resolution persists to dependent calls, create separate unions for independent resolution.
Unions are resolved during compilation and, like many features of <i>smoÎ»</i>, are zero-cost
abstractions. They can also unpack unions provided as arguments.</p>

<p>
For example, the <code class="language-smolambda">Type</code> union
below is determined to be <code class="language-smolambda">f64</code> while
calling <code class="language-smolambda">inc</code> to match the <code class="language-smolambda">Point</code>
argument and carries over to the internal
implementation. Therefore, the <code class="language-smolambda">f64</code> primitive is used for reading, constructing
a two-dimensional point, for casting the value of <i>1</i> to the appropriate type,
and calling the corresponding overloaded addition.
Unions account for overloads of their options up to the point
where they are defined.</p>

<pre><code class="language-smolambda">@include std.builtins

union Type(i64, f64, u64)
smo Point(Type x, Type y) -> @new
smo inc(Point &p)
    p.x = add(p.x, Type(1))
    p.y = add(p.y, Type(1))
    --

service main()
    value = f64:read()
    p = Point(value, value)
    p:inc()
    print(p.x)
    --
</code></pre>


<h3 id="new">@new <a href="#new" class="anchor-link">ðŸ”—</a></h3>

<p>Till now we used <code class="language-smolambda">->@new</code> returns as a shorthand for returning
input values. However, this type of return also helps disambiguate overloading when there is no clear resolution. 
In particular, if exactly one of the competing runtypes
has this kind of return declaration or argument, that is used as the choice that breaks the stalemate.
</p>

<p>For example, consider the following very simple program that reads from the console and manipulates strings
with a standard library implementation. The <code class="language-smolambda">str</code> runtype is overloaded
to allow various conversions to other primitives. However, we are still able to identify a specific variation, 
which in turn is used to identify and call <code class="language-smolambda">str:read</code>.</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    print("What's your name?")
    name = str:read
    print("Hi "+name+"!")
    --
</code></pre>



<h1 id="service">Services <a href="#service" class="anchor-link">ðŸ”—</a></h1>

<p>So far we have been writing <code class="language-smolambda">service main()</code> as the entrant
point of programs. Armed with the basics, we can now look at what that <i>service</i> keyword is all about. 
Functionally, services are runtypes with nameless returned values. That is, their returns are unpacked and 
can be parts of arguments normally, but do not accept field access because it would be either unsafe or create
hidden computational costs. More on why later</p>
<p>
Below is an example of declaring and calling a service. Syntactically, this is near-identical to working
with runtypes so that it's easy to change your mind as you write code. 
You will often not notice anything different.
</p>

<pre><code class="language-smolambda">@include std.builtins

service square(f64 x) -> mul(x,x)
service main()
    y = square(2.0)
    print(y)
    --
</code></pre>

<p><strong>Jump to:</strong>
  <a href="#whysvc">Why services?</a> Â·
  <a href="#errors">Error handling</a>
</p>
<br>


<h3 id="whysvc">Why services? <a href="#whysvc" class="anchor-link">ðŸ”—</a></h3>

<p>Semantically, services are equivalent to runtypes with error handling and the implementation restriction that they
do not accept arguments by reference. However, they cost some additional operations per call, 
as they need to actually push the call to the stack and cascade
unhandled errors. So they are less efficient if you, say, call them millions of times per second.
</p>
<p>
That said, they have three distinct advantages. First, they run independently and in parallel. Second, they can call each other regardless of definition order, 
and even allow recursion (by comparison, simpler runtypes can only "see" previous runtype and service declarations).
And, third, they provide a compartmentalized execution environment that does not let internal errors escape.
</p>

<h3 id="errors">Error handling <a href="#errors" class="anchor-link">ðŸ”—</a></h3>

<p>
The last point means that, after calling a service within another one,
you need to consider how to handle prospective errors. The pattern discussed 
so far blindly unpacks results into further service and runtime calls.
This elegantly fails if an error is returned: it is cascaded
through the service call stack until handled. Or it eventually terminates the 
main service. 
</p>


<pre><code class="language-smolambda">@include std.builtins

service square(f64 x) 
    fail("Don't wanna!") // manually fail
    -> mul(x,x)

service main()
    y = square(2.0)
    print(y)
    --
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
Don't wanna!
Runtime error: `square y` contains an error
</pre>

<p>
You can check for the error code of services by accessing it from the result per
<code class="language-smolambda">result.err</code>. By convention, error codes are skipped
when unpacking values to let service returns be used interchangeably to runtypes in 
the hotpath.
</p>

<pre><code class="language-smolambda">@include std.builtins

service square(f64 x) 
    fail("Don't wanna!") // manually fail
    -> mul(x,x)
service main()
    y = square(2.0)
    if y.err:bool -> print("Something went wrong")
    else          -> print(y)
    --
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
Don't wanna!
Something went wrong
</pre>

<p>
Services fail safely by deallocating resources, and in fact
<i>smoÎ»</i> encourages letting services fail and retrying instead of 
creating hard-to-implement recovery. Below is an example, where a 
service is created to handle bug-prone inputs in an isolated environment.
You could also implement it as a runtype and then have the whole main
service fail too.
</p>


<pre><code class="language-smolambda">@include std.builtins

service get_age() 
    print("What's your age?")
    age = i64:read()
    if age&lt;=1   -> fail("Too young for this stuff")
    if age<5    -> fail("Still too young")
    if age>=140 -> fail("Too old for this stuff")
    -> age

service main()
    age = get_age()
    while age.err:bool age = get_age() --
    print("You've seen at least \{age-1} years gone by.")
    --
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
What's your age?
1000
Too old for this stuff
What's your age?
-10
Too young for this stuff
What's your age?
10
You've seen at least 9 years gone by.
</pre>


<h1 id="buffers">Buffers <a href="#buffers" class="anchor-link">ðŸ”—</a></h1>

<p>Handle dynamic memory with the special <code class="language-smolambda">buffer</code> runtype.
Think of this as a list where new data are pushed to the back and popped from the front. The
definition is part of the language and it is how one would handle functions with variadic inputs or outputs too. 
(<i>Variadic</i> is a fancy way of calling an arbitrary number of inputs or outputs.)
</p>

<p>Buffers are unpacked into other runtypes by consuming elements from their start.
However, unpacking feasibility is checked at runtime. Memory deallocation is safe, occurs
always -even if runtime errors terminate services-
and is injected automatically by <i>smoÎ»</i>. Data are stored in buffers without
even primitive types and correct unpacking either relies solely on the programmer or on
safe runtypes that will be discussed later.</p>

<p><strong>Jump to:</strong>
  <a href="#localbuffers">Local buffers</a> Â·
  <a href="#returnbuffers">Returning buffers</a> Â·
  <a href="#slicing">Slicing</a> Â·
  <a href="#concat">Concatenation</a> Â·
  <a href="#nominal">Nominal typing</a>
</p>
<br>

<h3 id="localbuffers">Local buffers <a href="#localbuffers" class="anchor-link">ðŸ”—</a></h3>

<p>Buffer elements are unpacked from the front until no
more entries are required for desired runtype calls.
Popping is memory safe in that buffer overflows smoothly fail any service
(such as <code class="language-smolambda">main</code>)
with an appropriate error message. You can check the number of remaining
elements with the <code class="language-smolambda">len</code> runtype.
</p>

<pre><code class="language-smolambda">@include std.builtins

smo Point(i64 x, i64 y) -> @new
smo Field(Point start, Point end) -> @new

service main()
    buf = buffer(1,2,3,4,5)
    print(buf:len)    // 5
    f = buf:Field     // pops front
    print(f.start.x)  // 1
    print(buf:i64)    // 5
    --
</code></pre>

<h3 id="returnbuffers">Returning buffers <a href="#returnbuffers" class="anchor-link">ðŸ”—</a></h3>

<p>Runtypes and services can return buffers, but only if this is the only thing returned.
The result is interpreted as a buffer again to maintain its special operations.
For example, services that return buffers do not have an error field
<code class="language-smolambda">.err</code>  that you can check. Instead, identify failure 
by checking that the returned buffer has non-zero length. Below is an example.
</p>

<pre><code class="language-smolambda">@include std.builtins

service test()
    buf = buffer(0,1,2.0,3,4) // accidentally has an f64
    iterator = buf
    while iterator:len:bool
        print(iterator:i64)
    ---&gt; buf

service main()
    buf = test()
    if buf:len:bool:not -> print("failed to generate buffer")
    --
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
0
1
Runtime error: buffer element has different primitive type
failed to generate buffer
</pre>


<h3 id="slicing">Slicing <a href="#slicing" class="anchor-link">ðŸ”—</a></h3>

<p>
Buffers can be sliced to obtain a sub-view of elements. This happens irrespectively
of other operations applied on the original. Slices can be obtained from square brackets that either contain
their starting element as 
<code class="language-smolambda">u64</code> number,
or contain starting and non-inclusive end elements separated by <code class="language-smolambda">to</code>.
</p>

<p>
You can change the separating operator to <code class="language-smolambda">upto</code> to make the last element inclusive,
or <code class="language-smolambda">lento</code> to specify the number of elements in the slice.
Below is an example of slicing. <i>All operations are near-zero-cost abstractions, 
with the exception that specifying an end also checks for bounds compared to the enclosing slice.</i>
</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    buf = buffer(0,1,2,3,4,5)
    slice = buf[1:u64 to 3:u64]
    print(slice:i64)        // 1 (pops front from slice)
    print(buf[0:u64]:i64)   // 0 (buf[0] is also a slice)
    print(buf:i64)          // 0 (slice remains unaffected)
    print(slice:i64)        // 2 (continuing from where we left)
    print(slice:i64)        // CREATES RUNTIME ERROR
    --
</code></pre>

<h3 id="concat">Concatenation <a href="#concat" class="anchor-link">ðŸ”—</a></h3>

<p>Normally, you can have a buffer as the last argument so that popping knows how many elements
it needs to consume. As an exception, you can have a buffer as a first argument to a buffer too,
for example to copy it or concatenate it with more data. 
Furthermore, <code class="language-smolambda">put</code> 
assigns runtype values to the front elements. 
If you want highly optimized allocation, 
prefer using vectors from the standard library instead of buffers.
Below is an example on buffer concatenation and modification. </p>


<pre><code class="language-smolambda">@include std.builtins

smo Point(i64 x, i64 y) -> @new

service main()
    buf = buffer(1,2):buffer(1,2)
    buf[2]:put(3,4)
    p1 = Point(buf)
    p2 = Point(buf)
    print(p1.x) // 1
    print(p2.y) // 4
    --
</code></pre>

<p>
You can provide a buffer as the sole argument of another buffer to
copy its data. Below is an example.
</p>


<pre><code class="language-smolambda">@include std.builtins

smo Point(f64 x, f64 y) -> @new

service main()
    buf = buffer(1.0,2.0)
    buf2 = buf:buffer
    buf2[0:u64]:put(0.0)
    print(buf2[0:u64]:f64)
    print(buf[0:u64]:f64)
    --
</code></pre>

<h3 id="nominal">Nominal typing <a href="#nominal" class="anchor-link">ðŸ”—</a></h3>

<p>A last feature that has been delayed till this point is how to make
buffer reads semantically secure in not front-popping unintended runtypes.
The mechanism for doing so is presented at the runtype level by setting
an <code class="language-smolambda">nom</code> primitive as the first argument.
</p>
<p>This primitive is an expression of the so-called <i>nonimal typing</i>: 
if also contained in the returned tuple, it ties it back to the runtype. You
cannot normally set values to it.
</p>
<p>
Compiled assembly often ignores nominal typing primitives, as they are mostly
used for compilation checks, where they disambiguate strucurally equivalent runtypes 
among overloaded operations, or within unions. Nominal typing has a small dynamic overhead
when popping values from buffers.
</p>

<pre><code class="language-smolambda">@include std.builtins

smo Type1(nom, f64 value) -> @new
smo Type2(nom, f64 value) -> @new

smo recognize(Type1 p) print("this is Type1") --
smo recognize(Type2 p) print("this is Type2") --

service main()
    p1 = nom:Type1(1.0)
    p2 = nom:Type2(2.0)
    recognize(p1) 
    recognize(p2) 
    --
</code></pre>

<p>
In general, having alignment in runtypes is optional, as it comes with storage costs.
That said, alignment as a first returned argument is mandatory for safety if 
<code class="language-smolambda">ptr</code> data are also returned. This is mostly
a feature for the standard library, for example to ensure string integrity.</p>

<p>
<b>smoÎ» is safe as long as you do not use <code class="language-smolambda">ptr</code> in
your code and use implementations (e.g., the standard library) that safely implement pointers
and provide alignment.</b>
</p>


<pre><code class="language-smolambda">@include std.builtins

smo Point(nom, f64 x, f64 y) -> @new

service main()
    p = nom:Point(1.0, 2.0)
    buf()
    print(buf[1]:f64) // 1.0
    print(buf:f64) // alignment ensures correctness 
    --
</code></pre>


<h1 id="std">Std <a href="#std" class="anchor-link">ðŸ”—</a></h1>

<p>The standard library contains implementations for common programming needs.
Besides overloading pairswise numerical and comparison operators for basic arithmetic types and booleans, 
it also supports string handling.
</p>

<p><strong>Jump to:</strong>
  <a href="#console">Console</a> Â·
  <a href="#strings">Strings</a> Â·
  <a href="#files">Files</a> Â·
  <a href="#vectors">Vectors</a> Â·
  <a href="#math">Math</a>
</p>
<br>

<h3 id="console">Console <a href="#console" class="anchor-link">ðŸ”—</a></h3>
<p>Basic functionalities are introduced for the console, namely reading and printing. These support all escape characters
C++ can support, including ANSI codes for colors. They have also been overloaded for integers, floats, and -as seen in the next
segment- strings. Reading failure fails the current service under <i>smoÎ»</i>'s guidelines that services should fail completely and rerun
instead of trying to recover from invalid states. Here's an example:
</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    success = false
    x = f64:read()
    print(x)
    --
</code></pre>

<h3 id="strings">Strings <a href="#strings" class="anchor-link">ðŸ”—</a></h3>

<p>String manipulation is included from the builtin functionalities of the
standard library. Below is an example that demonstrates conversion from
primitives. Similarly overload <code class="language-smolambda">str(Type obj)</code> 
for custom types. Strings admit the following two optimizations under the hood to enable
very fast handling without creating excessive bloat when passed around:
a) they retain c-style strings for quoted characters, and b) they keep track of the first character
to enable fast comparison without going through heap data.
</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    i = 0
    while i&lt;=10 
        if 0==i%2 -> print("Even "+str(i))
        else      -> print("Odd  "+str(i))
        i = i+1
    ---- // end while and main with no return
</code></pre>


<p>Buffers and standard library implementations, like strings, are
safe to return from services. In that case, deallocation instructions
are transferred upwards, but still performed 
on failure. Note that the C++ interface is generally unsafe
and requires extensive tests to demonstrate correctness. However, once
safe implementations are provided, you can reuse those.
</p>

<p>Strings are immutable and therefore allow for very fast operations
for obtaining substrings by increasing pointers and decreasing length
under the hood. Those operations do aply bound checks but
do not copy memory and are therefore exceptionally performant. Here is
an example of what obtaining substrings looks like. Notice that you 
must place only the first and non-inclusve ending position.</p>

<pre><code class="language-smolambda">@include std.builtins
service main()
    s = "I like bananas!"
    print(s:substr(2:u64, 7:u64))  // prints "like"
    --
</code></pre>

<p>
As a trade-off for performance and safety, manipulating individual characters
in strings can only be done by spliting and recombining them, which
may be computationally intensive by moving memory.
Manipulating characters at individual string positions without losing safety
will be covered in future versions of the standard library.
</p>

<pre><code class="language-smolambda">@include std.builtins

service add_service(str v1, str v2) 
    i = 0
    while i&lt;10
        v2 = v2+"c"
        i = i+1
    ---> v1:add(v2)

service main()
    r1 = "aa":str
    r2 = "bb":str
    r1 = add_service(r1,r2)
    print(r1)
    --
</code></pre>


<h3 id="files">Files <a href="#files" class="anchor-link">ðŸ”—</a></h3>

<p>The next snipper shows how to create a service for reading the
contents of a file one chunk of 4,096 bytes at a time. Use <i>line</i> instead of 
<i>chunk</i> to stop reading chunks after new line characters too, 
but the byte limit will still be used to break long lines. Set a different limit to the number of
bytes per chunk by passing the number as a second <code class="language-smolambda">u64</code> 
to the file runtype.
</p>
<p>
Opening a non-existing file creates an error, so use 
<code class="language-smolambda">isfile</code> if you are
prepared to handle that scenario. Otherwise, let the current
service fail.
</p>

<pre><code class="language-smolambda">@include std.builtins
@include std.file

service contents(file f)
    ret = "":str 
    while f:ended:not 
        ret = ret+f:chunk
    ---&gt; ret // -- ends while, then -> returns

service main()
    if "README.md":isfile:not print("Going to fail") --
    print("README.md":file:contents)
    --
</code></pre>


<h3 id="vectors">Vectors <a href="#vectors" class="anchor-link">ðŸ”—</a></h3>
<b>Under construction.</b>

<p>Below is an example that demonstrates 
vector computations. These include the generation
of vectors with uniformly random elements.
</p>

<pre><code class="language-smolambda">@include std.builtins
@include std.vec
@include std.time

service main()
    n = 100000:u64
    x1 = vec(n)
    x2 = vec(n)
    tic = time()
    z = dot(x1,x2)
    print("Elapsed \{time()-tic} sec")
    print(z)
    --
</code></pre>


<h3 id="math">Math <a href="#math" class="anchor-link">ðŸ”—</a></h3>

<p>Various trigonometric operations are available, namely <code>cos, sin, tan, acos, asin, atan</code>.
In addition to those, you can compute multiples of <code>Ï€=3.14159...</code> per <code class="language-smolambda">value:pi</code> like below.
</p>
<pre><code class="language-smolambda">@include std.builtins
@include std.math

service main()
    print("Give a number of radians")
    rads = f64:read:pi
    print("cos \{rads:cos}")
    print("sin \{rads:sin}")
    print("tan \{rads:tan}")
    --
</code></pre>
<o>
Furthermore, <code>exp,log,pow,sqrt</code> are also available. Importantly, the logarithm requires
a positive inputs, the square root requires non-negative input, and power computations require
non-negative base. 
</p>

    

</div>
<script src="vendor/prism/prism.min.js"></script>
<script>
Prism.languages.smolambda = {
  'comment': /\/\/.*/,
  'directive': {
    pattern: /@\w+/,
    alias: 'important'
  },
  'keyword': [
    {
      pattern: /\b(?:smo|service|if|else|elif|with|include|do|while|union|to|upto|lento|len)\b/,
      greedy: true
    },
    {
      pattern: /(?:-->|->-|->>>>|->>>|->>-|->>|->|--|\:|\=)/,
      greedy: true
    }
  ],
  'builtin': /\b(?:i64|u64|f64|ptr|str|buffer|main|copy|bool|not|cos|sin|tan|acos|asin|atan|pi|exp|log|pow|sqrt|add|mul|sub|div|nom)\b/,
  'punctuation': /[{}();,\[\]]/,
  'number': /\b\d+\b/,
  'string': {
    pattern: /"(?:\\.|[^"\\])*"/,
    greedy: true
  }
};
</script>
<script>
  document.querySelectorAll('a.anchor-link').forEach(a =>
    a.addEventListener('click', e => {
      if (location.hash === a.getAttribute('href')) e.preventDefault()
    })
  )
</script>


</body>
</html>
