<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="SmoŒª is a low-level language with fast zero-cost abstractions that are organized into failsafe services.">
  <meta name="keywords" content="smolambda, low-level language, smoŒª, programming language, runtype, safe language, systems programming, DSL">
  <meta name="author" content="Emmanouil (Manios) Krasanakis">
  <meta name="robots" content="index, follow">
  <link rel="icon" href="smol.png" type="image/x-icon">

  <title>smoŒª</title>
  <link href="vendor/prism/prism.min.css" rel="stylesheet" />
  <style>
    html {scroll-behavior: smooth;}
    h1 {scroll-margin-top: 60px;}
    h2 {scroll-margin-top: 60px;}
    h3 {scroll-margin-top: 60px;}
    h1[id], h2[id], h3[id] { position: relative; }
    .anchor-link {text-decoration: none;font-size: 0.9em;margin-left: 8px;opacity: 0;transition: opacity 0.2s;}
    h1:hover .anchor-link,
    h2:hover .anchor-link,
    h3:hover .anchor-link { opacity: 1; }
    body {font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;margin: 0;background-color: #f9f9f9;color: #333;line-height: 1.7;}

    /* Tighter navbar */
    .navbar {
      background: #fffbf0;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
      padding: 2px 8px;
      position: sticky;
      top: 0;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      height: 48px; /* fixed tighter height */
    }
    .navbar a {
      color: #177042; /* green text */
      text-decoration: none;
      font-weight: bold;
      font-size: 1em;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 3px 8px;
      border-radius: 18px;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }
    .navbar a:hover {box-shadow: 0 6px 14px rgba(0, 0, 0, 0.15);transform: translateY(-1px);background: #e9eed8;border: 1px solid #444}
    .navbar a img {
      width: 28px;
      height: 28px;
      flex-shrink: 0;
      transition: transform 0.2s ease;
    }
    .navbar a:hover img {
      transform: scale(1.15);
    }

    .container {max-width: 800px;margin: 40px auto;padding: 0 20px;}
    h1, h2, h3 {color: #222;}
    table {width: 100%;border-collapse: collapse;margin-bottom: 2em;background-color: white;}
    th, td {border: 1px solid #ccc;padding: 10px;text-align: left;vertical-align: top;}
    th {background-color: #eee;}
    code {background: #eee;padding: 2px 0px;border-radius: 4px;font-family: 'Courier New', Courier, monospace;font-size: 1em;}
    pre {background: #272822;padding: 15px;border-radius: 8px;overflow-x: auto;font-size: 1em;margin-bottom: 2em;}
    pre code {background: none;font-family: 'Courier New', Courier, monospace;font-size: 1em;}
    p strong {color: #444;}
    .section-header {background-color: #eeb;font-weight: bold;color: #000;}
    .sidebar {  position: fixed;  top: 0;  left: calc(50% - 800px/2 - 260px);  height: 100%;  overflow-y: auto;  padding: 1em;  border-right: 10px solid #fdfaf9;   width: 200px;   margin-top: 50px; }
    .sidebar a {   text-decoration: none; color: #333;}
    .sidebar-title {  font-weight: none;  user-select: none; }
    .sidebar-name { font-weight: bold; user-select: none;  color: #73181d; }
    .token.special-amp {color: red;font-weight: bold; }
    .sidebar-sub { 
      font-size: 0.9em;
      margin-left: 1em;
    }
    .sidebar-sub a:hover {
      color: #177042;
      transform: scale(1.05);          /* visually enlarges the text */
      display: inline-block;          /* required so transform works properly */
      transition: transform 0.2s ease, color 0.2s ease; /* smooth animation */
    }


    @media (max-width: 768px) {
      .sidebar {transform: translateX(-100%); }
      .sidebar.open {transform: translateX(0);}
      .sidebar-toggle {display: block;}
      .container {margin-left: 0 !important;}
    }
</style>
</head>
<body>

<div class="navbar">
  <a href="index.html"><img src="smol.png" alt="home">Index</a>
  <a href="https://github.com/maniospas/smol" target="_blank"><img src="github.png" alt="github">GitHub</a>
</div>


<div class="sidebar">
  <div class="sidebar-section">
    <div class="sidebar-title"><span class="sidebar-name">Get started</span></div>
    <div class="sidebar-sub">
      <a href="#hello-world">Hello world</a><br>
      <a href="#variables">Variables</a>
    </div>
  </div>

  <div class="sidebar-section">
    <div class="sidebar-title"><span class="sidebar-name">Flow</span></div>
    <div class="sidebar-sub">
      <a href="#conditions">Conditions</a><br>
      <a href="#loops">Loops</a><br>
      <a href="#uplifting">Uplifting</a>
    </div>
  </div>

  <div class="sidebar-section">
    <div class="sidebar-title"><span class="sidebar-name">Functions</span></div>
    <div class="sidebar-sub">
      <a href="#arguments">Arguments</a><br>
      <a href="#currying">Currying</a><br>
      <a href="#returns">Returns</a><br>
      <a href="#fields">Fields</a><br>
      <a href="#errors">Error handling</a>
    </div>
  </div>
</div>

<div class="container">

<h1 id="hello-world">Hello world <a href="#hello-world" class="anchor-link">üîó</a></h1>

<p>
Let's take our first steps into programming with <i>smoŒª</i> 
(pronounced like "small" but with "o" instead of "a"). The language 
simplifies a lot of traditional programming concepts while keeping the ability to 
write very fast yet safe code. Some level of control is sacrificed in the process, but this means 
that you do not need to worry too much about details either. 
</p>
<p>
Our first program shows how to print a message.
Download the <code class="language-smolambda">smol</code> executable 
from the <a href="https://github.com/maniospas/smol/releases/latest">latest release</a>.
Place it alongside the <code>std</code> directory and add both the containing folder 
and a C/C++ compiler (e.g., GCC) to your system PATH. Finally, create a file named <i>main.s</i> 
with the text below. Open a terminal in the same folder and run 
<code>smol main.s</code>.
</p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    print("Hello world!")
    end
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
Hello world!
</pre>

<p>
As a quick preview, <code class="language-smolambda">@include std.core</code> 
adds basic functionality, like <code class="language-smolambda">print</code>. Then  
<code class="language-smolambda">service main()</code> is your actual program.
Finally, the line with <code class="language-smolambda">end</code> marks its completion.
</p>

<h1 id="variables">Variables <a href="#variables" class="anchor-link">üîó</a></h1>

<p>
A variable is a named box that holds a value. You give it a name, then 
put a value in it once with the pattern <code class="language-smolambda">variable_name = value</code>. 
In programming, this process is called <i>assignment</i>. 
Names cannot start with numbers or contain
spaces or special symbols other than the underscore <code class="language-smolambda">_</code>.
They can also not be existing variables or other operations. 
</p>
<p>In <i>smoŒª</i>, two consecutive underscores are not allowed either, because the language
uses the combination for some internal workings. Some valid variable names are <code>x</code>, <code>employee</code>,
<code>my_property</code>, <code>_temp_computation</code>, <code>MyDataStructure</code>, <code>var123</code>.
Below is an example where we set a constant 
text known during program creation (<code class="language-smolambda">cstr</code>) 
to a variable.
</p>

<pre><code class="language-smolambda">@include std.core

service main()
    greeting = "Hello world!"
    print(greeting)
    end
</code></pre>

<p>
Numbers are values too. There are three kinds you will use often:
</p>
<ul>
  <li><code class="language-smolambda">u64</code> ‚Äî whole numbers without a sign (0, 1, 2, ...). The default when writing <code class="language-smolambda">2</code> or <code class="language-smolambda">42</code>.</li>
  <li><code class="language-smolambda">i64</code> ‚Äî whole numbers with a sign (-1, +0, +1, ...) obtained by transforming <code class="language-smolambda">u64</code> values.</li>
  <li><code class="language-smolambda">f64</code> ‚Äî numbers with a decimal point. The default when writing <code class="language-smolambda">2.0</code> or <code class="language-smolambda">3.14</code>.</li>
</ul>
<p>These are known as unsigned integers, signed integers, and float numbers, respectively. 
The above names reassure
experienced programmers that they indeed use 64 bits to represent the numbers under-the-hood. 
That is, unsigned integers can represent numbers <code class="language-smolambda">0 upto 2^65-1</code>
but signed ones can represent numbers <code class="language-smolambda">-2^64 upto 2^64-1</code>.
Floats follow the IEEE 754 standard, which is typically accurate to 15-17 significant digits.
</p>
<p><b>Invalid operations:</b>
For safety, you cannot mix operations between different types of numbers. For example, you cannot subtract 
a float from <code class="language-smolambda">0</code> but only from <code class="language-smolambda">0.0</code>.
However, you can convert between number formats with <code class="language-smolambda">value:type</code>.
You would be surprised how many bugs are prevented by requiring only compatible numbers.
</p>
<p>
Below are some examples of numeric operations. Integer division by zero creates a runtime failure that you can intercept and handle at the level
of services. For floats, the IEEE 754 standard allows invalid operations like division by zero and lets them yield positive infinity, 
negative infinity, or NaN (not a number) values. You can check for those properties by correspondingly calling one of 
<code class="language-smolambda">is_inf</code> or <code class="language-smolambda">is_nan</code> 
that can be imported from <code class="language-smolambda"></code>std.math</code>. 
Lack of native error checking from the standard results in performant code.
</p>


<pre><code class="language-smolambda">@include std.core

service main()
    print(1+2)      // 3
    print(2/3)      // integer division (u64): 0
    print(2.0/3.0)  // float division (f64): a decimal result
    minus_one = 0:i64-1:i64
    print(minus_one) // -1
    end
</code></pre>

<p><b>Mutable variables:</b> After setting a variable, its value cannot normally change. To allow changes, declare it as <i>mutable</i> 
by placing <code class="language-smolambda">@mut</code> before its first declaration/assignment. 
Variables are immutable -that is, not mutable- by default to avoid many logic bugs. Always keep an eyes
for things that might have changed in the interim if something is mutable.</p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    @mut name = "Ada"
    print(name)
    name = "Lovelace" // allowed because we marked it mutable before
    print(name)
    end
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
Ada
Lovelace
</pre>

<h1 id="conditions">Conditions <a href="#conditions" class="anchor-link">üîó</a></h1>

<p>
Sometimes we only want certain lines to run if a tested condition is true.  
This is done with an <code class="language-smolambda">if</code> block.  
The word <code class="language-smolambda">if</code> starts the block, then comes a condition, 
then the code that should run if the test passes. 
Like with the <code class="language-smolambda">main</code> service so far, 
the block ends at <code class="language-smolambda">end</code>. </p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    if true
        print("this always runs")
    end end
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
this always runs
</pre>


<p>
<b>Style guide:</b> Prefer indenting the latter for easier reading, 
as well as starting it in a new line. Proper identation is a good coding practce for any
language, so try to stick to it. Do not be afraid
at merging multiple of end statements into one line; this helps keep your code concise.
Just make sure that you align those at their outermost level. For example, above we
placed <code class="language-smolambda">end end</code> at the identation showing the
service's end.
</p>

<p><b>Booleans:</b>
Above, the tsted condition is just the value <code class="language-smolambda">true</code>, so the message will always be printed.  
If you changed the condition to <code class="language-smolambda">false</code>, the inside would be skipped. These two values
(<code class="language-smolambda">true</code> and <code class="language-smolambda">false</code>) are 
known as boolean ones, or <code class="language-smolambda">bool</code> for short. 
More often, the test contains numerical or other comparisons that evaluate to a boolea value. 
For example, <code class="language-smolambda">2 &lt; 3</code> checks whether two is less than three.
</p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    if 2&lt;3
        print("yes, two is smaller")
        end
    end
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
yes, two is smaller
</pre>

<p>
There are several comparison operators you can use - some of these are defined for data other than numbers too:
</p>
<ul>
  <li><code class="language-smolambda">==</code> equal to</li>
  <li><code class="language-smolambda">!=</code> not equal to</li>
  <li><code class="language-smolambda">&lt;</code> less than</li>
  <li><code class="language-smolambda">&lt;=</code> less than or equal</li>
  <li><code class="language-smolambda">&gt;</code> greater than</li>
  <li><code class="language-smolambda">&gt;=</code> greater than or equal</li>
</ul>

<p>
We can also use <code class="language-smolambda">elif</code> (else if) 
and <code class="language-smolambda">else</code> branches to cover alternatves.  
Each branch is tried in order, until one runs. The rest are skipped. Here is an example:
</p>

<pre><code class="language-smolambda">@include std.core

service main()
    x = 5
    if x&gt;0
        print("positive")
        end
    elif x&lt;0
        print("negative")
        end
    else
        print("zero")
        end
    end
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
positive
</pre>

<p><b>Conditional values:</b> Sometimes, you may want to conditionally assign a value to
a variable. One option that reuses what we have learned so far is to have an assignment within 
each branch. However, this runs
the risk that, as you modify your code, there can be a branch that fails
to compute a value. To avoid this issue, you can instead return
a value from each branch per <code class="language-smolambda">return value</code>. 
Whichever branch runs determines the outcome of the conditional statement
and can be assigned to a variable. Below is an example, where each branch returns 
a different string. All branches must return either the exact same type of values, 
or nothing by ending at <code class="language-smolambda">end</code>.  </p>

<pre><code class="language-smolambda">@include std.core

service main()
    x = 0.0-2.0
    sign = 
        if x&gt;0.0 
            return "positive"
        elif x&lt;0.0 
            return "negative"
        else
            return "zero"

    print(sign)
    end
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
negative
</pre>


<h1 id="loops">Loops <a href="#loops" class="anchor-link">üîó</a></h1>

<p>A loop repeats a block while a condition is true. Syntactically, it
starts with <code class="language-smolambda">while</code> followed by a condition 
and the block's contents. Similarly to conditions, 
the block ends at <code class="language-smolambda">end</code>.
If a variable changes inside the loop, is needs to be mutable during its first assignment.
Otherwise, the language would complain.</p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    @mut i = 0
    while i&lt;5
        print(i)
        i = i+1
    end end
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
0
1
2
3
4
</pre>


<p>The next snippet shows a pattern for looping through a <i>range</i> of unsigned integers <code class="language-smolambda">0 upto 4</code>.
You could skip the <code>0,</code> argument for further simplicity. More details will be fully presented later, but it 
would be remiss to not mention this pattern here, as it prevents accidental bugs. Broadly, the <code>next</code> function
progresses the range while tracking values by assigning them to mutable varable <code class="language-smolambda">i</code>. 
The latter is updated in every loop.
</p>
<p>
Notice the <code class="language-smolambda">:</code> before the <code class="language-smolambda">while</code>, which is how
range is transferred to <code>next</code>. With this pattern, you do not need to manually handle the increment, which
you might forget about or could be complicated. Similar patterns let you, for example, automate the process of reading
from fles.
</p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    range(0, 5)
    :while next(@mut u64 i) 
        print(i)
    end end
</code></pre>


<h1 id="uplifting">Uplifting <a href="#uplifting" class="anchor-link">üîó</a></h1>

<p>
Sometimes you want to stop not just the current block, but also its parent blocks
up to a certain level. In those cases, 
put a vertical bar <code class="language-smolambda">|</code> before the end symbol 
for each level you want to ‚Äújump up‚Äù. For example,
<code class="language-smolambda">|end</code> ends the current block and its parent. 
Similarly, <code class="language-smolambda">|return value</code> returns a value to the parent.  
Two bars (<code class="language-smolambda">||</code>) jump two levels/parents upwards, and so on.
</p>

<pre><code class="language-smolambda">@include std.core

service main()
    @mut i = 0
    while true
        print(i)
        if i==5 
            |end // end loop early
        i = i+1
     end end
</code></pre>

<h1 id="arguments">Arguments <a href="#arguments" class="anchor-link">üîó</a></h1>

<p>
You can name a block of code and call it with inputs. These are called arguments.
There are two kinds of named blocks:
</p>
<ul>
  <li><code class="language-smolambda">def</code> ‚Äî a lightweight function that returns one or more values. It delegates error and resource handling to whichever services call it.</li>
  <li><code class="language-smolambda">service</code> ‚Äî a safer function that safely handles errors and resources, including resource freeing on failure.</li>
</ul>

<p>For most simple programs, you will mostly declare functions with <code class="language-smolambda">def</code>
and let them freely fail. <i>SmoŒª</i>'s philosophy is to not try to hopelessly recover from every failure state, 
but exit gracefully a bunch of dependent computations and try again. This is to strike a balance between having error handling
code poluting your codebase and being able to recover from failure. Services are more complex in that they run
independently to each other.</p>
<p>Regardless of the type of function, you can declare necessary inputs -called <i>arguments</i>- 
as comma-separated variable types and names. Types are needed so that the service can know what inputs to expect. 
For example, <code class="language-smolambda">f64 x</code> denotes an argument that is a float named <code>x</code>.
</p>

<pre><code class="language-smolambda">@include std.core

def affine(f64 x, f64 y, f64 z) 
    return (x+y)*z

service main()
    result = affine(1.0, 2.0, 3.0)
    print(result) // 9.0
    end
</code></pre>

<p><b>Mutability:</b>
Inputs are passed "by value" (without affecting the call site) unless you explicitly allow changes.  
Place <code class="language-smolambda">@mut</code> before argument names to declare that 
the variable passed as an argument may be modified inside the function - and hence
must already be mutable. This also makes the argument variable internally mutable. 
Importantly, <b>services do not accept mutable arguments</b>. The pattern there is to have one service
control the creation process of data, and share that with other services.
Below is an example.
</p>

<pre><code class="language-smolambda">@include std.core

def increment(@mut u64 x)
    x = x + 1
    end

service main()
    @mut n = 10
    increment(n)
    print(n) // 11
    end
</code></pre>

<p>
Similarly to mutable variables declared within blocks of code, 
mutable arguments make prospective changes happen easy to spot. 
Conversely, if you do not see <code class="language-smolambda">@mut</code>, 
nothing changes.
</p>

<p>
<b>Function arguments:</b> 
You can use functions as arguments to help disambiguate between similarly-named alternatives.
In that case, simply skip the the variable name. This is useful for choosing a behavior 
without passing a dummy value.
</p>

<pre><code class="language-smolambda">@include std.core

def zero(f64) 
    return 0.0

def zero(u64) 
    return 0

service main()
    a = zero(f64)
    b = zero(u64)
    print(a) // 0.0
    print(b) // 0
    end
</code></pre>

<h1 id="currying">Currying <a href="#currying" class="anchor-link">üîó</a></h1>

<p>
The colon <code class="language-smolambda">:</code> sends the value on the left as the first argument on the right.  
This reads left-to-right and removes extra parentheses when you chain steps.
</p>

<pre><code class="language-smolambda">@include std.core

def triple(f64 x) 
    return x*3.0

service main()
    print(2:f64:triple) // 6.0
    end
</code></pre>

<p>
The same colon also works with loops provided by the standard library (like <code class="language-smolambda">range</code>) so you can write readable iterations.
</p>

<h1 id="returns">Returns <a href="#returns" class="anchor-link">üîó</a></h1>

<p>
A block can return a value using <code class="language-smolambda">return</code>, or end with no value using <code class="language-smolambda">end</code>.  
Use uplifting if you need to jump out multiple levels when returning.
</p>

<pre><code class="language-smolambda">@include std.core

def abs(f64 x)
    if x&lt;0.0 
        |return 0.0-x
    return x

service main()
    x = 0.0-1.0
    print(abs(x)) // 1.0
    end
</code></pre>

<h1 id="fields">Fields <a href="#fields" class="anchor-link">üîó</a></h1>

<p>
You can return several named values at once and then access them as fields.  
<code class="language-smolambda">@args</code> is a shorthand that returns all inputs.
</p>

<pre><code class="language-smolambda">@include std.core

def Point(f64 x, f64 y) 
    return @args

def moved(Point p, f64 dx, f64 dy)
    nx = p.x + dx
    ny = p.y + dy
    return Point(nx, ny)

service main()
    @mut p = Point(1.0, 2.0)
    print(p.x) // 1
    print(p.y) // 2
    p = p:moved(3.0, 4.0)
    print(p.x) // 4
    print(p.y) // 6
    end
</code></pre>

<p>
If a runtype returns only one value, you use that directly, that is, without an extra field name.
</p>

<p>
To help you write secure code that does not arbitrarily access mutable fields, <i>smoŒª</i> normally
precents you from accessing or setting them. To be able to do so, add <code class="language-smolambda">@access</code>
at the very start of respective arguments. Below is an example where, without this notation, even immutable versions
of a runtype will not let you view mutable fields.
</p>


<pre><code class="language-smolambda">@include std.core

def Point(f64 _x, f64 _y) 
    @mut x = _x
    @mut y = _y
    return x,y

def print(@access Point p)
    // p is not mutable but you still need `@access` 
    // to look at p.x, p.y because their original 
    // declaration was mutable
    printin(x)
    printin(",")
    print(y)
    end

service main()
    @mut p = Point(1.0, 2.0)
    // print(p.x) // not allowed
    print(p)
    end
</code></pre>


<h1 id="errors">Error handling <a href="#errors" class="anchor-link">üîó</a></h1>

<p>
Now is the right time to talk about services and their philosophy: they are basically
runtypes that run in parallel threads 
(in truth: with a co-routine model but this is too advanced 
for this tutorial) and, when something is wrong -including in one of their called runtypes-, 
they complain and stop their work. When they stop, they also safely release any resources so that 
you do not have memory leaks or other similar issues.
Anywhere, call <code class="language-smolambda">fail("message")</code> to stop the current service.
</p>

<p>
The caller can check <code class="language-smolambda">result.err:bool</code>.  
If you don‚Äôt check but try to use a value, the error will bubble up until it reaches a place that does.
Your code waits for computations to conclude by called services only when values are used.
</p>

<pre><code class="language-smolambda">@include std.core

service divide(f64 x, f64 y)
    if y==0.0 
        return fail("Division by zero")
    return x/y

service main()
    r = divide(1.0, 0.0)
    if r.err:bool
        print("Could not compute.")
        end
    else
        print(r)
     end end
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
Division by zero
Could not compute.
</pre>

<p>
This approach keeps the main path simple. You try the thing. If it fails, you decide what the next step is (ask again, use a default, stop).
</p>

</div>

<script src="vendor/prism/prism.min.js"></script>
<script>
Prism.languages.smolambda = {
  'comment': /\/\/.*/,
  'directive': {
    pattern: /@\w+/,
    alias: 'important'
  },
  'keyword': [
    {
      pattern: /\b(?:def|service|if|return|else|elif|with|include|do|while|union|to|upto|lento|len|and|or|end)\b/,
      greedy: true
    },
    {
      pattern: /(?:\|\|\|->|\|\|->|\|\|end|\|->|\|end|->|end|:|=)/,
      greedy: true
    }
  ],
  'special-amp': {
    pattern: /&/,
    alias: 'operator' // optional, gives Prism‚Äôs operator style too
  },
  'builtin': /\b(?:i64|u64|f64|ptr|cstr|nstr|str|buffer|main|copy|bool|not|cos|sin|tan|acos|asin|atan|pi|exp|log|pow|sqrt|add|mul|sub|div|nominal)\b/,
  'punctuation': /[{}();,\[\]]/,
  'number': /\b\d+\b/,
  'string': {
    pattern: /"(?:\\.|[^"\\])*"/,
    greedy: true
  }
};
</script>
<script>
  document.querySelectorAll('a.anchor-link').forEach(a =>
    a.addEventListener('click', e => {
      if (location.hash === a.getAttribute('href')) e.preventDefault()
    })
  )
</script>

</body>
</html>
