<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Smoλ is a low-level language with fast zero-cost abstractions that are organized into failsafe services.">
  <meta name="keywords" content="smolambda, low-level language, smoλ, programming language, runtype, safe language, systems programming, DSL">
  <meta name="author" content="Emmanouil (Manios) Krasanakis">
  <meta name="robots" content="index, follow">
  <link rel="icon" href="smol.png" type="image/x-icon">

  <title>smoλ</title>
  <link href="vendor/prism/prism.min.css" rel="stylesheet" />
  <style>
    html {scroll-behavior: smooth;}
    h1 {scroll-margin-top: 60px;}
    h2 {scroll-margin-top: 60px;}
    h3 {scroll-margin-top: 60px;}
    h1[id], h2[id], h3[id] { position: relative; }
    .anchor-link {text-decoration: none;font-size: 0.9em;margin-left: 8px;opacity: 0;transition: opacity 0.2s;}
    h1:hover .anchor-link,
    h2:hover .anchor-link,
    h3:hover .anchor-link { opacity: 1; }
    body {font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;margin: 0;background-color: #f9f9f9;color: #333;line-height: 1.7;}

    /* Tighter navbar */
    .navbar {
      background: #fffbf0;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
      padding: 2px 8px;
      position: sticky;
      top: 0;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      height: 48px; /* fixed tighter height */
    }
    .navbar a {
      color: #177042; /* green text */
      text-decoration: none;
      font-weight: bold;
      font-size: 1em;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 3px 8px;
      border-radius: 18px;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }
    .navbar a:hover {box-shadow: 0 6px 14px rgba(0, 0, 0, 0.15);transform: translateY(-1px);background: #e9eed8;border: 1px solid #444}
    .navbar a img {
      width: 28px;
      height: 28px;
      flex-shrink: 0;
      transition: transform 0.2s ease;
    }
    .navbar a:hover img {
      transform: scale(1.15);
    }

    .container {max-width: 800px;margin: 40px auto;padding: 0 20px;}
    h1 {color: #73181d;}
    h2, h3 {color: #222;}
    table {width: 100%;border-collapse: collapse;margin-bottom: 2em;background-color: white;}
    th, td {border: 1px solid #ccc;padding: 10px;text-align: left;vertical-align: top;}
    th {background-color: #eee;}
    code {background: #eee;padding: 2px 0px;border-radius: 4px;font-family: 'Courier New', Courier, monospace;font-size: 1em;}
    pre {background: #272822;padding: 15px;border-radius: 8px;overflow-x: auto;font-size: 1em;margin-bottom: 2em;}
    pre code {background: none;font-family: 'Courier New', Courier, monospace;font-size: 1em;}
    p strong {color: #444;}
    .section-header {background-color: #eeb;font-weight: bold;color: #000;}
    .sidebar {  position: fixed;  top: 0;  left: calc(50% - 800px/2 - 260px);  height: 100%;  overflow-y: auto;  padding: 1em;  border-right: 10px solid #fdfaf9;   width: 200px;   margin-top: 50px; }
    .sidebar a {   text-decoration: none; color: #333;}
    .sidebar-title {  font-weight: none;  user-select: none; }
    .sidebar-name { font-weight: bold; user-select: none;  color: #73181d; }
    .token.special-amp {color: red;font-weight: bold; }
    .sidebar-sub { 
      font-size: 0.9em;
      margin-left: 1em;
    }
    .sidebar-sub a:hover {
      color: #177042;
      transform: scale(1.05);          /* visually enlarges the text */
      display: inline-block;          /* required so transform works properly */
      transition: transform 0.2s ease, color 0.2s ease; /* smooth animation */
    }

    details {margin:1.2em 0;padding:0.75em 1em;border-radius:10px;background:#fffefa;border:1px solid #ddd;box-shadow:0 2px 6px rgba(0,0,0,0.05);transition:all 0.25s ease;}
    details[open] {background:#fdf7e3;border-color:#d4b871;box-shadow:0 3px 8px rgba(0,0,0,0.1);}
    details summary {cursor:pointer;font-weight:bold;font-size:1.05em;color:#177042;outline:none;list-style:none;display:flex;align-items:center;}
    details summary::-webkit-details-marker {display:none;}
    details summary::before {content:"▶";margin-right:8px;font-size:0.9em;transition:transform 0.25s ease;color:#73181d;}
    details[open] summary::before {transform:rotate(90deg);}
    details p,details pre,details ul {margin-top:0.7em;}


    @media (max-width: 768px) {
      .sidebar {transform: translateX(-100%); }
      .sidebar.open {transform: translateX(0);}
      .sidebar-toggle {display: block;}
      .container {margin-left: 0 !important;}
    }
</style>
</head>
<body>

<div class="navbar">
  <a href="index.html"><img src="smol.png" alt="home">Index</a>
  <a href="https://github.com/maniospas/smol" target="_blank"><img src="github.png" alt="github">GitHub</a>
</div>


<div class="sidebar">
  <div class="sidebar-section">
    <a class="sidebar-title" href="#get-started"><span class="sidebar-name">Get started</span></a>
    <div class="sidebar-sub">
      <a href="#hello-world">Hello world</a><br>
      <a href="#variables">Variables</a>
    </div>
  </div>

  <div class="sidebar-section">
    <a class="sidebar-title" href="#flow"><span class="sidebar-name">Flow</span></a>
    <div class="sidebar-sub">
      <a href="#conditions">Conditions</a><br>
      <a href="#loops">Loops</a><br>
      <a href="#algorithms">Algorithms</a>
    </div>
  </div>

  <div class="sidebar-section">
    <a class="sidebar-title" href="#functions"><span class="sidebar-name">Functions</span></a>
    <div class="sidebar-sub">
      <a href="#arguments">Arguments</a><br>
      <a href="#returns">Returns (named tuples)</a><br>
      <a href="#errors">Error handling</a><br>
      <a href="#recursion">Recursion</a>
    </div>
  </div>

  <div class="sidebar-section">
    <a class="sidebar-title" href="#advanced"><span class="sidebar-name">Advanced</span></a>
    <div class="sidebar-sub">
      <a href="#unions">Unions</a><br>
      <a href="#memory">Memory</a><br>
      <a href="#strings">Strings</a><br>
      <a href="#buffers">Buffers</a><br>
      <a href="#recursion">Recursion</a>
    </div>
  </div>
</div>

<div class="container">

<h1 id="get-started">Get started <a href="#get-started" class="anchor-link">🔗</a></h1>

<h2 id="hello-world">Hello world <a href="#hello-world" class="anchor-link">🔗</a></h2>

<p>
Let's take our first steps into programming with <i>smoλ</i> 
(pronounced like "small" but with "o" instead of "a"). The language 
simplifies a lot of traditional programming concepts while keeping the ability to 
write very fast yet safe code. Some level of control is sacrificed in the process, but this means 
that you do not need to worry too much about details either. 
</p>
<p>
Our first program shows how to print a message.
To set things up, download the <code class="language-smolambda">smol</code> executable 
from the language's <a href="https://github.com/maniospas/smol/releases/latest">latest release</a>.
Place it alongside the <code>std/</code> directory and add both the containing folder 
and a C/C++ compiler (e.g., GCC) to your system PATH. Create a file named <i>main.s</i> 
with the text below. Finally, open a terminal in the same folder and run 
<code>smol main.s</code>.
</p>

<b>Simpler installation alternatives will be available in the future.</b>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    print("Hello world!")
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  26ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  139ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

Hello world!
</pre>

<p>
A bunch of messages appeared! So let's go through them in order.
First, <i>smoλ</i> is a compiled language, meaning that 
it creates executable programs containing machine instructions. 
To this end, it first parses your program and transforms it to 
a simpler form during the <i>codegen</i> phrase. 
Then, that representation is turned into binary machine 
code using an external backend. 
Turning programs into code is broadly known as <i>compiling</i> them. 
Finally, the generated executable runs.
</p>
<p>
The last two bullet points come from running the program. These
are printed by the language's default <i>runtime</i>, that is, the
instructions embeded in the generated executable of how to work together with the operating system. 
The default runtime prints a link to the language's repository so that you can report bugs (and add a star!)
and then automatically selects whether the application should be a single-threaded or multi-threaded one.
</p>
<p>
A quick preview on the source code of our first program: <code class="language-smolambda">@include std.core</code> 
adds basic functionality, like <code class="language-smolambda">print</code>. Then  
<code class="language-smolambda">service main()</code> is your actual program.
Why it's called a <i>service</i> is a mystery that will be addressed later.
</p>

<details>
<summary>Advanced options.</summary>

There are several options you can pass to <i>smoλ</i> to affect all phases of compilation. Some of these
concepts can be understood only after reading the rest of this tutorial:

<ul>
  <li><code>--back [compiler]</code> The compiler backend that is used to compile an intermediate
  C code representation produced by <i>smoλ</i>. Default is 
  the highly robust <i>gcc</i>, but for example you may want to use another compile installed in
  your system, or something like <i>tcc</i> (tinycc) for very fast compilation during prototyping.
  You can also use a C++ compiler to allow unsafe injection of code from that language too; everything
  has been configured to work with C99 or later, as well as C++11 or later.</li>
  <li><code>--runtime [name]</code> Determines how the compilation outcome will make
  use of the target platform's capabilities. This may change, for example, the memory allocation
  strategy for embedded devices, some of which require custom implementations of heap allocation 
  or require custom management of one huge preallocated memory segment. Such changes are controlled
  via runtime files, which are then picked by the standard library or other <i>smoλ</i> code.
  Another affected characteristic is whether services are treated as parallel co-routines or
  eagerly executed. The runtime's name path to a <i>.h</i> file or the name of such a file
  in the <i>std/runtime/</i> directory. Default name is <i>auto</i>, corresponding to
  <i>std/runtime/auto.h</i> that chooses between an eager and co-routine implementation 
  of services depending on their number. There are two more runtimes provided out-of-the-box,
  <i>threads</i> that contains a co-routine implementaiton of services and <i>eager</i>
  that contains an eager calling of services.</li>
  <li><code>--task [name]</code> Controls whet the compiler actually does with the input code.
  The default task is <i>run</i>, which produces and runs an executable. You can set the following options:
  <ul>
    <li><i>compile</i> to only produce the executable but not run it.</li>
    <li><i>transpile</i> to produce a <i>.c</i> file
    containing an intermediate largely unreadable but still compile-able C transpilation of your program.</li>
    <li><i>assemble</i> to run the combination process but emmit readable assembly, <i>verify</i> to run
    a verification of correctness and print warning about sources of unsafety without producing any
    other outcome.</li>
    <li><i>lsp</i> to run the same verification process with markdown output that is what is leveraged 
    by the language's language server provider.</li>
    <li><i>doc</i> to produce an html file holding documentation of all functions available in the target file.</li>
  </ul>
  </li>
  <li><code>--workers [number]</code> The number of threads that can be involved in
 the type system resolution. This only affects compilation. Default is a single worker.</li>
</ul>

</details>

<h2 id="variables">Variables <a href="#variables" class="anchor-link">🔗</a></h2>

<p>
A variable is a named box that holds a value. You give it a name, then 
put a value in it once with the pattern <code class="language-smolambda">variable_name = value</code>. 
In programming, we say that you <i>assign</i> a value to a variable. 
Names cannot start with numbers or contain
spaces or special symbols other than the underscore <code class="language-smolambda">_</code>.
They can also not be existing variables or other operations. 
</p>
<p>In <i>smoλ</i>, two consecutive underscores are not allowed either, because the language
uses the combination for some internal workings. Some valid variable names are <code>x</code>, <code>employee</code>,
<code>my_property</code>, <code>_temp_computation</code>, <code>MyDataStructure</code>, <code>var123</code>.
Below is an example where we set a constant 
text known during program creation (<code class="language-smolambda">cstr</code>) 
to a variable.
</p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    greeting = "Hello world!"
    print(greeting)
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  26ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  139ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

Hello world!
</pre>

<p>
<b>Numbers:</b> Numbers are values, too. There are three kinds you will use often:
</p>
<ul>
  <li><code class="language-smolambda">u64</code> — whole numbers without a sign (0, 1, 2, ...). The default when writing <code class="language-smolambda">2</code> or <code class="language-smolambda">42</code>.</li>
  <li><code class="language-smolambda">i64</code> — whole numbers with a sign (-1, +0, +1, ...) obtained by transforming <code class="language-smolambda">u64</code> values.</li>
  <li><code class="language-smolambda">f64</code> — numbers with a decimal point. The default when writing <code class="language-smolambda">2.0</code> or <code class="language-smolambda">3.14</code>.</li>
</ul>
<p>These are known as unsigned integers, signed integers, and float numbers, respectively. 
Notice that the type mnemonics combine the first letters of those types with the number 64.
The is to let experienced programmers know that 64 bits are used to represent the numbers under-the-hood
(there is some historically baggage concerning the C language on why programmers would not easily trust 
us if we did not explicitly promise a number).
Given that many bits, unsigned integers can represent numbers <code class="language-smolambda">0 upto 2^65-1</code>
and signed ones can represent numbers <code class="language-smolambda">-2^64 upto 2^64-1</code>.
Floats follow the IEEE 754 standard, which is typically accurate to 15-17 significant digits.
</p>
<p>
For safety, you cannot mix operations between different types of numbers. For example, you cannot subtract 
a float from <code class="language-smolambda">0</code> but only from <code class="language-smolambda">0.0</code>.
However, you can convert between number formats with <code class="language-smolambda">value.type()</code>.
You would be surprised how many bugs are prevented by requiring only compatible numbers. Below are some examples of numeric operations. 
</p>


<details>
<summary>What happens on division by zero?</summary>
Integer division by zero creates a runtime failure that you can intercept and handle at the level
of services. For floats, the IEEE 754 standard allows invalid operations like division by zero and lets them yield positive infinity, 
negative infinity, or NaN (not a number) values. You can check for those properties by correspondingly calling one of 
<code class="language-smolambda">is_inf</code> or <code class="language-smolambda">is_nan</code> 
that can be include from <code class="language-smolambda">std.math</code>. 
Lack of native error checking from the standard results in performant code.
</details>


<pre><code class="language-smolambda">@include std.core

service main()
    print(1+2)
    print(2/3)     // unsigned integer division
    print(2.0/3.0) // float division
    minus_one = 0.i64()-1.i64()
    print(minus_one)
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  24ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  69ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

3
0
0.666667
-1
</pre>

<p><b>Mutable variables:</b> After setting a variable, its value cannot normally change. To allow changes, declare it as <i>mutable</i> 
by placing <code class="language-smolambda">@mut</code> before its first declaration/assignment. 
Variables are immutable -that is, not mutable- by default to avoid many logic bugs. Always keep an eyes
for things that might have changed in the interim if something is mutable.</p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    @mut name = "Ada"
    print(name)
    name = "Lovelace" // allowed because we marked it mutable before
    print(name)
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  24ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  69ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

Ada
Lovelace
</pre>



<h1 id="flow">Flow <a href="#flow" class="anchor-link">🔗</a></h1>

<h2 id="conditions">Conditions <a href="#conditions" class="anchor-link">🔗</a></h2>

<p>
Sometimes we only want certain lines to run if a tested condition is true.  
This is done with an <code class="language-smolambda">if</code> block.  
The word <code class="language-smolambda">if</code> starts the block, then comes a condition, 
then the code that should run if the test passes. 
There are two ways code blocks can end: either with <code class="language-smolambda">return value</code>
that stops the function by returning a value (this will be covered below) 
or with <code class="language-smolambda">then final_expression</code> to run
the block's last expression.</p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    if true
        print("this always runs")
        then print("still in the if block")
    print("back in main now")
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  24ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  69ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

this always runs
still in the if block
back in main now
</pre>


<p>
<b>Style guide:</b> Prefer indenting code blocks for easier reading, 
as well as starting them in new lines. Proper identation is a good coding practce for any
language, so try to stick to it. As an exception, you can keep a block comprising a
single <code class="language-smolambda">then</code> statement in the same line as the condition
(see next example).
</p>

<p><b>Booleans:</b>
Above, the tested condition is just the value <code class="language-smolambda">true</code>, so the message will always be printed.  
If you changed the condition to <code class="language-smolambda">false</code>, the inside would be skipped. These two values
(<code class="language-smolambda">true</code> and <code class="language-smolambda">false</code>) are 
known as boolean ones, or <code class="language-smolambda">bool</code> for short. 
More often, the test contains numerical or other comparisons that evaluate to a boolea value. 
For example, <code class="language-smolambda">2 &lt; 3</code> checks whether two is less than three.
</p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    if 2&lt;3 then print("yes, two is smaller")
</code></pre>


<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  24ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  69ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

yes, two is smaller
</pre>

<p>
There are several comparison operators you can use - some of these are defined for data other than numbers too:
</p>
<ul>
  <li><code class="language-smolambda">==</code> equal to</li>
  <li><code class="language-smolambda">!=</code> not equal to</li>
  <li><code class="language-smolambda">&lt;</code> less than</li>
  <li><code class="language-smolambda">&lt;=</code> less than or equal</li>
  <li><code class="language-smolambda">&gt;</code> greater than</li>
  <li><code class="language-smolambda">&gt;=</code> greater than or equal</li>
</ul>

<p>
We can also use <code class="language-smolambda">elif</code> (else if) 
and <code class="language-smolambda">else</code> branches to cover alternatves.  
Each branch is tried in order, until one runs. The rest are skipped.  
Using <code class="language-smolambda">then</code> is mandatory only for the last branch, 
as in the other cases the language can understand where the block ends without it. But you 
can still add it for clarity, if you want to. Here is an example:
</p>

<pre><code class="language-smolambda">@include std.core

service main()
    x = 5
    if x&gt;0 
        print("positive")
    elif x&lt;0 
        print("negative")
    else 
        then print("zero")
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  24ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  69ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

positive
</pre>

<h2 id="loops">Loops <a href="#loops" class="anchor-link">🔗</a></h2>

<p>A loop repeats a block while a condition is true. Syntactically, it
starts with <code class="language-smolambda">while</code> followed by a condition 
and the block's contents. Similarly to conditions, the loop's condents end just after <code class="language-smolambda">then last_expression</code>.
If a variable changes inside the loop, is needs to be mutable during its first assignment.
Otherwise, the language would complain.</p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    @mut i = 0
    while i&lt;5
        print(i)
        then i = i+1
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  24ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  69ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

0
1
2
3
4
</pre>

<p>The next snippet shows a pattern for looping through a <i>range</i> of unsigned integers <code class="language-smolambda">0 upto 4</code>.
You could skip the <code>0,</code> argument for further simplicity. More details will be fully presented later, but it 
would be remiss to not mention this pattern here, as it prevents accidental bugs. Broadly, the <code>next</code> function
progresses the range while tracking values by assigning them to mutable varable <code class="language-smolambda">i</code>. 
The latter is updated in every loop.
</p>
<p>
Notice the <code class="language-smolambda">.</code> before the <code class="language-smolambda">while</code>, which is how
range is transferred to <code>next</code>. With this pattern, you do not need to manually handle the increment, which
you might forget about or could be complicated. Similar patterns let you, for example, automate the process of reading
from fles.
</p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    range(0, 5).while next(@mut u64 i) 
        then print(i)
</code></pre>


<h2 id="algorithms">Algorithms <a href="#algorithms" class="anchor-link">🔗</a></h2>


<p>Sometimes, you may want to conditionally assign a value to
a variable. If the variable is mutable, you can place a different assignment within 
each branch, though this requires the mutability -which is not as safe as immutable assignments-
and a priorly set default value. As an alternative, <i>smoλ</i> provides 
an <code class="language-smolambda">algorithm</code> control flow that starts a code block and
captures values obtained from internal statements of the form <code class="language-smolambda">return value</code>. 
Returns immediately end the code block, even if they occur within internally defined blocks.

<p>
Below is an example, which evaluates to several possibilities.
All returns must provide the same type of values. Do note that the return statement
also ends blocks in place of <code class="language-smolambda">end</code>. But, even if
there are nested conditions, all returns yield back a value to the <code class="language-smolambda">algorithm</code>.</p>

<pre><code class="language-smolambda">@include std.core

service main()
    x = 0.0-2.0
    sign = algorithm
        if x&gt;0.0 
            return "positive"
        if x&lt;0.0 
            return "negative"
        return "zero"
    print(sign)
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  24ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  69ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

negative
</pre>


<p><b>Breaking away from loops:</b>
The <code class="language-smolambda">algorithm</code> structure can be used as a means from
breaking away from loops. Below is an example, where some commands are merged in the same line
for conciseness. Having an explicit <code class="language-smolambda">return</code> statement 
in all situations is necessary - the language would complain otherwise. The example returns
a <code class="language-smolambda">nil</code> value provided by <code>std.core</code>, 
which has no contents. As a sidenote, the "algorithm" keyword is deliberately long so that
it's easy to spot and match nested returns to.
</p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    @mut i = 0
    limit = 5
    algorithm while true
        print(i)
        if i==limit
            return nil
        then i = i+1
        return nil  // runs if nothing else is returned
    print("ended while")
    print(i)
</code></pre>


<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  24ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  80ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

0
1
2
3
4
5
ended while
5
</pre>



<h1 id="functions">Functions <a href="#functions" class="anchor-link">🔗</a></h1>


<h2 id="arguments">Arguments <a href="#arguments" class="anchor-link">🔗</a></h2>

<p>
You can name a block of code and call it with inputs to obtain none, one, or multiple outputs. 
The named block is called a function and its inputs are called arguments. There are two kinds functions:
</p>
<ul>
  <li><code class="language-smolambda">def</code> — A function with no calling cost. Delegates error and resource handling to its caller.</li>
  <li><code class="language-smolambda">service</code> — Safely handles errors and resources, including resource freeing on failure.</li>
</ul>

<p>In simple programs you will mostly declare <code class="language-smolambda">def</code> functions
and let them freely fail. <i>Smoλ</i>'s philosophy is to not try to hopelessly recover from every failure state, 
but exit gracefully a bunch of dependent computations and try again. This is to strike a balance between error handling
code that polutes the codebase and recovering from impactful failures. Services are more complex in that they run
independently to each other.</p>
<p>Regardless of the type of function, you can declare arguments
as comma-separated variable types and names (each type corresponds to a name, separated by space). 
Types are needed so that the service can know what inputs to expect. 
For example, <code class="language-smolambda">f64 x</code> denotes an argument that is a float named <code>x</code>.
There may be some additional notation before types, described below.
</p>

<pre><code class="language-smolambda">// main.s
@include std.core

def affine(f64 x, f64 y, f64 z) 
    return (x+y)*z

service main()
    result = affine(1.0, 2.0, 3.0)
    print(result)
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  27ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  68ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

9.000000
</pre>

<p><b>Mutability:</b>
Inputs are passed "by value" (without affecting the call site) unless you explicitly allow changes.  
Place <code class="language-smolambda">@mut</code> before argument names to declare that 
the variable passed as an argument may be modified inside the function - and hence
must already be mutable. This also makes the argument variable internally mutable. 
Importantly, <b>services do not accept mutable arguments</b>. The pattern there is to have one service
control the creation process of data, and share that with other services.
Below is an example.
</p>

<pre><code class="language-smolambda">@include std.core

def increment(@mut u64 x)
    x = x + 1

service main()
    @mut n = 10
    increment(n)
    print(n)
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  27ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  68ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

11.000000
</pre>


<p>
Similarly to mutable variables declared within blocks of code, 
mutable arguments make prospective changes happen easy to spot. 
Conversely, if you do not see <code class="language-smolambda">@mut</code>, 
nothing changes.
</p>

<p>
<b>Functions as arguments:</b> 
You can use functions as arguments to help disambiguate between similarly-named alternatives.
In that case, simply skip the the variable name. This is useful for choosing a behavior 
without passing a dummy value.
</p>

<pre><code class="language-smolambda">@include std.core

def zero(f64) 
    return 0.0

def zero(u64) 
    return 0

service main()
    a = zero(f64)
    b = zero(u64)
    print(a)
    print(b)
</code></pre>


<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  27ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  68ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

0.000000
0
</pre>

<p>
<b>Currying:</b> 
The dot noration <code class="language-smolambda">first_argument.function_call(other_arguments)</code> 
sends the value on the left as the first argument of a function.  
This reads left-to-right and can be chained. Here is an example:
</p>

<pre><code class="language-smolambda">// main.s
@include std.core

def triple(f64 x) 
    return x*3.0

service main()
    2
    .f64()
    .triple()
    .print()
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  27ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  68ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

6.000000
</pre>

<p>
The same colon also works with loops provided by the standard library (like <code class="language-smolambda">range</code>) so you can write readable iterations.
</p>

<h2 id="returns">Returns <a href="#returns" class="anchor-link">🔗</a></h2>

<p>
You can return from a function early per <code class="language-smolambda">return value</code>. This works given that there is no 
<code class="language-smolambda">algorithm</code> environment capturing the returned value.
</p>

<pre><code class="language-smolambda">// main.s
@include std.core

def abs(f64 x)
    if x&lt;0.0 
        return 0.0-x
    return x

service main()
    x = 0.0-1.0
    print(abs(x))
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  27ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  68ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

1.000000
</pre>

<p>
You can return several named values at once and then access them by their variable's name with a 
dot notation. For example, if the outcome returning with <code class="language-smolambda">return x,y</code>
is stored into a variable <code>p</code>, individual values can be accessed via <code>p.x</code> or <code>p.y</code>.
But <code>p</code> still represents the sequence of values <code>x,y</code>.
</p>
<p>
This is visually different from currying in that there is no function call parenthesis. But returned values would not
be retrievable from <code class="language-smolambda">return x+1,y+1</code>, as the additions have not been stored
in a named variable. This is also fine, and you may do it for convenience in some scenarios.
Finally, <code class="language-smolambda">@args</code> is a shorthand that returns all inputs
and accessing fiels is also done with the dot notation. Below is an example.
</p>

<pre><code class="language-smolambda">\\ main.s
@include std.core

def Point(f64 x, f64 y) 
    return @args

def moved(Point p, f64 dx, f64 dy)
    nx = p.x + dx
    ny = p.y + dy
    return Point(nx, ny)

service main()
    @mut p = Point(1.0, 2.0)
    print(p.x)
    print(p.y)
    p = p.moved(3.0, 4.0)
    print(p.x)
    print(p.y)
</code></pre>


<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  27ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  68ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

1.000000
2.000000
4.000000
6.000000
</pre>

<p>
If a function returns only one value, you use that directly, that is, without an extra field name.
</p>

<p>
To help you write secure code that does not arbitrarily access mutable fields, <i>smoλ</i> normally
precents you from accessing or setting them. To be able to do so, add <code class="language-smolambda">@access</code>
at the very start of respective arguments. Below is an example where, without this notation, even immutable versions
of a runtype will not let you view mutable fields.
</p>


<pre><code class="language-smolambda">// main.s
@include std.core

def Point(f64 _x, f64 _y) 
    @mut x = _x
    @mut y = _y
    return x,y

def print(@access Point p)
    // p is not mutable but you still need `@access` 
    // to look at p.x, p.y because their original 
    // declaration was mutable
    printin(x)
    printin(",")
    print(y)

service main()
    @mut p = Point(1.0, 2.0)
    // print(p.x) // not allowed
    print(p)
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  27ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  68ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

1.000000,2.000000
</pre>

<h2 id="errors">Error handling <a href="#errors" class="anchor-link">🔗</a></h2>

<p>
Now is the right time to talk about services and their philosophy: they are basically
runtypes that run in parallel threads 
(in truth: with a co-routine model but this is too advanced 
for this tutorial) and, when something is wrong -including in one of their called runtypes-, 
they complain and stop their work. When they stop, they also safely release any resources so that 
you do not have memory leaks or other similar issues.
Anywhere, call <code class="language-smolambda">fail("message")</code> to stop the current service.
</p>

<p>
The caller can check <code class="language-smolambda">result.err.bool()</code>.  
If you don’t check but try to use a value, the error will bubble up until it reaches a place that does.
Your code waits for computations to conclude by called services only when values are used.
</p>

<pre><code class="language-smolambda">// main.s
@include std.core

service divide(f64 x, f64 y)
    if y==0.0 
        then fail("Division by zero")
    return x/y

service main()
    r = divide(1.0, 0.0)
    if r.err.bool()
        print("Could not compute.")
    else
        then print(r)
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  27ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  68ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

Division by zero
Could not compute.
</pre>

<p>
This approach keeps the happy path simple; you try running the service and, if it fails, decide what the next step is (ask again, use a default, stop).
</p>


<h1 id="advanced">Advanced <a href="#advanced" class="anchor-link">🔗</a></h1>

<h2 id="unions">Unions <a href="#unions" class="anchor-link">🔗</a></h2>

<p>
Sometimes we want to treat several different types as if they were “the same kind of thing.”  
For example, an integer, a float, and a signed integer are all numbers with similar operation defined;
thus we can write code that reads largely the same for all of those. 
In <i>smoλ</i>, you can avoid repeating that code by defining a <code class="language-smolambda">union</code>.
The latter groups together several types under a single name and you can define 
functions that work with the union instead of each type separately. Its definition looks like
an assignment, where the right-hand-side types are separated by <code class="language-smolambda">or</code>.
</p>

<pre><code class="language-smolambda">union Number = f64 or u64 or i64 
</code></pre>

<p>
This definition means that <code class="language-smolambda">Number</code> can represent 
<code>u64 class="language-smolambda"</code>, 
<code class="language-smolambda">f64</code>, or <code class="language-smolambda">i64</code>. 
Once the union is defined, you can write 
functions that take a <code>Number</code> and automatically work with whichever 
form it has. For example, the standard library has printing and arithmetic operator overloads: 
so you can call <code>print</code> on a <code>Number</code> and it “just works.”
Unions are lexically scoped within functions; the same name always represents the same type.
Thus in the example below both numbers must be of the same type. 
But you can add a union as part of another one to transfer all types under a different name.
</p>

<pre><code class="language-smolambda">// main.s
@include std.core // defines Number

def add1mul(Number a, Number b)
    // convert 1 to the Number correct primitive
    one = 1.Number()
    return (a+one)*(b+one)

service main()
    print(add1mul(1,2))
    print(add1mul(1.0, 2.0))
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  27ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  68ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

6
6.000000
</pre>

<p>
Behind the scenes, <i>smoλ</i> makes sure that union usage is safe and the right code runs 
depending on which variant you are using; new functions immediately
check if they can work for all variations of union members to report errors early.
</p>

<details>
<summary>Why are unions useful?</summary>
<p>
  Unions let use overload function names (like <code>print</code>) by dynamically
  adapting them on the type. However, only the declared member types are allowed.
  They further quickly create zero-cost overloaded variations of functions with the same code.
</p>

<p>
Think of unions as a way to say:  
<i>“I don’t care if this is an <code>i64</code> or an <code>f64</code> — 
as long as it’s a <code>Number</code>, I can use the overloaded operations
to write the same code conceptually.”</i>
</p>

</details>


<h2 id="memory">Memory <a href="#memory" class="anchor-link">🔗</a></h2>

<p>
At this point, you may be wondering how can <i>smoλ</i> run operations that consume an indeterminate 
amount of memory, such as combining strings or managing lists of arbitrary sizes. This is where buffers and the
<code class="language-smolambda">std.mem</code> import come. Here, we start from touching on concepts
from the import, to give a general picture. Broadly, there are two memory
devices; the <code>Stack</code> and <code>Heap</code>, corresponding to the small but fast
memory your operating system uses to run your program, and the full extend of availabel memory.
These provide memory allocation capabilities, but also grant you the ability to allocate more
memory either dynamically or as arenas at the respective device.</p>

<p>Memory follows the same pattern as
all resources that <i>smoλ</i> uses; it is freed only when not in use by any of your program's data.
This is achieved with some minor restrictions that the compiler will let you know occasionally. For example,
you need to declare memory management contexts (the <code class="language-smolambda">on</code>
statements mentioned below) outside of loops that would leak the memory in each execution. However, the
benefit is that there is no running overhead or bottlenceck for testing when memory is no longer needed
and freeing it. Instead, memory is released back to the operating system at function ends that are
determined during compilation. That is, memory management is a zero-cost abstraction.
</p>

<p>
<b>Arenas:</b> Of the aforementiond types of memory, arenas are pre-allocated memory regions that cannot grow. 
They are typically made to consume a safe amount of memory
to ensure that programs can successfully run, although this often comes with some
wasteage. New allocations on arenas are 
lightweight (thay are reduced to simple additions) and therefore execute fastly. In <i>smoλ</i>, arenas
that run out of space cause services to fail, which is always done safely and without leaking
resources. Here is how to work with arenas, where the <code class="language-smolambda">on</code>
statement automatically adds the arena as a first argument to all operations inside the current code block. 
</p>

<pre><code class="language-smolambda">// main.s
@include std.core
@include std.mem
@include std.vec

service main()
    // allocate a stack arena of 1024 bytes
    @mut memory = Stack.arena(1024)

    on memory
    v = vector(5) // calls vector(memory,5)
    print(v.len())
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  27ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  68ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

5
</pre>

<p>
If you switch to <code>Heap</code> instead of <code>Stack</code>, the same code 
would allocate on random access memory. Do note that the exact details of how heap 
memory is manageed may be modified under the hood for different systems by passing 
a different runtime to the compiler.
</p>


<p>In the above snippet, mutability is needed to allow modification of memory contents.
However, variables not assigned to any symbol are by default mutable. You can also return a
value from that block, therefore making the following equivalent syntax possible. 
Remember that the arena's consumed memory is not released at the end of the 
<code class="language-smolambda">on</code> block, but only when the vector is no longer needed. 
</p>

<pre><code class="language-smolambda">//main.s
@include std.core
@include std.mem
@include std.vec

service main()
    on Stack.arena(1024) 
    v = vector(5)

    on nil
    print(v.len())
</code></pre>


<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  27ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  68ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

5
</pre>


<p><b>Dynamic memory:</b>
You can also choose to maintain a collection of dynamically allocated memory segments,
for example by calling <code class="language-smolambda">on Heap.dynamic()</code> instead
of creating an arena. If multiple of those segments are attached to the same dynamic
allocation, they are also released together, which means that they remain allocated as 
long as any is in use. However, you can also retain one allocation per dynamic memory.
</p>


<i>For more types of memory and operations, refer to the standard library's
  documentation <a href="std.html">here</a>. Among other things, the
  implemented memory model allows parameterization of functions by being able 
  to allocate on segments of allocated memory.
</i>


<h2 id="strings">Strings <a href="#strings" class="anchor-link">🔗</a></h2>

<p>
<i>Smoλ</i> provides three main string types: 
<code class="language-smolambda">cstr</code> (a constant string enclosed in quotations during compilation, zero-terminated), 
<code class="language-smolambda">nstr</code> (zero-terminated with length information), and 
<code class="language-smolambda">str</code> (a string segment). For most purposes, you can use and convert results to
<code class="language-smolambda">str</code>.
</p>

<p>
Most operations on strings are zero-cost abstractions over simple arithmetics, as happens 
for example when retrieving substrings. The most heavyweight operations are copying and
concatenation, both of which require an arena or dynamic memory to store the result. Below
is an example, where it is important to note that concatenation yilds a <code class="language-smolambda">nstr</code>
by default, which can be directly reduced to a simpler <code class="language-smolambda">str</code> if needed.
Similarly, conversion of <code class="language-smolambda">cstr</code> to the other types is lightweight.
</p>


<pre><code class="language-smolambda"> // main.s  
@include std.core
@include std.mem

def Segment(nominal, str value)
    // return all inputs 
    // function returns are tuples of named elements
    return @args

def Segment(String _value)
    // convert from many string types
    value = _value.str()
    return nominal.Segment(value)

def combine(Segment[] segments)
    @mut combined = "".str()  // mutable string with known size
    on Stack.arena(1024)      // automatically use as argument if needed (for string operations)
    segments.len().range().while next(@mut u64 i) 
        then combined = str(combined+segments[i].value+" ")
    return combined

service main()
    segments = Segment[] // buffer
    .push("I think.".Segment())
    .push("Therefore I am.".Segment())
    segments.combine().print()
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  27ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  68ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

I think. Therefore I am.
</pre>


<h2 id="buffers">Buffers <a href="#buffers" class="anchor-link">🔗</a></h2>

<p>
Buffers represent collections of data that grow dynamically.  
The simplest syntax is <code class="language-smolambda">type[]</code>, which produces 
a resizable array of that type. You can grow buffers or modify
their elements only as long as they remain mutable. For example,
you can create a buffer <code class="language-smolambda">v = u64[].push(1).push(2)</code>
that is henceforth immutable. 
</p>

<pre><code class="language-smolambda">// main.s
@include std.core

def data(u64 id, u64[] values) 
    return @args

service main()
    @mut vals = u64[]
    .push(1)
    .push(2)

    p = data[]
    .push(data(10, vals))

    print(p[0].id)
    print(p[0].values[0])
    print(vals[0])
</code></pre>


<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  27ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  68ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

10
1
1
</pre>

<p>
By default, buffers use dynamically sized Heap memory to store their data. However, you can
also create them on memory allocations created from the standard library; all types of memory
accept an ,<code>allocate(size)</code> function for setting aside a fixed-size region, within
which buffers can grow. Below is an example. Do note that data can be pushed onto buffers during
their creation, while they are temporary variables -and hence mutable- and the result can be 
assigned to an immutable variable.
</p>



<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    vals = u64[Heap.allocate(1024)] // 1024 max buffer size
    .push(1)
    .push(2)

    print(vals[0])
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  27ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  68ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

1
</pre>


<p>
Buffers preserve mutability rules: 
if a buffer itself is mutable, its contents can be changed or extended.
Strings can also be stored in buffers or arrays <b>given that they reside
in the same memory surface</b>.
Below is an example.
</p>

<pre><code class="language-smolambda">\\ main.s
@include std.core
@include std.mem

service main()
    boxes = str[]
    .push("buffer start".str())
    .push("buffer end".str())

    b = boxes[0]
    print(b)
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  27ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  68ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

buffer start
</pre>

<p>
Here we pushed two strings into a string array. 
Notice the explicit conversion to the correct string version using <code>.str()</code>.
</p>

<details>
<summary>Returning buffers from services</summary>

<pre><code class="language-smolambda">@include std.core

service samples()
    buf = u64[]
    .push(42)
    .push(10)
    return buf

service main()
    buf = samples()
    print(buf[0])
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  27ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  68ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

42
</pre>

<p>
Here <code>samples</code> constructs and returns a buffer.  
The caller can then access its elements with <code>buf[index]</code>.
</p>
</details>

<h2 id="recursion">Recursion <a href="#recursion" class="anchor-link">🔗</a></h2>

<p>
In most languages, <i>recursion</i> means that a function calls itself, or that 
it calls another function that eventually calls itself.
This is useful, but it usually comes at a cost: every call stacks on top of the previous one, 
and if you recurse too deeply, you might run out of memory (a “stack overflow”).
<i>Smoλ</i> functions can only look at previously declared or imported functions
in an effort to protect such unconstrained behavior. But the same recursive computations
are still possible.
</p>

<p>
In particular, instead of creating dependent calls, the language uses a trick called <b>trampolining</b>.  
Think of it like a ball bouncing back and forth between two or more functions: 
each one decides what the next step is, and we loop until the process finishes.  
This way, recursion does not pile up memory; it just reuses a single loop.
</p>

<p>
Below is an example that demonstrates how to do this using a <code class="language-smolambda">tag</code> primitive that 
we have not addressed so far. That consists of writing 
<code class="language-smolambda">;name</code> and behaves like a number with a given value.
Importatly, tag values, can overlap with function names, which a <code class="language-smolambda">@dynamic</code>
instruction uses to its advantage to execut dfferent functions given different tag values.
</p>

<p>Below is a concrete example of how this can work in practice. 
There, the <code class="language-smolambda">tag</code> primitive type lets us reference <code>:ping</code> or <code>:pong</code> anywhere,
even before those are being defined. Then, the <code>@dynamic</code> instruction chooses to call a function
among various options (<code>ping</code> or <code>pong</code> here) depending on the next tag value. Additional
tag values are added as first arguments.
If something unexpected happens, such as another tag was found, the service just fails safely, without memory leaks or crashes.
At the same time, types are safe and are checked during compilation.</p>

<pre><code class="language-smolambda">// main.s  
@include std.core

def lambda(tag func, u64 n) 
    return @args

def ping(u64 n, cstr message)
    printin(message)
    print("ping")
    return :pong.lambda(n)

def pong(u64 n, cstr message)
    if n == 0
        return :done.lambda(u64)
    printin(message)
    print("pong")
    return :ping.lambda(n-1)

service main()
    @mut pending = :pong.lambda(2)
    while :done!=pending.func
        then pending = @dynamic(ping,pong) pending("next - ")
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
<span style="color: #b072d1;">codegen</span> --workers 1 ██████████ 7/7 files  22ms
<span style="color: #b072d1;">compile</span> --back gcc  --runtime std/runtime/auto.h  66ms
<span style="color: #7cd15d;">running</span> tests/unit/tutorial/hello

<span style="color:#5dc1b9">🔹</span> https://github.com/maniospas/smol
<span style="color:#5dc1b9">🔹</span> single threaded

next - pong
next - ping
next - pong
next - ping
</pre>

<p>
To sum up, in the example above <code>ping</code> and <code>pong</code> call each other back and forth.
Instead of diving deeper into the stack, they just return a next state marked with a tag
(<code class="language-smolambda">:ping</code>, <code class="language-smolambda">:pong</code>, or <code class="language-smolambda">:done</code>). 
The main loop keeps track of which step is next, and runs it until it reaches the <code>:done</code> tag.</li>
</ul>

<p>
So whenever you would normally write a recursive function, you can instead write it 
as a loop with tags. It feels a bit like building a tiny “interpreter” 
for your recursive logic that is safe and efficient, and performant. Do note that 
<code class="language-smolambda">@dynamic</code> may inject code from all functions it
handles, so do not overuse it to avoid creating exceptionally large executables.
</p>




</div>




<script src="vendor/prism/prism.min.js"></script>
<script>
Prism.languages.smolambda = {
  'comment': /\/\/.*/,
  'directive': {
    pattern: /@\w+/,
    alias: 'important'
  },
  'constant': {
    pattern: /\:\w+/,
    alias: 'important'
  },
  'keyword': [
    {
      pattern: /\b(?:def|service|if|return|then|else|elif|with|case|qed|include|algorithm|while|union|to|upto|lento|len|and|or|on)\b/,
      greedy: true
    },
    {
      pattern: /(\.|\||\:)/,
      greedy: true
    }
  ],
  'special-amp': {
    pattern: /&/,
    alias: 'operator' // optional, gives Prism’s operator style too
  },
  'builtin': /\b(?:i64|u64|f64|nil|true|false|ptr|cstr|nstr|str|buffer|main|copy|bool|not|cos|sin|tan|acos|asin|atan|pi|exp|log|pow|sqrt|add|mul|sub|div|nominal|tag)\b/,
  'punctuation': /[{}();,\[\]]/,
  'number': /\b\d+\b/,
  'string': {
    pattern: /"(?:\\.|[^"\\])*"/,
    greedy: true
  }
};
</script>
<script>
  document.querySelectorAll('a.anchor-link').forEach(a =>
    a.addEventListener('click', e => {
      if(location.hash === a.getAttribute('href')) e.preventDefault()
    })
  )
</script>

</body>
</html>
