<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Smoλ is a low-level language with fast zero-cost abstractions that are organized into failsafe services.">
  <meta name="keywords" content="smolambda, low-level language, smoλ, programming language, runtype, safe language, systems programming, DSL">
  <meta name="author" content="Emmanouil (Manios) Krasanakis">
  <meta name="robots" content="index, follow">
  <link rel="icon" href="smol.png" type="image/x-icon">

  <title>smoλ</title>
  <link href="vendor/prism/prism.min.css" rel="stylesheet" />
  <style>
    html {scroll-behavior: smooth;}
    h1 {scroll-margin-top: 60px;}
    h2 {scroll-margin-top: 60px;}
    h3 {scroll-margin-top: 60px;}
    h1[id], h2[id], h3[id] { position: relative; }
    .anchor-link {text-decoration: none;font-size: 0.9em;margin-left: 8px;opacity: 0;transition: opacity 0.2s;}
    h1:hover .anchor-link,
    h2:hover .anchor-link,
    h3:hover .anchor-link { opacity: 1; }
    body {font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;margin: 0;background-color: #f9f9f9;color: #333;line-height: 1.7;}

    /* Tighter navbar */
    .navbar {
      background: #fffbf0;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
      padding: 2px 8px;
      position: sticky;
      top: 0;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      height: 48px; /* fixed tighter height */
    }
    .navbar a {
      color: #177042; /* green text */
      text-decoration: none;
      font-weight: bold;
      font-size: 1em;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 3px 8px;
      border-radius: 18px;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }
    .navbar a:hover {box-shadow: 0 6px 14px rgba(0, 0, 0, 0.15);transform: translateY(-1px);background: #e9eed8;border: 1px solid #444}
    .navbar a img {
      width: 28px;
      height: 28px;
      flex-shrink: 0;
      transition: transform 0.2s ease;
    }
    .navbar a:hover img {
      transform: scale(1.15);
    }

    .container {max-width: 800px;margin: 40px auto;padding: 0 20px;}
    h1 {color: #73181d;}
    h2, h3 {color: #222;}
    table {width: 100%;border-collapse: collapse;margin-bottom: 2em;background-color: white;}
    th, td {border: 1px solid #ccc;padding: 10px;text-align: left;vertical-align: top;}
    th {background-color: #eee;}
    code {background: #eee;padding: 2px 0px;border-radius: 4px;font-family: 'Courier New', Courier, monospace;font-size: 1em;}
    pre {background: #272822;padding: 15px;border-radius: 8px;overflow-x: auto;font-size: 1em;margin-bottom: 2em;}
    pre code {background: none;font-family: 'Courier New', Courier, monospace;font-size: 1em;}
    p strong {color: #444;}
    .section-header {background-color: #eeb;font-weight: bold;color: #000;}
    .sidebar {  position: fixed;  top: 0;  left: calc(50% - 800px/2 - 260px);  height: 100%;  overflow-y: auto;  padding: 1em;  border-right: 10px solid #fdfaf9;   width: 200px;   margin-top: 50px; }
    .sidebar a {   text-decoration: none; color: #333;}
    .sidebar-title {  font-weight: none;  user-select: none; }
    .sidebar-name { font-weight: bold; user-select: none;  color: #73181d; }
    .token.special-amp {color: red;font-weight: bold; }
    .sidebar-sub { 
      font-size: 0.9em;
      margin-left: 1em;
    }
    .sidebar-sub a:hover {
      color: #177042;
      transform: scale(1.05);          /* visually enlarges the text */
      display: inline-block;          /* required so transform works properly */
      transition: transform 0.2s ease, color 0.2s ease; /* smooth animation */
    }

    details {margin:1.2em 0;padding:0.75em 1em;border-radius:10px;background:#fffefa;border:1px solid #ddd;box-shadow:0 2px 6px rgba(0,0,0,0.05);transition:all 0.25s ease;}
    details[open] {background:#fdf7e3;border-color:#d4b871;box-shadow:0 3px 8px rgba(0,0,0,0.1);}
    details summary {cursor:pointer;font-weight:bold;font-size:1.05em;color:#177042;outline:none;list-style:none;display:flex;align-items:center;}
    details summary::-webkit-details-marker {display:none;}
    details summary::before {content:"▶";margin-right:8px;font-size:0.9em;transition:transform 0.25s ease;color:#73181d;}
    details[open] summary::before {transform:rotate(90deg);}
    details p,details pre,details ul {margin-top:0.7em;}


    @media (max-width: 768px) {
      .sidebar {transform: translateX(-100%); }
      .sidebar.open {transform: translateX(0);}
      .sidebar-toggle {display: block;}
      .container {margin-left: 0 !important;}
    }
</style>
</head>
<body>

<div class="navbar">
  <a href="index.html"><img src="smol.png" alt="home">Index</a>
  <a href="https://github.com/maniospas/smol" target="_blank"><img src="github.png" alt="github">GitHub</a>
</div>


<div class="sidebar">
  <div class="sidebar-section">
    <a class="sidebar-title" href="#get-started"><span class="sidebar-name">Get started</span></a>
    <div class="sidebar-sub">
      <a href="#hello-world">Hello world</a><br>
      <a href="#variables">Variables</a>
    </div>
  </div>

  <div class="sidebar-section">
    <a class="sidebar-title" href="#flow"><span class="sidebar-name">Flow</span></a>
    <div class="sidebar-sub">
      <a href="#conditions">Conditions</a><br>
      <a href="#loops">Loops</a><br>
      <a href="#algorithms">Algorithms</a>
    </div>
  </div>

  <div class="sidebar-section">
    <a class="sidebar-title" href="#functions"><span class="sidebar-name">Functions</span></a>
    <div class="sidebar-sub">
      <a href="#arguments">Arguments</a><br>
      <a href="#returns">Returns (named tuples)</a><br>
      <a href="#errors">Error handling</a><br>
      <a href="#recursion">Recursion</a>
    </div>
  </div>

  <div class="sidebar-section">
    <a class="sidebar-title" href="#advanced"><span class="sidebar-name">Advanced</span></a>
    <div class="sidebar-sub">
      <a href="#unions">Unions</a><br>
      <a href="#memory">Memory</a><br>
      <a href="#strings">Strings</a><br>
      <a href="#buffers">Buffers</a><br>
      <a href="#recursion">Recursion</a>
    </div>
  </div>
</div>

<div class="container">

<h1 id="get-started">Get started <a href="#get-started" class="anchor-link">🔗</a></h1>

<h2 id="hello-world">Hello world <a href="#hello-world" class="anchor-link">🔗</a></h2>

<p>
Let's take our first steps into programming with <i>smoλ</i> 
(pronounced like "small" but with "o" instead of "a"). The language 
simplifies a lot of traditional programming concepts while keeping the ability to 
write very fast yet safe code. Some level of control is sacrificed in the process, but this means 
that you do not need to worry too much about details either. 
</p>
<p>
Our first program shows how to print a message.
Download the <code class="language-smolambda">smol</code> executable 
from the <a href="https://github.com/maniospas/smol/releases/latest">latest release</a>.
Place it alongside the <code>std</code> directory and add both the containing folder 
and a C/C++ compiler (e.g., GCC) to your system PATH. Finally, create a file named <i>main.s</i> 
with the text below. Open a terminal in the same folder and run 
<code>smol main.s</code>.
</p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    print("Hello world!")
    end
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
Hello world!
</pre>

<p>
As a quick preview, <code class="language-smolambda">@include std.core</code> 
adds basic functionality, like <code class="language-smolambda">print</code>. Then  
<code class="language-smolambda">service main()</code> is your actual program.
Finally, the line with <code class="language-smolambda">end</code> marks its completion.
</p>

<details>
<summary>Advanced compilation options.</summary>

There are several options you can add to smoλ's compilation,
most of which can be seen in the above result. Some of these
concepts can be understood only after reading the rest of this tutorial:

<ul>
  <li><code>--back [compiler]</code> The compiler backend that is used to compile an intermediate
  C code representation produced by <i>smoλ</i>. Default is 
  the highly robust <i>gcc</i>, but for example you may want to use another compile installed in
  your system, or something like <i>tcc</i> (tinycc) for very fast compilation during prototyping.
  You can also use a C++ compiler to allow unsafe injection of code from that language too; everything
  has been configured to work with both C99 or later and C++11 or later.</li>
  <li><code>--runtime [name]</code> Determines how the compilation outcome will make
  use of the target platform's capabilities. This may change, for example, the memory allocation
  strategy for embedded devices, some of which require custom implementations of heap allocation 
  or require custom management of one huge preallocated memory segment. Such changes are controlled
  via runtime files, which are then picked by the standard library or other <i>smoλ</i> code.
  Another affected characteristic is whether services are treated as parallel co-routines or
  eagerly executed. The runtime's name path to a <i>.h</i> file or the name of such a file
  in the <i>std/runtime/</i> directory. Default name is <i>auto</i>, corresponding to
  <i>std/runtime/auto.h</i> that chooses between an eager and co-routine implementation 
  of services depending on their number. There are two more runtimes provided out-of-the-box,
  <i>threads</i> that contains a co-routine implementaiton of services and <i>eager</i>
  that contains an eager calling of services.</li>
  <li><code>--task [name]</code> Controls whet the compiler actually does with the input code.
  The default task is <i>run</i>, which produces and runs an executable. You can set the following options:
  <ul>
    <li><i>compile</i> to only produce the executable but not run it.</li>
    <li><i>transpile</i> to produce a <i>.c</i> file
    containing an intermediate largely unreadable but still compile-able C transpilation of your program.</li>
    <li><i>assemble</i> to run the combination process but emmit readable assembly, <i>verify</i> to run
    a verification of correctness and print warning about sources of unsafety without producing any
    other outcome.</li>
    <li><i>lsp</i> to run the same verification process with markdown output that is what is leveraged 
    by the language's language server provider.</li>
    <li><i>doc</i> to produce an html file holding documentation of all functions available in the target file.</li>
  </ul>
  </li>
  <li><code>--workers [number]</code> The number of threads that can be involved in
 the type system resolution. This only affects compilation. Default is a single worker.</li>
</ul>

</details>

<h2 id="variables">Variables <a href="#variables" class="anchor-link">🔗</a></h2>

<p>
A variable is a named box that holds a value. You give it a name, then 
put a value in it once with the pattern <code class="language-smolambda">variable_name = value</code>. 
In programming, this process is called <i>assignment</i>. 
Names cannot start with numbers or contain
spaces or special symbols other than the underscore <code class="language-smolambda">_</code>.
They can also not be existing variables or other operations. 
</p>
<p>In <i>smoλ</i>, two consecutive underscores are not allowed either, because the language
uses the combination for some internal workings. Some valid variable names are <code>x</code>, <code>employee</code>,
<code>my_property</code>, <code>_temp_computation</code>, <code>MyDataStructure</code>, <code>var123</code>.
Below is an example where we set a constant 
text known during program creation (<code class="language-smolambda">cstr</code>) 
to a variable.
</p>

<pre><code class="language-smolambda">@include std.core

service main()
    greeting = "Hello world!"
    print(greeting)
    end
</code></pre>

<p>
Numbers are values too. There are three kinds you will use often:
</p>
<ul>
  <li><code class="language-smolambda">u64</code> — whole numbers without a sign (0, 1, 2, ...). The default when writing <code class="language-smolambda">2</code> or <code class="language-smolambda">42</code>.</li>
  <li><code class="language-smolambda">i64</code> — whole numbers with a sign (-1, +0, +1, ...) obtained by transforming <code class="language-smolambda">u64</code> values.</li>
  <li><code class="language-smolambda">f64</code> — numbers with a decimal point. The default when writing <code class="language-smolambda">2.0</code> or <code class="language-smolambda">3.14</code>.</li>
</ul>
<p>These are known as unsigned integers, signed integers, and float numbers, respectively. 
The above names reassure
experienced programmers that they indeed use 64 bits to represent the numbers under-the-hood. 
That is, unsigned integers can represent numbers <code class="language-smolambda">0 upto 2^65-1</code>
but signed ones can represent numbers <code class="language-smolambda">-2^64 upto 2^64-1</code>.
Floats follow the IEEE 754 standard, which is typically accurate to 15-17 significant digits.
</p>
<p>
For safety, you cannot mix operations between different types of numbers. For example, you cannot subtract 
a float from <code class="language-smolambda">0</code> but only from <code class="language-smolambda">0.0</code>.
However, you can convert between number formats with <code class="language-smolambda">value.type()</code>.
You would be surprised how many bugs are prevented by requiring only compatible numbers.
</p>
<p>
Below are some examples of numeric operations. Integer division by zero creates a runtime failure that you can intercept and handle at the level
of services. For floats, the IEEE 754 standard allows invalid operations like division by zero and lets them yield positive infinity, 
negative infinity, or NaN (not a number) values. You can check for those properties by correspondingly calling one of 
<code class="language-smolambda">is_inf</code> or <code class="language-smolambda">is_nan</code> 
that can be imported from <code class="language-smolambda"></code>std.math</code>. 
Lack of native error checking from the standard results in performant code.
</p>


<pre><code class="language-smolambda">@include std.core

service main()
    print(1+2)      // 3
    print(2/3)      // integer division (u64): 0
    print(2.0/3.0)  // float division (f64): a decimal result
    minus_one = 0.i64()-1.i64()
    print(minus_one) // -1
    end
</code></pre>

<p><b>Mutable variables:</b> After setting a variable, its value cannot normally change. To allow changes, declare it as <i>mutable</i> 
by placing <code class="language-smolambda">@mut</code> before its first declaration/assignment. 
Variables are immutable -that is, not mutable- by default to avoid many logic bugs. Always keep an eyes
for things that might have changed in the interim if something is mutable.</p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    @mut name = "Ada"
    print(name)
    name = "Lovelace" // allowed because we marked it mutable before
    print(name)
    end
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
Ada
Lovelace
</pre>


<h1 id="flow">Flow <a href="#flow" class="anchor-link">🔗</a></h1>

<h2 id="conditions">Conditions <a href="#conditions" class="anchor-link">🔗</a></h2>

<p>
Sometimes we only want certain lines to run if a tested condition is true.  
This is done with an <code class="language-smolambda">if</code> block.  
The word <code class="language-smolambda">if</code> starts the block, then comes a condition, 
then the code that should run if the test passes. 
Like with the <code class="language-smolambda">main</code> service so far, 
the block ends at <code class="language-smolambda">end</code>. </p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    if true
        print("this always runs")
    end end
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
this always runs
</pre>


<p>
<b>Style guide:</b> Prefer indenting the latter for easier reading, 
as well as starting it in a new line. Proper identation is a good coding practce for any
language, so try to stick to it. Do not be afraid
at merging multiple of end statements into one line; this helps keep your code concise.
Just make sure that you align those at their outermost level. For example, above we
placed <code class="language-smolambda">end end</code> at the identation showing the
service's end.
</p>

<p><b>Booleans:</b>
Above, the tsted condition is just the value <code class="language-smolambda">true</code>, so the message will always be printed.  
If you changed the condition to <code class="language-smolambda">false</code>, the inside would be skipped. These two values
(<code class="language-smolambda">true</code> and <code class="language-smolambda">false</code>) are 
known as boolean ones, or <code class="language-smolambda">bool</code> for short. 
More often, the test contains numerical or other comparisons that evaluate to a boolea value. 
For example, <code class="language-smolambda">2 &lt; 3</code> checks whether two is less than three.
</p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    if 2&lt;3
        print("yes, two is smaller")
    end end
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
yes, two is smaller
</pre>

<p>
There are several comparison operators you can use - some of these are defined for data other than numbers too:
</p>
<ul>
  <li><code class="language-smolambda">==</code> equal to</li>
  <li><code class="language-smolambda">!=</code> not equal to</li>
  <li><code class="language-smolambda">&lt;</code> less than</li>
  <li><code class="language-smolambda">&lt;=</code> less than or equal</li>
  <li><code class="language-smolambda">&gt;</code> greater than</li>
  <li><code class="language-smolambda">&gt;=</code> greater than or equal</li>
</ul>

<p>
We can also use <code class="language-smolambda">elif</code> (else if) 
and <code class="language-smolambda">else</code> branches to cover alternatves.  
Each branch is tried in order, until one runs. The rest are skipped. Here is an example; 
note that <code class="language-smolambda">end</code> is needed only at the last branch:
</p>

<pre><code class="language-smolambda">@include std.core

service main()
    x = 5
    if x&gt;0
        print("positive")
    elif x&lt;0
        print("negative")
    else
        print("zero")
    end end
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
positive
</pre>

<h2 id="loops">Loops <a href="#loops" class="anchor-link">🔗</a></h2>

<p>A loop repeats a block while a condition is true. Syntactically, it
starts with <code class="language-smolambda">while</code> followed by a condition 
and the block's contents. Similarly to conditions, 
the block ends at <code class="language-smolambda">end</code>.
If a variable changes inside the loop, is needs to be mutable during its first assignment.
Otherwise, the language would complain.</p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    @mut i = 0
    while i&lt;5
        print(i)
        i = i+1
    end end
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
0
1
2
3
4
</pre>


<p>The next snippet shows a pattern for looping through a <i>range</i> of unsigned integers <code class="language-smolambda">0 upto 4</code>.
You could skip the <code>0,</code> argument for further simplicity. More details will be fully presented later, but it 
would be remiss to not mention this pattern here, as it prevents accidental bugs. Broadly, the <code>next</code> function
progresses the range while tracking values by assigning them to mutable varable <code class="language-smolambda">i</code>. 
The latter is updated in every loop.
</p>
<p>
Notice the <code class="language-smolambda">.</code> before the <code class="language-smolambda">while</code>, which is how
range is transferred to <code>next</code>. With this pattern, you do not need to manually handle the increment, which
you might forget about or could be complicated. Similar patterns let you, for example, automate the process of reading
from fles.
</p>

<pre><code class="language-smolambda">// main.s
@include std.core

service main()
    range(0, 5).while next(@mut u64 i) 
        print(i)
    end end
</code></pre>


<h2 id="algorithms">Algorithms <a href="#algorithms" class="anchor-link">🔗</a></h2>


<p><b>Returning values:</b> Sometimes, you may want to conditionally assign a value to
a variable. If the variable is mutable, you can place a different assignment within 
each branch, though this requires the mutability -which is not as safe as immutable assignments-
and a priorly set default value. As an alternative, <i>smoλ</i> provides 
an <code class="language-smolambda">algorithm</code> control flow that starts a code block and
captures values obtained from internal statements of the form <code class="language-smolambda">return value</code>. 
Returns immediately end the code block, even if they occur within internally defined blocks.

<p>
Below is an example, which evaluates to several possibilities.
All returns must provide the same type of values. Do note that the return statement
also ends blocks in place of <code class="language-smolambda">end</code>. But, even if
there are nested conditions, all returns yield back a value to the <code class="language-smolambda">algorithm</code>.</p>

<pre><code class="language-smolambda">@include std.core

service main()
    x = 0.0-2.0
    sign = algorithm
        if x&gt;0.0 
            return "positive"
        if x&lt;0.0 
            return "negative"
        return "zero"

    print(sign)
    end
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
negative
</pre>

<p><b>Breaking away from loops:</b>
The <code class="language-smolambda">algorithm</code> structure can be used as a means from
breaking away from loops. Below is an example, where some commands are merged in the same line
for conciseness. Having an explicit <code class="language-smolambda">return</code> statement 
in all situations is necessary - the language would complain otherwise. The example returns
a boolean value indicating success or failure, but could also return the
<code class="language-smolambda">None</code> type from the included core.
</p>

<pre><code class="language-smolambda">@include std.core

service main()
    @mut i = 0
    algorithm while true
        print(i)
        if i==5 
            return true
        i = i+1
        end return false
    end
</code></pre>


<h1 id="functions">Functions <a href="#functions" class="anchor-link">🔗</a></h1>


<h2 id="arguments">Arguments <a href="#arguments" class="anchor-link">🔗</a></h2>

<p>
You can name a block of code and call it with inputs to obtain none, one, or multiple outputs. 
The named block is called a function and its inputs are called arguments. There are two kinds functions:
</p>
<ul>
  <li><code class="language-smolambda">def</code> — A function with no calling cost. Delegates error and resource handling to its caller.</li>
  <li><code class="language-smolambda">service</code> — Safely handles errors and resources, including resource freeing on failure.</li>
</ul>

<p>In simple programs you will mostly declare <code class="language-smolambda">def</code> functions
and let them freely fail. <i>Smoλ</i>'s philosophy is to not try to hopelessly recover from every failure state, 
but exit gracefully a bunch of dependent computations and try again. This is to strike a balance between error handling
code that polutes the codebase and recovering from impactful failures. Services are more complex in that they run
independently to each other.</p>
<p>Regardless of the type of function, you can declare arguments
as comma-separated variable types and names (each type corresponds to a name, separated by space). 
Types are needed so that the service can know what inputs to expect. 
For example, <code class="language-smolambda">f64 x</code> denotes an argument that is a float named <code>x</code>.
There may be some additional notation before types, described below.
</p>

<pre><code class="language-smolambda">@include std.core

def affine(f64 x, f64 y, f64 z) 
    return (x+y)*z

service main()
    result = affine(1.0, 2.0, 3.0)
    print(result) // 9.0
    end
</code></pre>

<p><b>Mutability:</b>
Inputs are passed "by value" (without affecting the call site) unless you explicitly allow changes.  
Place <code class="language-smolambda">@mut</code> before argument names to declare that 
the variable passed as an argument may be modified inside the function - and hence
must already be mutable. This also makes the argument variable internally mutable. 
Importantly, <b>services do not accept mutable arguments</b>. The pattern there is to have one service
control the creation process of data, and share that with other services.
Below is an example.
</p>

<pre><code class="language-smolambda">@include std.core

def increment(@mut u64 x)
    x = x + 1
    end

service main()
    @mut n = 10
    increment(n)
    print(n) // 11
    end
</code></pre>

<p>
Similarly to mutable variables declared within blocks of code, 
mutable arguments make prospective changes happen easy to spot. 
Conversely, if you do not see <code class="language-smolambda">@mut</code>, 
nothing changes.
</p>

<p>
<b>Functions as arguments:</b> 
You can use functions as arguments to help disambiguate between similarly-named alternatives.
In that case, simply skip the the variable name. This is useful for choosing a behavior 
without passing a dummy value.
</p>

<pre><code class="language-smolambda">@include std.core

def zero(f64) 
    return 0.0

def zero(u64) 
    return 0

service main()
    a = zero(f64)
    b = zero(u64)
    print(a) // 0.0
    print(b) // 0
    end
</code></pre>

<p>
<b>Currying:</b> 
The dot noration <code class="language-smolambda">first_argument.function_call(other_arguments)</code> 
sends the value on the left as the first argument of a function.  
This reads left-to-right and can be chained. Here is an example:
</p>

<pre><code class="language-smolambda">@include std.core

def triple(f64 x) 
    return x*3.0

service main()
    2
    .f64()
    .triple()
    .print()  // prints 6.0
    end
</code></pre>

<p>
The same colon also works with loops provided by the standard library (like <code class="language-smolambda">range</code>) so you can write readable iterations.
</p>

<h2 id="returns">Returns <a href="#returns" class="anchor-link">🔗</a></h2>

<p>
A block can return a value using <code class="language-smolambda">return</code>, or end with no value using <code class="language-smolambda">end</code>.
</p>

<pre><code class="language-smolambda">@include std.core

def abs(f64 x)
    if x&lt;0.0 
        |return 0.0-x
    return x

service main()
    x = 0.0-1.0
    print(abs(x)) // 1.0
    end
</code></pre>

<p>
You can return several named values at once and then access them by their variable's name with a 
dot notation. For example, if the outcome returning with <code class="language-smolambda">return x,y</code>
is stored into a variable <code>p</code>, individual values can be accessed via <code>p.x</code> or <code>p.y</code>.
This is visually different from currying in that there is no function call parenthesis. But returned values would not
be retrievable from <code class="language-smolambda">return x+1,y+1</code>, as the additions have not been stored
in a named variable. This is also fine, and you may do it for convenience in some scenarios.
Finally, <code class="language-smolambda">@args</code> is a shorthand that returns all inputs
and accessing fiels is also done with the dot notation. Below is an example.
</p>

<pre><code class="language-smolambda">@include std.core

def Point(f64 x, f64 y) 
    return @args

def moved(Point p, f64 dx, f64 dy)
    nx = p.x + dx
    ny = p.y + dy
    return Point(nx, ny)

service main()
    @mut p = Point(1.0, 2.0)
    print(p.x) // 1
    print(p.y) // 2
    p = p.moved(3.0, 4.0)
    print(p.x) // 4
    print(p.y) // 6
    end
</code></pre>

<p>
If a function returns only one value, you use that directly, that is, without an extra field name.
</p>

<p>
To help you write secure code that does not arbitrarily access mutable fields, <i>smoλ</i> normally
precents you from accessing or setting them. To be able to do so, add <code class="language-smolambda">@access</code>
at the very start of respective arguments. Below is an example where, without this notation, even immutable versions
of a runtype will not let you view mutable fields.
</p>


<pre><code class="language-smolambda">@include std.core

def Point(f64 _x, f64 _y) 
    @mut x = _x
    @mut y = _y
    return x,y

def print(@access Point p)
    // p is not mutable but you still need `@access` 
    // to look at p.x, p.y because their original 
    // declaration was mutable
    printin(x)
    printin(",")
    print(y)
    end

service main()
    @mut p = Point(1.0, 2.0)
    // print(p.x) // not allowed
    print(p)
    end
</code></pre>


<h2 id="errors">Error handling <a href="#errors" class="anchor-link">🔗</a></h2>

<p>
Now is the right time to talk about services and their philosophy: they are basically
runtypes that run in parallel threads 
(in truth: with a co-routine model but this is too advanced 
for this tutorial) and, when something is wrong -including in one of their called runtypes-, 
they complain and stop their work. When they stop, they also safely release any resources so that 
you do not have memory leaks or other similar issues.
Anywhere, call <code class="language-smolambda">fail("message")</code> to stop the current service.
</p>

<p>
The caller can check <code class="language-smolambda">result.err.bool()</code>.  
If you don’t check but try to use a value, the error will bubble up until it reaches a place that does.
Your code waits for computations to conclude by called services only when values are used.
</p>

<pre><code class="language-smolambda">@include std.core

service divide(f64 x, f64 y)
    if y==0.0 
        return fail("Division by zero")
    return x/y

service main()
    r = divide(1.0, 0.0)
    if r.err.bool()
        print("Could not compute.")
        end
    else
        print(r)
    end end
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
Division by zero
Could not compute.
</pre>

<p>
This approach keeps the happy path simple; you try running the service and, if it fails, decide what the next step is (ask again, use a default, stop).
</p>


<h1 id="advanced">Advanced <a href="#advanced" class="anchor-link">🔗</a></h1>

<h2 id="unions">Unions <a href="#unions" class="anchor-link">🔗</a></h2>

<p>
Sometimes we want to treat several different types as if they were “the same kind of thing.”  
For example, an integer, a float, and a signed integer are all numbers with similar operation defined;
thus we can write code that reads largely the same for all of those. 
In <i>smoλ</i>, you can avoid repeating that code by defining a <code class="language-smolambda">union</code>.
The latter groups together several types under a single name and you can define 
functions that work with the union instead of each type separately. Its definition looks like
an assignment, where the right-hand-side types are separated by <code class="language-smolambda">or</code>.
</p>

<pre><code class="language-smolambda">union Number = f64 or u64 or i64 
</code></pre>

<p>
This definition means that <code class="language-smolambda">Number</code> can represent 
<code>u64 class="language-smolambda"</code>, 
<code class="language-smolambda">f64</code>, or <code class="language-smolambda">i64</code>. 
Once the union is defined, you can write 
functions that take a <code>Number</code> and automatically work with whichever 
form it has. For example, the standard library has printing and arithmetic operator overloads: 
so you can call <code>print</code> on a <code>Number</code> and it “just works.”
Unions are lexically scoped within functions; the same name always represents the same type.
Thus in the example below both numbers must be of the same type. 
But you can add a union as part of another one to transfer all types under a different name.
</p>

<pre><code class="language-smolambda">@include std.core // defines Number

def add1mul(Number a, Number b)
    // convert 1 to the Number correct primitive
    one = 1.Number()
    return (a+one)*(b+one)

service main()
    print(add1mul(1,2))      // prints 6
    print(add1mul(1.0, 2.0)) // prints 6.0
    end
</code></pre>


<p>
Behind the scenes, <i>smoλ</i> makes sure that union usage is safe and the right code runs 
depending on which variant you are using; new functions immediately
check if they can work for all variations of union members to report errors early.
</p>

<details>
<summary>Why unions are useful</summary>
<p>
  Unions let use overload function names (like <code>print</code>) by dynamically
  adapting them on the type. However, only the declared member types are allowed.
  They further quickly create zero-cost overloaded variations of functions with the same code.
</p>

<p>
Think of unions as a way to say:  
<i>“I don’t care if this is an <code>i64</code> or an <code>f64</code> — 
as long as it’s a <code>Number</code>, I can use the overloaded operations
to write the same code conceptually.”</i>
</p>

</details>


<h2 id="memory">Memory <a href="#memory" class="anchor-link">🔗</a></h2>

<p>
At this point, you may be wondering how can <i>smoλ</i> run operations that consume an indeterminate 
amount of memory, such as combining strings or managing lists of arbitrary sizes. This is where buffers and the
<code class="language-smolambda">std.mem</code> import come. Here, we start from touching on concepts
from the import, to give a general picture. Broadly, there are two memory
devices; the <code>Stack</code> and <code>Heap</code>, corresponding to the small but fast
memory your operating system uses to run your program, and the full extend of availabel memory.
These provide memory allocation capabilities, but also grant you the ability to allocate more
memory either dynamically or as arenas at the respective device.</p>

<p>Memory follows the same pattern as
all resources that <i>smoλ</i> uses; it is freed only when not in use by any of your program's data.
This is achieved with some minor restrictions that the compiler will let you know occasionally. For example,
you need to declare the surfaces of memory management (the <code class="language-smolambda">on</code>
statements mentioned below) outside of loops that would leak the memory in each execution. However, the
benefit is that there is no running overhead or bottlenceck for testing when memory is no longer needed
and freeing it. Instead, memory is released back to the operating system at function ends that are
determined during compilation. That is, memory management is a zero-cost abstraction.
</p>

<p>
<b>Arenas:</b> Of the aforementiond types of memory, arenas are pre-allocated memory regions that cannot grow. 
They are typically made to consume more than needed speed
to ensure that programs can successfully run. However, new allocations on them are very 
lightweight (simple additions) so they are very fast to execute. If arenas
run out of space, they cause services to fail, which is always done safely and without leaking
resources. Here is how to work with arenas, where the <code class="language-smolambda">on</code>
block automatically adds the arena to operations that need it inside. 
</p>

<pre><code class="language-smolambda">@include std.core
@include std.mem
@include std.vec

service main()
    // allocate a stack arena of 1024 bytes
    @mut memory = Stack.arena(1024)

    on memory
    v = vector(5) // calls vector(memory,5)
    print(v.len())
    end
</code></pre>

<p>
If you switch to <code>Heap</code> instead of <code>Stack</code>, the same code 
would allocate on your random access memory, though the exact details of how heap 
memory is manageed may be modified under the hood for different systems by passing 
a different runtime configuration to the compiler.
</p>


<p>In the above segment, mutability is needed to allow modification of memory contents.
However, variables not assigned to any symbol are by default mutable. You can also return a
value from that block, therefore making the following equivalent syntax possible. 
Remember that the arena's consumed memory is not released at the end of the 
<code class="language-smolambda">on</code> block, but only when the vector is no longer needed. 
</p>

<pre><code class="language-smolambda">@include std.core
@include std.mem
@include std.vec

service main()
    on Stack.arena(1024) 
    v = vector(5)

    on None
    print(v.len())
</code></pre>


<p><b>Dynamic memory:</b>
You can also choose to maintain a collection of dynamically allocated memory segments,
for example by calling <code class="language-smolambda">on Heap.dynamic()</code> instead
of creating an arena. If multiple if of those segments are attached to the same dynamic
allocation, they are also released together, which means that they remain allocated as 
long as any is in use. However, you can also retain one allocation per dynamic memory.
</p>


<i>For more types of memory and operations, refer to the standard library's
  documentation <a href="std.html">here</a>. The implemented model
  deep and allows parameterization of functions by being able to allocate
  on segments of already allocated memory.
</i>


<h2 id="strings">Strings <a href="#strings" class="anchor-link">🔗</a></h2>

<p>
<i>Smoλ</i> provides three main string types: 
<code class="language-smolambda">cstr</code> (a constant string enclosed in quotations during compilation, zero-terminated), 
<code class="language-smolambda">nstr</code> (zero-terminated with length information), and 
<code class="language-smolambda">str</code> (a string segment). For most purposes, you can use and convert results to
<code class="language-smolambda">str</code>.
</p>

<p>
Most operations on strings are zero-cost abstractions over simple arithmetics, as happens 
for example when retrieving substrings. The most heavyweight operations are copying and
concatenation, both of which require an arena or dynamic memory to store the result. Below
is an example, where it is important to note that concatenation yilds a <code class="language-smolambda">nstr</code>
by default, which can be directly reduced to a simpler <code class="language-smolambda">str</code> if needed.
Similarly, conversion of <code class="language-smolambda">cstr</code> to the other types is lightweight.
</p>


<pre><code class="language-smolambda">@include std.core
@include std.mem

def Segment(nominal, str value)
    // return all inputs 
    // function returns are tuples of named elements
    return @args

def Segment(String _value)
    // convert from many string types
    value = _value.str()
    return nominal.Segment(value)

def combine(Segment[] segments)
    @mut combined = "".str()  // mutable string with known size
    on Stack.arena(1024)      // automatically use as argument if needed (for string operations)
    segments.len().range().while next(@mut u64 i) 
        combined = str(combined+segments[i].value+" ")
        end
    return combined

service main()
    segments = Segment[] // buffer
    .push("I think.".Segment())
    .push("Therefore I am.".Segment())
    segments.combine().print()
    end
</code></pre>


<h2 id="buffers">Buffers <a href="#buffers" class="anchor-link">🔗</a></h2>

<p>
Buffers represent collections of data that grow dynamically.  
The simplest syntax is <code>type[]</code>, which produces 
a resizable array of that type.
</p>

<pre><code class="language-smolambda">@include std.core

def data(u64 id, u64[] values) 
    return @args

service main()
    @mut vals = u64[]
    .push(1)
    .push(2)

    p = data[]
    .push(data(10, vals))

    print(p[0].id)        // 10
    print(p[0].values[0]) // 1
    print(vals[0])        // 1
    end
</code></pre>

<p>
By default, buffers use dynamically sized Heap memory to store their data. However, you can
also create them on memory allocations created from the standard library; all types of memory
accept an ,<code>allocate(size)</code> function for setting aside a fixed-size region, within
which buffers can grow. Below is an example. Do note that data can be pushed onto buffers during
their creation, while they are temporary variables -and hence mutable- and the result can be 
assigned to an immutable variable.
</p>



<pre><code class="language-smolambda">@include std.core

service main()
    vals = u64[Heap.allocate(1024)] // 1024 max buffer size
    .push(1)
    .push(2)

    print(vals[0])
    end
</code></pre>



<p>
Buffers preserve mutability rules: 
if a buffer itself is mutable, its contents can be changed or extended.
Strings can also be stored in buffers or arrays <b>given that they reside
in the same memory surface</b>.
Below is an example.
</p>

<pre><code class="language-smolambda">@include std.core
@include std.mem

service main()
    boxes = str[]
    .push("buffer start".str())
    .push("buffer end".str())

    b = boxes[0]
    print(b)
    end
</code></pre>

<p>
Here we pushed two strings into a string array. 
Notice the explicit conversion to the correct string version using <code>.str()</code>.
</p>

<details>
<summary>Returning buffers from services</summary>

<pre><code class="language-smolambda">@include std.core

service samples()
    buf = u64[]
    .push(42)
    .push(10)
    return buf

service main()
    buf = samples()
    print(buf[0]) // prints 42
end
</code></pre>

<p>
Here <code>samples</code> constructs and returns a buffer.  
The caller can then access its elements with <code>buf[index]</code>.
</p>
</details>

<h2 id="recursion">Recursion <a href="#recursion" class="anchor-link">🔗</a></h2>

<p>
In most languages, <i>recursion</i> means that a function calls itself, or that 
it calls another function that eventually calls itself.
This is useful, but it usually comes at a cost: every call stacks on top of the previous one, 
and if you recurse too deeply, you might run out of memory (a “stack overflow”).
<i>Smoλ</i> functions can only look at previously declared or imported functions
in an effort to protect such unconstrained behavior. But the same recursive computations
are still possible.
</p>

<p>
In particular, instead of creating dependent calls, the language uses a trick called <b>trampolining</b>.  
Think of it like a ball bouncing back and forth between two or more functions: 
each one decides what the next step is, and we loop until the process finishes.  
This way, recursion does not pile up memory; it just reuses a single loop.
</p>

<p>
Below is an example that demonstrates how to do this using a <code class="language-smolambda">tag</code> primitive that 
we have not addressed so far. That consists of writing 
<code class="language-smolambda">;name</code> and behaves like a number with a given value.
Importatly, tag values, can overlap with function names, which a <code class="language-smolambda">@dynamic</code>
instruction uses to its advantage to execut dfferent functions given different tag values.
</p>

<p>Below is a concrete example of how this can work in practice. 
There, the <code class="language-smolambda">tag</code> primitive type lets us reference <code>:ping</code> or <code>:pong</code> anywhere,
even before those are being defined. Then, the <code>@dynamic</code> instruction chooses to call a function
among various options (<code>ping</code> or <code>pong</code> here) depending on the next tag value. Additional
tag values are added as first arguments.
If something unexpected happens, such as another tag was found, the service just fails safely, without memory leaks or crashes.
At the same time, types are safe and are checked during compilation.</p>

<pre><code class="language-smolambda">@include std.core

def lambda(tag func, u64 n) 
    return @args

def ping(u64 n, cstr message)
    printin(message)
    print("ping")
    return :pong.lambda(n)

def pong(u64 n, cstr message)
    if n == 0
        return :done.lambda(u64)
    printin(message)
    print("pong")
    return :ping.lambda(n-1)

service main()
    @mut pending = :pong.lambda(2)
    while :done!=pending.func
        pending = 
            @dynamic(ping,pong)
            pending("next - ")
    end end
</code></pre>

<p>
To sum up, in the example above <code>ping</code> and <code>pong</code> call each other back and forth.
Instead of diving deeper into the stack, they just return a next state marked with a tag
(<code class="language-smolambda">:ping</code>, <code class="language-smolambda">:pong</code>, or <code class="language-smolambda">:done</code>). 
The main loop keeps track of which step is next, and runs it until it reaches the <code>:done</code> tag.</li>
</ul>

<p>
So whenever you would normally write a recursive function, you can instead write it 
as a loop with tags. It feels a bit like building a tiny “interpreter” 
for your recursive logic that is safe and efficient, and performant. Do note that 
<code class="language-smolambda">@dynamic</code> may inject code from all functions it
handles, so do not overuse it to avoid creating exceptionally large executables.
</p>




</div>




<script src="vendor/prism/prism.min.js"></script>
<script>
Prism.languages.smolambda = {
  'comment': /\/\/.*/,
  'directive': {
    pattern: /@\w+/,
    alias: 'important'
  },
  'constant': {
    pattern: /\:\w+/,
    alias: 'important'
  },
  'keyword': [
    {
      pattern: /\b(?:def|service|if|return|else|elif|with|case|qed|include|algorithm|while|union|to|upto|lento|len|and|or|on)\b/,
      greedy: true
    },
    {
      pattern: /(\.|\||\:)/,
      greedy: true
    }
  ],
  'special-amp': {
    pattern: /&/,
    alias: 'operator' // optional, gives Prism’s operator style too
  },
  'builtin': /\b(?:i64|u64|f64|None|true|false|ptr|cstr|nstr|str|buffer|main|copy|bool|not|cos|sin|tan|acos|asin|atan|pi|exp|log|pow|sqrt|add|mul|sub|div|nominal|tag)\b/,
  'punctuation': /[{}();,\[\]]/,
  'number': /\b\d+\b/,
  'string': {
    pattern: /"(?:\\.|[^"\\])*"/,
    greedy: true
  }
};
</script>
<script>
  document.querySelectorAll('a.anchor-link').forEach(a =>
    a.addEventListener('click', e => {
      if(location.hash === a.getAttribute('href')) e.preventDefault()
    })
  )
</script>

</body>
</html>
