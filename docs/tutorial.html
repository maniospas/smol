<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Smoλ is a low-level language with fast zero-cost abstractions that are organized into failsafe services.">
  <meta name="keywords" content="smolambda, low-level language, smoλ, programming language, runtype, safe language, systems programming, DSL">
  <meta name="author" content="Emmanouil (Manios) Krasanakis">
  <meta name="robots" content="index, follow">
  <link rel="icon" href="smol.png" type="image/x-icon">

  <title>smoλ</title>
  <link href="vendor/prism/prism.min.css" rel="stylesheet" />
  <style>
    html {scroll-behavior: smooth;}
    h1 {scroll-margin-top: 60px;}
    h2 {scroll-margin-top: 60px;}
    h3 {scroll-margin-top: 60px;}
    h1[id], h2[id], h3[id] { position: relative; }
    .anchor-link {text-decoration: none;font-size: 0.9em;margin-left: 8px;opacity: 0;transition: opacity 0.2s;}
    h1:hover .anchor-link,
    h2:hover .anchor-link,
    h3:hover .anchor-link { opacity: 1; }
    body {font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;margin: 0;background-color: #f9f9f9;color: #333;line-height: 1.7;}
    .navbar { background: #fffbf0; box-shadow: 0 4px 14px rgba(0, 0, 0, 0.1);  padding: 0px;position: sticky;top: 0;z-index: 1000;display: flex;flex-wrap: wrap;justify-content: center;}
    .navbar a {color: white;text-decoration: none;padding: 5px 10px;font-weight: bold;}
    .navbar span {color: white;text-decoration: none;padding: 5px 10px;font-weight: bold;}
    .navbar a:hover {box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);transform: translateY(-1px);border-radius: 20px;}
    .navbar a img {width: 40px;height: 40px;margin-top:5px}
    .navbar a:hover img {width: 45px;height: 45px;margin:0px}
    .container {max-width: 800px;margin: 40px auto;padding: 0 20px;}
    h1, h2, h3 {color: #222;}
    table {width: 100%;border-collapse: collapse;margin-bottom: 2em;background-color: white;}
    th, td {border: 1px solid #ccc;padding: 10px;text-align: left;vertical-align: top;}
    th {background-color: #eee;}
    code {background: #eee;padding: 2px 0px;border-radius: 4px;font-family: 'Courier New', Courier, monospace;font-size: 95%;}
    pre {background: #272822;padding: 15px;border-radius: 8px;overflow-x: auto;font-size: 90%;margin-bottom: 2em;}
    pre code {background: none;font-family: 'Courier New', Courier, monospace;font-size: 90%;}
    p strong {color: #444;}
    .section-header {background-color: #eeb;font-weight: bold;color: #000;}
    .sidebar {  position: fixed;  top: 0;  left: 0;  max-height: 100vh;  overflow-y: auto;  background: #fafafa;   padding: 1em;   border-right: 1px solid #ddd;   width: 220px;   margin-top: 50px; }
    .sidebar a {   text-decoration: none; color: #333;}
    .sidebar a.active {  font-weight: bold;  color: #177042; }
    .sidebar-title {  font-weight: none;  cursor: pointer;  user-select: none;  font-size: 0.75em; }
    .sidebar-name { font-size:1.3em; font-weight: bold;  cursor: pointer;  user-select: none;  color: #73181d; }
    .sidebar-sub { font-size: 0.9em;  margin-left: 1em; display: none; }
    .token.special-amp {color: red;font-weight: bold; }

    @media (max-width: 768px) {
      .sidebar {transform: translateX(-100%); }
      .sidebar.open {transform: translateX(0);}
      .sidebar-toggle {display: block;}
      .container {margin-left: 0 !important;}
    }
  </style>
</head>
<body>

<div class="navbar">
  &nbsp;&nbsp;
  <a href="index.html"><img src="smol.png" alt="home"></a>
  <a href="https://github.com/maniospas/smol" target="_blank"><img src="github.png" alt="github"></a>
</div>

<div class="sidebar">
  <div class="sidebar-section">
    <div class="sidebar-title">▶ <span class="sidebar-name">Get started</span></div>
    <div class="sidebar-sub">
      <a href="#hello-world">Hello world</a><br>
      <a href="#variables">Variables</a>
    </div>
  </div>

  <div class="sidebar-section">
    <div class="sidebar-title">▶ <span class="sidebar-name">Flow</span></div>
    <div class="sidebar-sub">
      <a href="#conditions">Conditions</a><br>
      <a href="#loops">Loops</a><br>
      <a href="#uplifting">Uplifting</a>
    </div>
  </div>

  <div class="sidebar-section">
    <div class="sidebar-title">▶ <span class="sidebar-name">Calls</span></div>
    <div class="sidebar-sub">
      <a href="#arguments">Arguments</a><br>
      <a href="#mutability">Mutability</a><br>
      <a href="#typeargs">Type arguments</a><br>
      <a href="#currying">Currying</a>
    </div>
  </div>

  <div class="sidebar-section">
    <div class="sidebar-title">▶ <span class="sidebar-name">Returns</span></div>
    <div class="sidebar-sub">
      <a href="#returns">Returns</a><br>
      <a href="#fields">Fields</a><br>
      <a href="#errors">Error handling</a>
    </div>
  </div>
</div>

<div class="container">

<h1 id="hello-world">Hello world <a href="#hello-world" class="anchor-link">🔗</a></h1>

<p>
Let's take our first steps into programming with <i>smoλ</i> 
(pronounced like "small" but with "o" instead of "a"). The language is a bit 
atypical in that it simplifies a lot of traditional programming concepts while keeping the ability to 
write very fast yet safe code. Some level of control is sacrificed in the process, but this means 
that you do not need to worry too much about technical details. 
</p>
<p>
Our first program shows how to run a program and print a message.
Download the <code class="language-smolambda">smol</code> executable 
from the <a href="https://github.com/maniospas/smol/releases/latest">latest release</a>.
Place it alongside the <code>std</code> directory and add both the containing folder 
and a C/C++ compiler (e.g., GCC) to your system PATH. Finally, create a file named <i>main.s</i> 
with the text below. Open a terminal in the same folder and run 
<code class="language-smolambda">smol main.s</code>.
</p>

<pre><code class="language-smolambda">// main.s
@include std.builtins

service main()
    print("Hello world!")
    --
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
Hello world!
</pre>

<p>
As a quick preview, <code class="language-smolambda">@include std.builtins</code> 
adds basic tools like <code class="language-smolambda">print</code>,  
<code class="language-smolambda">service main()</code> is where your program starts, 
and the line with <code class="language-smolambda">--</code> marks the end 
of the program.
</p>

<h1 id="variables">Variables <a href="#variables" class="anchor-link">🔗</a></h1>

<p>
A variable is a named box that holds a value. You give it a name, then 
put a value in it once with the pattern <code class="language-smolambda">variable_name = value</code>. 
This process is called an <i>assignment</i>. Names cannot start with numbers or contain
spaces or special symbols other than the underscore <code class="language-smolambda">_</code>. 
Having two consecutive underscores is also not allowed. Below is an example where we set a 
constant text known during program creation (<code class="language-smolambda">cstr</code>) 
to a variable.
</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    greeting = "Hello world!"
    print(greeting)
    --
</code></pre>

<p>
Numbers are values too. There are three kinds you will use often:
</p>
<ul>
  <li><code class="language-smolambda">u64</code> — whole numbers without a sign (0, 1, 2, ...). The default when writing <code class="language-smolambda">2</code> or <code class="language-smolambda">42</code>.</li>
  <li><code class="language-smolambda">i64</code> — whole numbers with a sign (-1, +0, +1, ...) obtained by transforming <code class="language-smolambda">u64</code> values.</li>
  <li><code class="language-smolambda">f64</code> — numbers with a decimal point. The default when writing <code class="language-smolambda">2.0</code> or <code class="language-smolambda">3.14</code>.</li>
</ul>
<p>These are known as unsigned integers, signed integers, and float numbers, respectively. 
The above names add <i>64</i> next to a mnemonic symbol to reassure
experienced programmers that we will use 64 bits to represent the numbers under-the-hood. 
That is, unsigned integers can represent numbers <code class="language-smolambda">0 upto 2^65-1</code>
but signed ones can represent numbers <code class="language-smolambda">-2^64 upto 2^64-1</code>.
Floats follow the IEEE 754 standard, which is typically accurate to 15-17 significant digits.
</p>
<p><b>Invalid operations:</b>
For safety, you cannot mix operations between different types of numbers. For example, you cannot subtract 
a float from <code class="language-smolambda">0</code> but only from <code class="language-smolambda">0.0</code>.
However, you can convert between number formats with <code class="language-smolambda">value:type</code>.
You would be surprised how many bugs are prevented by requiring explicit data conversions.
</p>
<p>
See below for examples. Integer division by zero creates a runtime failure that you can intercept and handle at the level
of services. For floats, the IEEE 754 standard allows invalid operations like division by zero and lets them yield positive infinity, 
negative infinity, or NaN (not a number) values. You can check for those properties by correspondingly calling one of 
<code class="language-smolambda">is_inf</code> or <code class="language-smolambda">is_nan</code> 
that can be imported from <code class="language-smolambda"></code>std.math</code>. 
Lack of native error checking from the standard results in performant code.
</p>


<pre><code class="language-smolambda">@include std.builtins

service main()
    print(1+2)      // 3
    print(2/3)      // integer division (u64): 0
    print(2.0/3.0)  // float division (f64): a decimal result
    minus_one = 0:i64-1:i64
    print(minus_one) // -1
    --
</code></pre>

<p><b>Mutable variables:</b> After setting a variable, its value cannot normally change. To allow changes, declare it as <i>mutable</i> 
by placing <code class="language-smolambda">&</code> before its name in its first assignment. 
Variables are immutable by default to avoid many logic bugs. Look out for the marking to spot values 
that can may change.</p>

<pre><code class="language-smolambda">// main.s
@include std.builtins

service main()
    &name = "Ada"
    print(name)
    name = "Lovelace" // allowed because we marked it mutable before
    print(name)
    --
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
Ada
Lovelace
</pre>

<h1 id="conditions">Conditions <a href="#conditions" class="anchor-link">🔗</a></h1>

<p>
Sometimes we only want certain lines to run if a tested condition is true.  
This is done with an <code class="language-smolambda">if</code> block.  
The word <code class="language-smolambda">if</code> starts the block, then comes a condition, 
then the code that should run if the test passes. Prefer indenting the latter for easier reading, 
as well as starting it in a new line.
Like before, the block ends at <code class="language-smolambda">--</code>.
</p>

<pre><code class="language-smolambda">// main.s
@include std.builtins

service main()
    if true
        print("this always runs")
        --
    -- // could merge both lines into ---- here
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
this always runs
</pre>

<p>
Here the test is just the value <code class="language-smolambda">true</code>, so the message will always print.  
If you changed the condition to <code class="language-smolambda">false</code>, the inside will be skipped. These are 
known as boolean values, or <code class="language-smolambda">bool</code> for short.
More often, the test contains numerical or other comparisons that evaluate to a boolea value. 
For example, <code class="language-smolambda">2 &lt; 3</code> checks whether two is less than three.
</p>

<pre><code class="language-smolambda">// main.s
@include std.builtins

service main()
    if 2&lt;3
        print("yes, two is smaller")
    ----
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
yes, two is smaller
</pre>

<p>
There are several comparison operators you can use - some of these are defined for data other than numbers too:
</p>
<ul>
  <li><code class="language-smolambda">==</code> equal to</li>
  <li><code class="language-smolambda">!=</code> not equal to</li>
  <li><code class="language-smolambda">&lt;</code> less than</li>
  <li><code class="language-smolambda">&lt;=</code> less than or equal</li>
  <li><code class="language-smolambda">&gt;</code> greater than</li>
  <li><code class="language-smolambda">&gt;=</code> greater than or equal</li>
</ul>

<p>
We can also add <code class="language-smolambda">elif</code> (else if) 
and <code class="language-smolambda">else</code> branches to cover other cases.  
Each branch is tried in order until one runs.
</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    x = 0.0-2.0
    sign = if x&gt;0.0 
          -> "positive"
        elif x&lt;0.0 
          -> "negative"
        else
          -> "zero"

    print(sign)
    --
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
negative
</pre>

<p>
Notice here that, above, each branch returns a string. All branches must return the same type, or nothing.  
For example, you could also just perform an action inside each branch:
</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    x = 5
    if x&gt;0
        print("positive")
        --
    elif x&lt;0
        print("negative")
        --
    else
        print("zero")
        --
    --
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
positive
</pre>

<p>
If you prefer, it is okay to keep code compact when it reads naturally, for example by writing one line:  
<code class="language-smolambda">if x&gt;0 -> print("positive")</code>.
</p>


<h1 id="loops">Loops <a href="#loops" class="anchor-link">🔗</a></h1>

<p>A loop repeats a block while a condition is true. Syntactically, it
starts with <code class="language-smolambda">while</code> followed by a condition 
and the block's contents. Those must end at <code class="language-smolambda">--</code>.
If a variable changes inside the loop, make it mutable during its first assignment.</p>

<pre><code class="language-smolambda">// main.s
@include std.builtins

service main()
    &i = 0
    while i&lt;5
        print(i)
        i = i+1
    ----
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
0
1
2
3
4
</pre>


<p>The next snippet shows a pattern for looping through a range of unsigned integers. This is 
less prone to accidental bugs is a pattern that will be fully explained later.
This pattern is known as an <i>iterator</i> because it builds on some data that can 
be traversed and assigns to a variable while traversing them. Here the data is a
a <code class="language-smolambda">range(5)</code> indicating values <code class="language-smolambda">0 upto 4</code> and
traversed values are assigned to <code class="language-smolambda">i</code>.
Iterators are convenient in that you do not need to manually handle the increment, which
you might forget about or could be complicated. For example, reading from
files is also implemented as an iterator.
</p>

<pre><code class="language-smolambda">// main.s
@include std.builtins

service main()
    range(5):while next(u64 &i) 
        print(i)
    ----
</code></pre>


<h1 id="uplifting">Uplifting <a href="#uplifting" class="anchor-link">🔗</a></h1>

<p>
Sometimes you want to stop not just the current block, but also its parent blocks
up to a certain level. In those cases, 
put a vertical bar <code class="language-smolambda">|</code> before the return symbol 
for each level you want to “jump up”. For example,
<code class="language-smolambda">|--</code> ends the current block and its parent. 
Similarly, <code class="language-smolambda">|-&gt;</code> returns a to the parent.  
Two bars (<code class="language-smolambda">||</code>) jump two levels, and so on.
</p>

<pre><code class="language-smolambda">@include std.builtins

service main()
    &i = 0
    while true
        print(i)
        if i==5 |-- // end loop early
        i = i+1
    ----
</code></pre>

<h1 id="arguments">Arguments <a href="#arguments" class="anchor-link">🔗</a></h1>

<p>
You can name a block of code and call it with inputs. These are called arguments.
There are two kinds of named blocks of code:
</p>
<ul>
  <li><code class="language-smolambda">smo</code> — a lightweight function. It is called a <i>runtype</i>.</li>
  <li><code class="language-smolambda">service</code> — a safer unit that handles errors and resources for you.</li>
</ul>

<p>For most simple programs, you will only mostly runtypes. Services are complex pieces of code that run
independently to each other. Adding arguments to a service is as simple as adding a list of comma-separated
variable types and names. Types are needed so that the service can know what inputs to expect. 
For example, <code class="language-smolambda">f64 x</code> denotes an argument that is a float named <code>x</code>.
</p>

<pre><code class="language-smolambda">@include std.builtins

smo affine(f64 x, f64 y, f64 z) 
    -> (x+y)*z

service main()
    result = affine(1.0, 2.0, 3.0)
    print(result) // 9.0
    --
</code></pre>

<h1 id="mutability">Mutability <a href="#mutability" class="anchor-link">🔗</a></h1>

<p>
Inputs are passed "by value" (without affecting the call site) unless you explicitly allow changes.  
Place <code class="language-smolambda">&</code> before argument names to declare that 
the variable passed as an argument may be modified inside the runtype or service - and hence
must already be mutable. This also makes the argument variable internally mutable. 
Below is an example.
</p>

<pre><code class="language-smolambda">@include std.builtins

smo increment(u64 &x)
    x = x + 1
    --

service main()
    &n = 10
    increment(n)
    print(n) // 11
    --
</code></pre>

<p>
Similarly to mutable variables declared within blocks of code, 
mutable arguments make prospective changes happen easy to spot. 
Conversely, if you do not see <code class="language-smolambda">&</code>, 
nothing changes.
</p>

<h1 id="typeargs">Type arguments <a href="#typeargs" class="anchor-link">🔗</a></h1>

<p>
You can use types as arguments to help disambiguate between similarly-named runtypes.
This is useful for choosing a behavior without passing a dummy value.
</p>

<pre><code class="language-smolambda">@include std.builtins

smo zero(f64) 
    -> 0.0

smo zero(u64) 
    -> 0

service main()
    a = zero(f64)
    b = zero(u64)
    print(a) // 0.0
    print(b) // 0
    --
</code></pre>

<h1 id="currying">Currying <a href="#currying" class="anchor-link">🔗</a></h1>

<p>
The colon <code class="language-smolambda">:</code> sends the value on the left as the first argument on the right.  
This reads left-to-right and removes extra parentheses when you chain steps.
</p>

<pre><code class="language-smolambda">@include std.builtins

smo triple(f64 x) 
    -> x*3.0

service main()
    print(2:f64:triple) // 6.0
    --
</code></pre>

<p>
The same colon also works with loops provided by the standard library (like <code class="language-smolambda">range</code>) so you can write readable iterations.
</p>

<h1 id="returns">Returns <a href="#returns" class="anchor-link">🔗</a></h1>

<p>
A block can return a value using <code class="language-smolambda">-&gt;</code>, or end with no value using <code class="language-smolambda">--</code>.  
Returning early is just a return higher up the page; use uplifting if you need to jump out of an extra level.
</p>

<pre><code class="language-smolambda">@include std.builtins

smo abs(f64 x)
    if x&lt;0.0 
        |-> 0.0-x
    -> x

service main()
    x = 0.0-1.0
    print(abs(x)) // 1.0
    --
</code></pre>

<h1 id="fields">Fields <a href="#fields" class="anchor-link">🔗</a></h1>

<p>
You can return several named values at once and then access them as fields.  
<code class="language-smolambda">@nominal</code> is a shorthand that returns all inputs by name.
</p>

<pre><code class="language-smolambda">@include std.builtins

smo Point(f64 x, f64 y) -> @args

smo moved(Point p, f64 dx, f64 dy)
    &nx = p.x + dx
    &ny = p.y + dy
    -> Point(nx, ny)

service main()
    p = Point(1.0, 2.0)
    print(p.x) // 1
    print(p.y) // 2
    q = p:moved(3.0, 4.0)
    print(q.x) // 4
    print(q.y) // 6
    --
</code></pre>

<p>
If a runtype returns only one value, you use that directly (no extra field name needed).
</p>

<h1 id="errors">Error handling <a href="#errors" class="anchor-link">🔗</a></h1>

<p>
When something is wrong, say it clearly and stop that unit of work.  
In a service, call <code class="language-smolambda">fail("message")</code>. The caller can check <code class="language-smolambda">result.err:bool</code>.  
If you don’t check, the error will bubble up until it reaches a place that does.
</p>

<pre><code class="language-smolambda">@include std.builtins

service divide(f64 x, f64 y)
    if y==0.0 
        -> fail("Division by zero")
    -> x/y

service main()
    r = divide(1.0, 0.0)
    if r.err:bool
        print("Could not compute.")
        --
    else
        print(r)
    ----
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
Division by zero
Could not compute.
</pre>

<p>
This approach keeps the main path simple. You try the thing. If it fails, you decide what the next step is (ask again, use a default, stop).
</p>

</div>

<script src="vendor/prism/prism.min.js"></script>
<script>
Prism.languages.smolambda = {
  'comment': /\/\/.*/,
  'directive': {
    pattern: /@\w+/,
    alias: 'important'
  },
  'keyword': [
    {
      pattern: /\b(?:smo|service|if|else|elif|with|include|do|while|union|to|upto|lento|len|and|or)\b/,
      greedy: true
    },
    {
      pattern: /(?:\|\|\|->|\|\|->|\|\|--|\|->|\|--|->|--|:|=)/,
      greedy: true
    }
  ],
  'special-amp': {
    pattern: /&/,
    alias: 'operator' // optional, gives Prism’s operator style too
  },
  'builtin': /\b(?:i64|u64|f64|ptr|cstr|nstr|str|buffer|main|copy|bool|not|cos|sin|tan|acos|asin|atan|pi|exp|log|pow|sqrt|add|mul|sub|div|nominal)\b/,
  'punctuation': /[{}();,\[\]]/,
  'number': /\b\d+\b/,
  'string': {
    pattern: /"(?:\\.|[^"\\])*"/,
    greedy: true
  }
};
</script>
<script>
  document.querySelectorAll('a.anchor-link').forEach(a =>
    a.addEventListener('click', e => {
      if (location.hash === a.getAttribute('href')) e.preventDefault()
    })
  )
</script>
<script>
document.querySelectorAll('.sidebar-title').forEach(title => {
  title.addEventListener('click', () => {
    const sub = title.nextElementSibling;
    const expanded = sub.style.display === 'block';
    sub.style.display = expanded ? 'none' : 'block';
    const arrow = expanded ? '▶' : '▼';
    title.innerHTML = arrow + ' ' + title.innerHTML.slice(2);
  });
});
</script>

</body>
</html>
