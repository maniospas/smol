<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Exploring how smoÎ» handles memory safety with arenas and failsafe services.">
  <meta name="keywords" content="smolambda, smoÎ», programming language, memory safety, arenas, services, systems programming">
  <meta name="author" content="Emmanouil (Manios) Krasanakis">
  <meta name="robots" content="index, follow">
  <link rel="icon" href="smol.png" type="image/x-icon">

  <title>smoÎ» Blog â€“ Memory safety via delayed freeing & failsafe services </title>
  <link href="../vendor/prism/prism.min.css" rel="stylesheet" />
  <style>
    html {scroll-behavior: smooth;}
    h1 {scroll-margin-top: 60px;}
    h2 {scroll-margin-top: 60px;}
    h3 {scroll-margin-top: 60px;}
    h1[id], h2[id], h3[id] { position: relative; }
    .anchor-link {text-decoration: none;font-size: 0.9em;margin-left: 8px;opacity: 0;transition: opacity 0.2s;}
    h1:hover .anchor-link,
    h2:hover .anchor-link,
    h3:hover .anchor-link { opacity: 1; }
    body {font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;margin: 0;background-color: #f9f9f9;color: #333;line-height: 1.7;}
    .navbar {background-color: #333;padding: 2px;position: sticky;top: 0;z-index: 1000;display: flex;flex-wrap: wrap;justify-content: center;}
    .navbar a {color: white;text-decoration: none;padding: 5px 10px;font-weight: bold;}
    .navbar a:hover {background-color: #555;}
    .container {max-width: 800px;margin: 20px auto;padding: 0 20px;}
    h1, h2, h3 {color: #222;}
    table {width: 100%;border-collapse: collapse;margin-bottom: 2em;background-color: white;}
    th, td {border: 1px solid #ccc;padding: 10px;text-align: left;vertical-align: top;}
    th {background-color: #eee;}
    code {background: #eee;padding: 2px 0px;border-radius: 4px;font-family: 'Courier New', Courier, monospace;font-size: 95%;}
    pre {padding: 15px;border-radius: 8px;overflow-x: auto;font-size: 90%;margin-bottom: 2em;}
    pre code {background: none;font-family: 'Courier New', Courier, monospace;font-size: 90%;}
    p strong {color: #444;}
    .token.special-amp {color: red;font-weight: bold; }
    .section-header {background-color: #eeb;font-weight: bold;color: #000;}
    .info-box {display: flex;align-items: center;gap: 15px; background: #fffbf0; box-shadow: 0 4px 14px rgba(0, 0, 0, 0.1);  border-radius: 12px;  padding: 20px;  margin: 20px 0;  transition: transform 0.2s ease, box-shadow 0.2s ease;  text-decoration: none;  color: inherit; }
    .info-box:hover {transform: translateY(-5px);box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);}
    .info-box img {width: 48px;height: 48px;}
    .info-box h2 {margin: 0 0 4px;font-size: 1.4em;}
    .info-box div {font-size: 1em;color: #333;}
    .info-box-text {display: flex; flex-direction: column;}
    .explain-button { position: absolute;  bottom: 10px; right: 10px;  padding: 6px 12px; font-size: 0.9em;  background-color: #ffffff; color: #333; border: 1px solid #aaa; border-radius: 6px; cursor: pointer; transition:  background-color 0.3s ease,  color 0.3s ease,  box-shadow 0.3s ease,  transform 0.2s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
    .explain-button:hover {background-color: #aafbf0;color: #333;box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); transform: translateY(-2px); border-radius: 30px;}
    .post-meta {font-size: 0.9em; color: #777; margin-bottom: 2em;}
  </style>
</head>
<body>

<div class="container">

  <div>
    <span id="post-title" style="font-size: 2.4em; font-weight: bold;">Memory safety via delayed freeing</span><br>
    <div class="post-meta">by Emmanouil (Manios) Krasanakis â€“ September 6, 2025</div>
  </div>

  <p>
    <i>"Yet another take on memory safety. Aren't there enough out there?"</i>
  </p>
  <p>If you are
    a little bit familiar with programming language design, this is a probable first reaction
    to this blog post. And, honestly, you would be mostly right. But 
    I believe there is a useful insight or two here. 
    Not to mention that snippets like the following
    from <i>smoÎ»'s</i> standard library are not going to explain themselves. 
    So I might as well give a full explanation <i>somewhere</i>. 
  </p>


  <pre><code class="language-smolambda">// from std/mem.device.s
smo ContiguousMemory (
        nominal, 
        MemoryDevice, 
        u64 size,
        Primitive,
        ptr mem,
        ptr underlying
    ) 
    -> @args

// from std/mem/arena.s
smo Arena(nominal type, ContiguousMemory contents)
    @noborrow
    length = 0
    size = contents.size
    with contents.Primitive:is(char)
    ---> type, contents, length, size</code></pre>

  <p>
    I already see with your first reaction: skipping the above snippet because
    it makes zero sense out-of-context. ðŸ˜‰ This is what I would do, at least.
    If you are more careful than me, you may look more closely and decide that, 
    with data structures like these to move around, who needs chromium in every app? - we 
    are going to consume all memory ourselves first!
  </p>
  <p>
    These concerns are all valid.
  </p>
  <p>
    Soooo... let me address them by explaining some of the zero-cost 
    design principles of <i>smoÎ»</i> that end up granting low-level control without sacrificing safety. 
    I will focus on memory safety, but other types of resources, such as files, use the same system.
    To keep things simple, I will also delegate description of mutability semantics to a different post 
    - <b>here consider all memory and contents to be immutable once allocated and data are inserted.</b>
  </p>


  <h2 id="recap">Recap on language concepts<a class="anchor-link" href="#recap">#</a></h2>

  <p>
    <b>Runtypes -</b> Before starting, a brief recap on the language is that it's centered 
    around the concept of <i>runtypes</i>. These are functions whose results serve
    as both tuples and type fields. For example, the following declares a nominal
    type, so that if you write <code class="language-smolambda">p=nominal:point2(x,y)</code> 
    you get fields <code  class="language-smolambda">p.x</code> and <code  class="language-smolambda">p.y</code>.
  </p>

  <pre><code class="language-smolambda">smo point2(nominal, f64 _x, f64 _y) 
  x = 2*_x 
  y = 2*_y 
  -> x,y // return statement</code></pre>
  
  <p>
    <b>Nominal types -</b> I shamelessly inserted two more concepts in the above explanation, 
    because they are pretty important and we will need them to read code later. First is
    <code class="language-smolambda">nominal</code>, which is a value indicating the type 
    and wch prevents matching any pair of <code class="language-smolambda">f64</code> values
    or other types containing the same values. 
    The language's typing is static though, so <code class="language-smolambda">nominal</code> indicators
    are removed by the compiler and are not available during execution. 
  </p>
  <p>
    <b>Currying -</b> Second is the language's currying symbol <code class="language-smolambda">:</code>, which 
    transfers the left-hand-sight as the first argument to the right. For example, 
    <code class="language-smolambda">obj:fun</code> means <code class="language-smolambda">fun(obj)</code>
    and <code class="language-smolambda">obj:fun(arg1,arg2)</code> means <code class="language-smolambda">fun(obj,arg1,arg2)</code>,
    and so on.
  </p>
  
  <p>
    <b>Smo vs services -</b> In general, there are two ways to declare runtypes; as <code class="language-smolambda">smo</code> delcarations,
    like above, or as <code class="language-smolambda">service</code>s. The main difference is that the former are inlined,
    whereas services are implemented as co-routines and give the opportunity of error handling when errors occur inside - to be addressed in
    another post.
  </p>


  <h2 id="no-memory">Where memory is <i>not</i> used <a class="anchor-link" href="#no-memory">#</a></h2>
  <p>
    A nice feature of <i>smoÎ»</i> is that its default runtype manipulation mechanism does not use heap memory but
    registers and th stack store local variables. For example, the previous <code class="language-smolambda">point2</code>
    runtype is simply stored into underlying variables <code class="language-smolambda">p__x.p__y</code>.
  </p>
  </p>
    Remember that smo definitions are inlined, so we can have very complex data transfers be zero cost by performing variable substitution
    and elimination. Currently, the language transpiles to an unholy subset of C with <code class="language-smolambda">goto</code> as 
    its intermediate representation. Mostly because I kinda dislike the bloat of working with the LLVM stack. So these optimization are 
    performed by modern C compilers (by default: <i>gcc</i>). Those compilers are exceptionally good at
    reasoning over simple named variables and assignments if we have already done the complicated analysis for them.
  </p>
  <p>
    For example, if the value <code class="language-smolambda">p.y</code> is never used, <code class="language-smolambda">p__y</code> 
    will be eliminated by the compilation process completely. Even if it's used elsewhere, inlining eventually means that we
    do not need to (re)load <code class="language-smolambda">p.y</code> from memory because it already resides in the stack.
    In the end, <b>we are free to keep "metadata" variables
    that help us track resource properties</b>, such as <code class="language-smolambda">ptr underlying</code> 
    to track the common allocated memory and <code class="language-smolambda">u64 size</code> for the current accessible size.
    These will either be eliminated or -if actually useful for runtime code- be kept at one place without moving around.
    Such optimization do not occur for service arguments, since these are proper stack-based functions, but the cost there
    is negligible compared to co-routine switching (which is already lightweight but uses mutexes).
  </p>

  <h2 id="release">Release timing <a class="anchor-link" href="#release">#</a></h2>
  <p>
    I previously made a point to explain the difference between <code class="language-smolambda">smo</code>
    and <code class="language-smolambda">service</code> because resources like memory are gathered
    by the compiler and their release code is inserted at the end of service calls. Those working in domains where 
    delays are critical now <i>know</i> at which point systems are going to do work. But we also
    have the benefit that, upon critical failures, like invalid file reads, 
    we know how to safely terminate the service without leaking resources. Error handling is also not for
    now, though.
  </p>
  <p>
    In the simplest case, there would only be the <code class="language-smolambda">main</code> service and 
    all releases occur at its end - just before program termination. 
    By the way, releasing all resources related to a variable can also be done manually 
    with <code class="language-smolambda">@release var</code>. In this case, <i>smoÎ»</i> will complain if you try
    to use/leak a resource later.
  </p>
  <p>
    Something important to consider is <b>what happens to returned data</b>. In those cases, we just 
    delay the freeing of resources until a point where they are not used anymore - as if they
    were allocated by the calling service. The mechanism for doing so consists of detecting resource
    frees at compile time and delegating them to the caller service. 
  </p>
  <p><b>Declaring freeing code -</b> <i>SmoÎ»</i> aims to automate resource allocation and deallocation
    for higher level data types. Still ,you might be curious what interfaces the language provides
    to allow the addition of new resource type. The way to transfer freeing code is by attaching it to 
    underlying variables and moving it alongside those variables' values during compilation. I repeat: 
    we track VALUES during compilation, not variables. Because we need to reason about memory.
  <p>
  </p>
    Below is an example of how free declarations look in practice. The code is a bit of a mess
    because it interweaves raw C. Any data that stores
    <code>mem</code>'s value retains a link to the freeing code, and there is an additional dependency
    exploration during returns to have only one of those (either <code>mem</code> or -preferred if it exists- a 
    returned value) own the freeing code. Note that <code class="language-smolambda">@unsafe</code> is needed
    to convey to the author of this file -me- is who you should be trusting. 
    Now, I would not trust me too much, but this is another story...
  </p>
  

  <div style="position: relative; margin-bottom: 2em;">
<pre><code class="language-smolambda">// From std/mem/device.s, comments only here.

// File-level @about is needed whenever @unsafe 
// is declared to get a sense of why one could 
// trust this unsafe file. The compiler can  
// summarize these sources of presumed trust.
@unsafe
@about "Standard library implementation of memory management ..."

smo allocate(Heap, u64 size, Primitive)
    // Usually optimized away if, for example
    // one called Heap:allocate(1024, char)
    if size==0 
        -> fail("Cannot allocate zero size")

    // C header
    @head{#include &lt;stdlib.h>}

    // A hack to declare a local variable wth the 
    // appropriate builtin type (among char,f64,u64,
    // i64) that the C code in @body below can see.
    // Optimized away.
    Primitive = Primitive 

    // Direct C code here.
    @body{ptr mem=__runtime_alloc(size*sizeof(Primitive));} // malloc usually

    // Allocation safety - just fail services whenever.
    if mem:bool:not 
        -> fail("Failed a Heap allocation")

    // Attach freeing C code to the mem ptr address.
    // That is is managed by the compiler.
    @finally mem { 
        if(mem)
            __runtime_free(mem); // free usually
        mem=0;
    }
    -> nominal:ContiguousMemory(
        Heap, // track type as zero-valued object (optmized away later)
        size, // size of region within underlying memory
        Primitive, // track type as zero-valued object (optmized away later)
        mem,  // region start within underlying memory
        mem   // underlying memory
    )
</code></pre>
  </div>
  <p>
    Notice that there is a ton of information injected with the indent of tracking it during compilation but
    to be optimized away later. The resulting code may end up being an <code>malloc</code>, allocation test,
    and eventual <code>free</code>. But the richness of all intermediate information lets us do nice things
    during compilation, such as track where the memory should be released and the primitive alignment (64-bit 
    for numbers or 8-bit for char primitives).
  </p>

  <p><b>Practical example -</b> Before moving on to seeing memory implementations in action, 
    look at the language's built-in buffer 
    system, indicated by <code class="language-smolambda">[]</code>. Default buffers reside on the 
    heap to account for their dynamic nature, though this can be adjusted for systems with unavailable heaps.
    Fast implementations from the standard library for strings and vectors use other memory constructs 
    described next.
  </p>

  <div style="position: relative; margin-bottom: 2em;">
<pre><code class="language-smolambda">@include std.builtins // basic arithmetics, etc

service samples()
    buf = u64[]
    :push(42)
    :push(10)
    -> buf // return statement

service main()
    buf = samples()
    print(buf[0]) // prints 42
    -- // end block, buffer is deallocated here
</code></pre>
  </div>

  <div id="example-block" style="display: none;">
    This snippet shows how arenas scope memory allocation:
    <ul>
      <li><code class="language-smolambda">on arena</code> introduces a region where memory
      is borrowed from the arena.</li>
      <li>When the block ends, resources are automatically released.</li>
      <li>If a <code class="language-smolambda">smo</code> fails inside, the arena cleans up safely.</li>
    </ul>
  </div>

  <h2 id="why-arenas">Why Arenas?<a class="anchor-link" href="#why-arenas">#</a></h2>
  <p>
    Arenas are predictable, fast, and avoid fragmentation. Unlike garbage collection,
    they donâ€™t defer cleanup â€” all allocations tied to the arena vanish at once
    when its scope ends.
  </p>

  <h2 id="failsafe-services">Failsafe Services<a class="anchor-link" href="#failsafe-services">#</a></h2>
  <p>
    Combining arenas with <code class="language-smolambda">service</code> functions ensures
    that even in failure scenarios, resources are handled gracefully. This creates
    a <strong>failsafe execution model</strong>.
  </p>

  <h3 id="example-service">Example Service<a class="anchor-link" href="#example-service">#</a></h3>
<pre><code class="language-smolambda">service main()
    &arena = Stack:arena(8192)
    demo_arena()
    print("Finished safely")
    --
</code></pre>

  <p>
    Here, <code>main</code> calls <code>demo_arena</code> with its own scoped arena.
    Even if something fails inside, <code>service</code> ensures cleanup.
  </p>

  <hr>

  <p><em>This post is part of the smoÎ» language's material. For more resources, check out these links:</em></p>

<div style="display: flex; gap: 12px; margin-top: 10px;">
  <a href="../index.html" class="navbar-link">
    <img src="../smol.png" alt="home" style="width: 24px; height: 24px;">
    Home
  </a>
  <a href="https://github.com/maniospas/smol" target="_blank" class="navbar-link">
    <img src="../github.png" alt="github" style="width: 24px; height: 24px;">
    GitHub
  </a>
</div>

<style>
  .navbar-link {
    color: #177042;
    text-decoration: none;
    font-weight: bold;
    font-size: 1em;
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 4px 10px;
    border-radius: 18px;
    transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
  }
  .navbar-link:hover {
    box-shadow: 0 6px 14px rgba(0, 0, 0, 0.15);
    transform: translateY(-1px);
    background: #eefdf7;
  }
  .navbar-link img {
    transition: transform 0.2s ease;
  }
  .navbar-link:hover img {
    transform: scale(1.15);
  }
</style>

</div>

<script src="../vendor/prism/prism.min.js"></script>
<script>
Prism.languages.smolambda = {
  'comment': /\/\/.*/,
  'directive': {
    pattern: /@\w+/,
    alias: 'important'
  },
  'keyword': [
    {
      pattern: /\b(?:smo|service|if|else|elif|with|include|on|while|union|to|upto|lento|len|and|or)\b/,
      greedy: true
    },
    {
      pattern: /(?:\|\|\|->|\|\|->|\|\|--|\|->|\|--|->|--|:|=)/,
      greedy: true
    }
  ],
  'special-amp': {
    pattern: /&/,
    alias: 'operator' // optional, gives Prismâ€™s operator style too
  },
  'builtin': /\b(?:i64|u64|f64|ptr|cstr|nstr|str|buffer|main|copy|bool|not|cos|sin|tan|acos|asin|atan|pi|exp|log|pow|sqrt|add|mul|sub|div|nominal)\b/,
  'punctuation': /[{}();,\[\]]/,
  'number': /\b\d+\b/,
  'string': {
    pattern: /"(?:\\.|[^"\\])*"/,
    greedy: true
  }
};
</script>
<script>
  document.querySelectorAll('a.anchor-link').forEach(a =>
    a.addEventListener('click', e => {
      if (location.hash === a.getAttribute('href')) e.preventDefault()
    })
  )
</script>



</body>
</html>
