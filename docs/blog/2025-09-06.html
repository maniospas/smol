<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Exploring how smoλ handles memory safety with arenas and failsafe services.">
  <meta name="keywords" content="smolambda, smoλ, programming language, memory safety, arenas, services, systems programming">
  <meta name="author" content="Emmanouil (Manios) Krasanakis">
  <meta name="robots" content="index, follow">
  <link rel="icon" href="smol.png" type="image/x-icon">

  <title>smoλ blog – Memory safety via delayed freeing</title>
  <link href="../vendor/prism/prism.min.css" rel="stylesheet" />
  <style>
    html {scroll-behavior: smooth;}
    h1 {scroll-margin-top: 60px;}
    h2 {scroll-margin-top: 60px;}
    h3 {scroll-margin-top: 60px;}
    h1[id], h2[id], h3[id] { position: relative; }
    .anchor-link {text-decoration: none;font-size: 0.9em;margin-left: 8px;opacity: 0;transition: opacity 0.2s;}
    h1:hover .anchor-link,
    h2:hover .anchor-link,
    h3:hover .anchor-link { opacity: 1; }
    body {font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;margin: 0;background-color: #f9f9f9;color: #333;line-height: 1.7;}
    .navbar {background-color: #333;padding: 2px;position: sticky;top: 0;z-index: 1000;display: flex;flex-wrap: wrap;justify-content: center;}
    .navbar a {color: white;text-decoration: none;padding: 5px 10px;font-weight: bold;}
    .container {max-width: 800px;margin: 20px auto;padding: 0 20px;}
    h1, h2, h3 {color: #222;}
    table {width: 100%;border-collapse: collapse;margin-bottom: 2em;background-color: white;}
    th, td {border: 1px solid #ccc;padding: 10px;text-align: left;vertical-align: top;}
    th {background-color: #eee;}
    code {background: #eee;padding: 2px 0px;border-radius: 4px;font-family: 'Courier New', Courier, monospace;font-size: 95%;}
    pre {padding: 15px;border-radius: 8px;overflow-x: auto;font-size: 90%;margin-bottom: 2em;}
    pre code {background: none;font-family: 'Courier New', Courier, monospace;font-size: 90%;}
    p strong {color: #444;}
    .token.special-amp {color: red;font-weight: bold; }
    .section-header {background-color: #eeb;font-weight: bold;color: #000;}
    .info-box {display: flex;align-items: center;gap: 15px; background: #fffbf0; box-shadow: 0 4px 14px rgba(0, 0, 0, 0.1);  border-radius: 12px;  padding: 20px;  margin: 20px 0;  transition: transform 0.2s ease, box-shadow 0.2s ease;  text-decoration: none;  color: inherit; }
    .info-box:hover {transform: translateY(-5px);box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);}
    .info-box img {width: 48px;height: 48px;}
    .info-box h2 {margin: 0 0 4px;font-size: 1.4em;}
    .info-box div {font-size: 1em;color: #333;}
    .info-box-text {display: flex; flex-direction: column;}
    .explain-button { position: absolute;  bottom: 10px; right: 10px;  padding: 6px 12px; font-size: 0.9em;  background-color: #ffffff; color: #333; border: 1px solid #aaa; border-radius: 6px; cursor: pointer; transition:  background-color 0.3s ease,  color 0.3s ease,  box-shadow 0.3s ease,  transform 0.2s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
    .explain-button:hover {background-color: #aafbf0;color: #333;box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); transform: translateY(-2px); border-radius: 30px;}
    .post-meta {font-size: 0.9em; color: #777; margin-bottom: 2em;}
  </style>
</head>
<body>

<div class="container">

  <div>
    <span id="post-title" style="font-size: 2.4em; font-weight: bold;">Memory safety via delayed freeing</span><br>
    <div class="post-meta">by Emmanouil (Manios) Krasanakis – September 6, 2025 - Programming languages, safety, delayed free</div>
  </div>

  <p>This post is Part I of a series on how <i>smoλ</i> handles resources. And I can already hear you sighing.</p>

  <p>
    <i>"Yet another take on memory safety. Aren't there enough out there?"</i>
  </p>
  <p>If you are
    a little bit familiar with programming language design, this is a probable first reaction. 
    And, honestly, you would be right. But 
    I believe there is a useful insight or two here. Not to mention that snippets like the next one
    are not going to explain themselves within <i>smoλ's</i> standard library. 
    So I might as well give an explanation <i>somewhere</i>. 
  </p>


  <pre><code class="language-smolambda">// from std/mem.device.s
def ContiguousMemory (
    new type,
    u64 size,
    ptr mem,
    ptr underlying
)
    //@noassign
    @c_buffer mem size underlying
    return @args

// from std/mem/arena.s
def Arena(new, ContiguousMemory contents)
    length = 0 
    return @args, length</code></pre>

  <p>
    Don't feel guilty if your first reaction was to skip the above snippet.
    It's exactly what I would have done, too, because it makes little sense out-of-context.
    If you are more careful than me, you could also look more closely and decide that, 
    with bloated data structures like these to move around, who needs chromium in every app
    munching on our memory? - we are going to consume it all ourselves first! And, wait,
    did I not say something about safety? Where's that?
  </p>
  <p>
    I will address these concerns with a series of blog posts, starting from the 
    very basics of how one can have a safe memory release model in this one. I will cover 
    mutability and a fast memory system that can easily pivot between arenas
    and dynamic memory in next installments.
  </p>
  <p>
    In particular, here I will explain some of the zero-cost 
    design principles of <i>smoλ</i> that help delay resource cleanup until it's safe.
    Principles discussed apply to any 
    resource, such as several kinds of memory management and files. 
  </p>


  <h2 id="recap">Recap on language concepts<a class="anchor-link" href="#recap">#</a></h2>

  <p>
    <b>Types -</b> Before starting, a brief recap that <i>smoλ</i> is centered 
    around functions whose returned values serve
    as both tuples and type fields. For example, the following declares a new
    type, so that if you write <code class="language-smolambda">p=new:point2(x,y)</code> 
    you can access fields <code  class="language-smolambda">p.x</code> and <code  class="language-smolambda">p.y</code>.
  </p>

  <pre><code class="language-smolambda">def point2(new, f64 _x, f64 _y) 
    x = 2*_x 
    y = 2*_y 
    return x,y</code></pre>
  
  <p>
    <b>New types -</b> I shamelessly forced upon you a couple more concepts in the above explanation, 
    because they are pretty important. First is
    <code class="language-smolambda">new</code>, which is a value indicating a type
    matched to its name instead of structure (two <code class="language-smolambda">f64</code> values).
    The language's typing is static, so <code class="language-smolambda">new</code> indicators
    are checked during compilation but removed and do not affect execution.
  </p>
  <p>
    <b>Currying -</b> The language's currying symbol <code class="language-smolambda">.</code> 
    transfers the left-hand-sight as the first argument to the right. For example, 
    <code class="language-smolambda">obj.fun()</code> means <code class="language-smolambda">fun(obj)</code>
    and <code class="language-smolambda">obj.fun(arg1,arg2)</code> means <code class="language-smolambda">fun(obj,arg1,arg2)</code>,
    and so on.
  </p>
  
  <p>
    <b>Definitions vs services -</b> In general, there are two types of functions; <code class="language-smolambda">def</code> declarations,
    like above, or <code class="language-smolambda">service</code>s. The main difference is that the former are inlined,
    whereas services are implemented as co-routines and give the opportunity of error handling when errors occur inside - to be addressed in
    another post.
  </p>


  <h2 id="no-memory">Where memory is <i>not</i> used <a class="anchor-link" href="#no-memory">#</a></h2>
  <p>
    A nice feature of <i>smoλ</i> is that its default type instance manipulation mechanism does not use heap memory. Instead,
    registers and the stack store fields as local variables. For example, the previous <code class="language-smolambda">point2</code>
    type is simply stored into underlying variables <code class="language-smolambda">p__x.p__y</code>.
  </p>
  </p>
    Remember that def definitions are inlined, so we can have very complex data transfers be zero cost (or faster-than-zero-cost, depending
    on how you look at it) by performing variable substitution
    and elimination. Currently, the language transpiles to an unholy subset of C with <code class="language-smolambda">goto</code> as 
    its intermediate representation. Mostly because I am uncomfortable around the LLVM stack's bloat. So these variable
    optimizations are deliberately delegated to modern C compilers (by default: <i>gcc</i>), which are very adept at them. 
    What is C, after all, if not portable assembly? Jokes aside, LLVM is an engineering wonder and I am being stuborn here, but this
    would be the least of my moral failings.
  </p>
  <p>
    As an example, if the value <code class="language-smolambda">p.y</code> is never used, <code class="language-smolambda">p__y</code> 
    will be eliminated by the compilation process completely. Even if used elsewhere, inlining eventually means that we
    do not need to load <code class="language-smolambda">p.y</code> from memory if it is already in the cache. Of course,
    cache locality is still key, but the language enables allows more intensive usage.
  </p>
  <p>
    The end result: <b>we are free to keep "metadata" variables
    that help us track resource properties</b>, such as <code class="language-smolambda">ptr underlying</code> 
    to track the common allocated memory, and <code class="language-smolambda">u64 size</code> to track the current accessible size.
    The costs of those variables are either eliminated by removing dead computations or would have been payed either way. 
    For example, <code class="language-smolambda">z=point2(point2(x,y).x,y) print(z.x+z.y)</code> has the same compilation 
    outcome as the minimal required operations <code class="language-smolambda">print(2*2*x+2*y)</code>. 
  </p>
  <p>
    As a final note, optimizations do not occur for service arguments, since the latter are proper functions. But the cost there
    is negligible compared to co-routine switching (which is already reasonably lightweight but incures costs due to mutexes).
    Importantly, only one variable -typically of a pointer builtin type <code class="language-smolambda">ptr</code>- is sufficient
    to hold attached resources.</p>
  <p>For example, generic strings are declared as follows, where <code>memory</code> represents the memory resource
    they have been attached to, and <code>first</code> the first character to reduce cache misses when comparing strings by comparing
    that instead of the <code>contents</code>.
  </p>

  <div style="position: relative; margin-bottom: 2em;">
<pre><code class="language-smolambda">// from std/builtins/str.s

def str (
    new, 
    ptr contents, 
    u64 length, 
    char first, 
    ptr memory
)
    return @args
</code></pre>
  </div>

  <h2 id="release">Release timing <a class="anchor-link" href="#release">#</a></h2>
  <p>
    Concurrency aside, the main difference between <code class="language-smolambda">def</code>
    and <code class="language-smolambda">service</code> is that resources like memory are gathered
    by the compiler and safely released at the end of services that fail. If no errors occur, 
    resources are released -if not used anymore- at the exist point of functions. Those working in domains 
    where delays are critical are now aware of exactly when systems are going to do work. But we also
    have the benefit that, upon failures like invalid file reads, 
    we can safely terminate the service without leaking resources. 
    Error handling is also not for now, though.
  </p> 
  <p>
    In the simplest case, there would only be the <code class="language-smolambda">main</code> service and 
    all releases would occur at its end - just before program termination. 
    By the way, releasing all resources related to a variable can also be done manually 
    with <code class="language-smolambda">@release var</code>. In this case, <i>smoλ</i> will complain if you try
    to use/leak a resource later.
  </p>
  <p>
    Something important to consider is <b>what happens to returned data</b>. For those, we just 
    delay freeing until they are not used anymore - as if they
    were allocated by the calling service. The mechanism for doing so consists of detecting 
    resource frees at compile time and delegating them to the caller. In short: if A calls B, 
    the act of releasing resources on which B's return depends is delegated to A.
  </p>

  <p><b>Practical example -</b> Below is an example using the language's built-in buffer 
    system, where buffers are created by placing <code class="language-smolambda">[]</code> after a type. 
    Default buffers reside on the 
    heap to account for their dynamic nature, though this can be adjusted for systems with different memory models
    by adding new runtimes in the <i>std/runtimes/</i> folder.
    Fast implementations from the standard library for strings and vectors use other memory constructs 
    described next.
  </p>

  <div style="position: relative; margin-bottom: 2em;">
<pre><code class="language-smolambda">@include std.core // basic arithmetics, etc

service samples()
    buf = u64[]
    .push(42)
    .push(10)
    return buf // return statement

service main()
    buf = samples()
    print(buf[0]) // prints 42
    //buffer is deallocated at function end
</code></pre>
  </div>

  <p>
    <b>Formalism</b> - A particular family of programming fans 
    may be ready to point out that I follow linear logic for ownership (hello there, Rust enthusiasts!). 
    This is not entirely true, however, because I actually use linear time logic (LTL); the statement 
    I am making is that <i>"<b>eventually</b> allocated memory is deallocated and at the end of a services 
    after which it is not referenced anymore"</i>. 
    <i>Ahem!</i> Trying very hard to not spam notation here. 
    For reals. But I promise to release a white paper for this... <i>eventually.</i> 
    Just notice that the nature of this promise completely eliminates use-after-free.
    Though it obviously comes at the cost for keeping some memory alive for longer.
   </p>


  <p><b>Safe arenas -</b> The same principle is in action for other types of resources, such as arenas. 
    I am not going ito cover the memory model implemented by the 
    standard library in this post, so it suffices to know that arenas (per their common definition)
    are pre-allocated chunks of memory where new allocations are as simple as incrementing 
    pointers. The downside is that their size should be fixed beforehand.
  </p>
  <p>
    Without going into syntax details, in <i>smoλ</i> one can open an arena context
    per <code class="language-smolambda">on Heap:arena(size)</code>. Memory contexts
    like this essentially provide an allocation mechanism for string concatenations and vector numeric operators. 
    You can also replace the heap with <code>Stack</code> if you plan to remain within a service's call 
    stack. But the compiler will create an error if you would try to return stack memory from a service.
    Or you could use <code class="language-smolambda">on Heap:dynamic</code> to allow
    dynamic allocations that are all freed up together.
  </p>
  <p>
    The example below uses an arena for string concatenations. Do note that the language 
    has three types of strings: <code class="language-smolambda">cstr</code> corresponding to raw text enclosed in quotations, 
    like <code class="language-smolambda">"there"</code>,
    null terminated strings <code class="language-smolambda">nstr</code>, which are normally the outcome of concatenation, 
    and <code class="language-smolambda">str</code> that are either null-terminated or a zero-cost substring view. 
    Each of those types is convertible to subsequent ones through zero-cost 
    abstractions. The reason I am mentioning string types is to explain 
    why we need to explicitly convert <code class="language-smolambda">"there"</code>
    to <code class="language-smolambda">str</code> in the code.
  </p>

  <div style="position: relative; margin-bottom: 2em;">
<pre><code class="language-smolambda">@include std.core
@include std.mem

service greet(str name)
    @on Heap.allocate(1.KB()).arena()
    greeting = add(@all "Hi "name"!")
    return greeting

service main()
    greeting = "there".str().greet()
    print(greeting)
    //the returned arena is deallocated here
</code></pre>
  </div>

  <p>
    Type details out of the way, we allocated a disproportionately large arena for string concatenation. 
    Then, this arena's freeing operations are attached to its allocated pointer, with string results keeping track of it.
    Hence, when the <code>greeting</code> string is returned, it is also accompanied by the whole arena and its deallocated code.
    Of course "returning" the arena has no execution overhead other than moving its pointer value.
  </p>
  <p> 
    Automatic releases are similar to declaring destructors, but deallocation code is identified statically.
    Furthermore, despite the slightly bloated memory consumption in this case,
    speed gains from arenas (or fixed-size buffers) are what people often refer to when 
    they mention the term <i>"blazingly fast"</i>; you get the benefits of minimized memory fragmentation, 
    cache locality, and near-instantaneous allocation.
  </p>

  <h2 id="declare-release">Declaring releases <a class="anchor-link" href="#declare-release">#</a></h2>

  <p><i>Smoλ</i> aims to automate resource allocation and deallocation
    for higher level data types. Still, you might be curious what interfaces the language provides
    to allow the addition of new resource types. The way to transfer freeing code is by attaching it to 
    underlying variables and moving it alongside those variables' values during compilation. I repeat,
    because it is worth repeating: 
    we track memory VALUES during compilation, not variables. Because we need to reason about the status
    of memory contents.
  <p>
  </p>
    Below is an example of how resource acquisition looks like; this is how <code>Heap</code>
    memory can allocate a contiguous memory segment, for example to be used by arenas. Allocation
    code is different for different types of memory; for instance, arenas themselves implement
    <code>allocate</code> based on pointer additions.
  </p>
  <p>The code below is a bit of a mess
    because it interweaves raw C. Any data that stores
    <code>mem</code>'s value retains a link to the freeing code, and there is an additional dependency
    exploration during returns to have only one of those (either <code>mem</code> or -preferred if it exists- a 
    returned value) own the freeing code. Note that <code class="language-smolambda">@unsafe</code> is needed
    to convey to the author of this file -me- is who you should be trusting instead of the language. 
    Now, I would not trust me too much, but this is another story...
  </p>
  

  <div style="position: relative; margin-bottom: 2em;">
<pre><code class="language-smolambda">// From std/mem/device.s, comments only here.

// File-level @about is needed whenever @unsafe 
// is declared to get a sense of why one could 
// trust this unsafe file. The compiler can  
// summarize these sources of presumed trust.
@unsafe
@about "Standard library implementation of memory management ..."

def allocate(Heap, u64 size, Primitive)
    // Usually optimized away if, for example
    // one called Heap:allocate(1024, char)
    if size==0 
        fail("Cannot allocate zero size")

    // C header
    @c_head{#include &lt;stdlib.h>}

    // A hack to declare a local variable with the 
    // appropriate builtin type (among char,f64,u64,
    // i64) that the C code in @c_body below can see.
    // Optimized away.
    Primitive = Primitive 

    // Direct C code here.
    @c_body{ptr mem=__runtime_alloc(size*sizeof(Primitive));} // malloc usually

    // Allocation safety - just fail services whenever.
    if mem.bool().not() 
        fail("Failed a Heap allocation")

    // Attach freeing C code to the mem ptr address.
    // That is managed by the compiler and is curated to run correctly
    // even if the code above fails triggering the release (unitilized
    // variables are always set to zero).
    @c_finally mem { 
        if(mem)
            __runtime_free(mem); // free usually
        mem=0;
    }
    -> new.ContiguousMemory(
        Heap, // track type as zero-valued object (optimized away later)
        size, // size of region within underlying memory
        Primitive, // track type as zero-valued object (optimized away later)
        mem,  // region start within underlying memory
        mem   // underlying memory
    )
</code></pre>
  </div>
  <p>
    Notice that there is a ton of information injected with the indent of tracking it during compilation but
    to be optimized away later. The resulting code may end up being an <code>malloc</code>, allocation test,
    and eventual <code>free</code>. But the richness of all intermediate information lets us do nice things
    during compilation, such as track where the memory should be released and the primitive alignment (64-bit 
    for numbers or 8-bit for char primitives).
  </p>




  <hr>

  <p><em>This post is part of the smoλ language's material. For more resources, check out these links:</em></p>

<div style="display: flex; gap: 12px; margin-top: 10px;">
  <a href="../index.html" class="navbar-link">
    <img src="../smol.png" alt="home" style="width: 24px; height: 24px;">
    Home
  </a>
  <a href="https://github.com/maniospas/smol" target="_blank" class="navbar-link">
    <img src="../github.png" alt="github" style="width: 24px; height: 24px;">
    GitHub
  </a>
</div>

<style>
  .navbar-link{color: #177042;text-decoration: none;font-weight: bold;font-size: 1em;display: flex;align-items: center;gap: 6px;padding: 4px 8px;border-radius: 20px;transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;}
  .navbar-link:hover {box-shadow: 0 6px 14px rgba(0, 0, 0, 0.15);background: #e9eed8;border: 1px solid #444}
  .navbar-link img {
    transition: transform 0.2s ease;
  }
  .navbar-link:hover img {
    transform: scale(1.15);
  }
</style>

</div>

<script src="../vendor/prism/prism.min.js"></script>
<script>
Prism.languages.smolambda = {
  'comment': /\/\/.*/,
  'directive': {
    pattern: /@\w+/,
    alias: 'important'
  },
  'keyword': [
    {
      pattern: /\b(?:smo|service|if|else|elif|with|case|qed|include|on|while|union|to|upto|lento|len|and|or)\b/,
      greedy: true
    },
    {
      pattern: /(?:\|\|\|->|\|\|->|\|\|--|\|->|\|--|->|--|:|=)/,
      greedy: true
    }
  ],
  'special-amp': {
    pattern: /&/,
    alias: 'operator' // optional, gives Prism’s operator style too
  },
  'builtin': /\b(?:i64|u64|f64|ptr|cstr|nstr|str|buffer|main|copy|bool|not|cos|sin|tan|acos|asin|atan|pi|exp|log|pow|sqrt|add|mul|sub|div|new)\b/,
  'punctuation': /[{}();,\[\]]/,
  'number': /\b\d+\b/,
  'string': {
    pattern: /"(?:\\.|[^"\\])*"/,
    greedy: true
  }
};
</script>
<script>
  document.querySelectorAll('a.anchor-link').forEach(a =>
    a.addEventListener('click', e => {
      if(location.hash === a.getAttribute('href')) e.preventDefault()
    })
  )
</script>



</body>
</html>
