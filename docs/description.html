<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="SmoŒª is a low-level language with fast zero-cost abstractions that are organized into failsafe services.">
  <meta name="keywords" content="smolambda, low-level language, smoŒª, programming language, runtype, safe language, systems programming, DSL">
  <meta name="author" content="Emmanouil (Manios) Krasanakis">
  <meta name="robots" content="index, follow">
  <link rel="icon" href="smol.png" type="image/x-icon">


  <title>smoŒª</title>
  <link href="vendor/prism/prism.min.css" rel="stylesheet" />
  <style>
    html {scroll-behavior: smooth;}
    h1 {scroll-margin-top: 60px;}
    h2 {scroll-margin-top: 60px;}
    h3 {scroll-margin-top: 60px;}
    h1[id], h2[id], h3[id] { position: relative; }
    .anchor-link {text-decoration: none;font-size: 0.9em;margin-left: 8px;opacity: 0;transition: opacity 0.2s;}
    h1:hover .anchor-link,
    h2:hover .anchor-link,
    h3:hover .anchor-link { opacity: 1; }
    body {font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;margin: 0;background-color: #f9f9f9;color: #333;line-height: 1.7;}

    /* Tighter navbar */
    .navbar {
      background: #fffbf0;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
      padding: 2px 8px;
      position: sticky;
      top: 0;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      height: 48px; /* fixed tighter height */
    }
    .navbar a {
      color: #177042; /* green text */
      text-decoration: none;
      font-weight: bold;
      font-size: 1em;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 3px 8px;
      border-radius: 18px;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }
    .navbar a:hover {box-shadow: 0 6px 14px rgba(0, 0, 0, 0.15);transform: translateY(-1px);background: #e9eed8;border: 1px solid #444}
    .navbar a img {
      width: 28px;
      height: 28px;
      flex-shrink: 0;
      transition: transform 0.2s ease;
    }
    .navbar a:hover img {
      transform: scale(1.15);
    }

    .container {max-width: 800px;margin: 40px auto;padding: 0 20px;}
    h1, h2, h3 {color: #222;}
    table {width: 100%;border-collapse: collapse;margin-bottom: 2em;background-color: white;}
    th, td {border: 1px solid #ccc;padding: 10px;text-align: left;vertical-align: top;}
    th {background-color: #eee;}
    code {background: #eee;padding: 2px 0px;border-radius: 4px;font-family: 'Courier New', Courier, monospace;font-size: 1em;}
    pre {background: #272822;padding: 15px;border-radius: 8px;overflow-x: auto;font-size: 1em;margin-bottom: 2em;}
    pre code {background: none;font-family: 'Courier New', Courier, monospace;font-size: 1em;}
    p strong {color: #444;}
    .section-header {background-color: #eeb;font-weight: bold;color: #000;}
    .sidebar {  position: fixed;  top: 0;  left: calc(50% - 800px/2 - 260px);  height: 100%;  overflow-y: auto;  padding: 1em;  border-right: 10px solid #fdfaf9;   width: 200px;   margin-top: 50px; }
    .sidebar a {   text-decoration: none; color: #333;}
    .sidebar-title {  font-weight: none;  user-select: none; }
    .sidebar-name { font-weight: bold; user-select: none;  color: #73181d; }
    .token.special-amp {color: red;font-weight: bold; }
    .sidebar-sub { 
      font-size: 0.9em;
      margin-left: 1em;
    }
    .sidebar-sub a:hover {
      color: #177042;
      transform: scale(1.05);          /* visually enlarges the text */
      display: inline-block;          /* required so transform works properly */
      transition: transform 0.2s ease, color 0.2s ease; /* smooth animation */
    }


    @media (max-width: 768px) {
      .sidebar {transform: translateX(-100%); }
      .sidebar.open {transform: translateX(0);}
      .sidebar-toggle {display: block;}
      .container {margin-left: 0 !important;}
    }
</style>
</head>
<body>

<div class="navbar">
  <a href="index.html"><img src="smol.png" alt="home">Home</a>
  <a href="https://github.com/maniospas/smol" target="_blank"><img src="github.png" alt="github">GitHub</a>
</div>


<!-- <div class="sidebar">
  <a href="#quickstart">Quickstart</a><br>
  <a href="#flow">Flow</a><br>
  <a href="#smo">Runtypes</a><br>
  <a href="#service">Services</a><br>
  <a href="#buffers">Buffers</a> <br>
  <a href="#std">Std & memory</a>
  </ul>
</div> -->
<div class="sidebar">
  <div class="sidebar-section">
    <div class="sidebar-title"><span class="sidebar-name">Quickstart</span></div>
    <div class="sidebar-sub">
      <a href="#quickstart">About</a><br>
      <a href="#setup">Setup</a><br>
      <a href="#interesting">Basic structure</a><br>
      <a href="#cheatsheet">Cheatsheet</a>
    </div>
  </div>

  <div class="sidebar-section">
    <div class="sidebar-title"><span class="sidebar-name">Control flow</span></div>
    <div class="sidebar-sub">
      <a href="#flow">Conditions</a><br>
      <a href="#loops">Loops</a><br>
      <a href="#next">@next</a><br>
      <a href="#uplifting">Uplifting</a><br>
    </div>
  </div>

  <div class="sidebar-section">
    <div class="sidebar-title"><span class="sidebar-name">Runtypes</span></div>
    <div class="sidebar-sub">
      <a href="#smo">Type+function</a><br>
      <a href="#primitives">Primitives</a><br>
      <a href="#returns">Return</a><br>
      <a href="#mutability">Mutability</a><br>
      <a href="#currying">Currying</a><br>
    </div>
  </div>

  <div class="sidebar-section">
    <div class="sidebar-title"><span class="sidebar-name">Type system</span></div>
    <div class="sidebar-sub">
      <a href="#typesystem">Overloading</a><br>
      <a href="#callbytype">Call by type</a><br>
      <a href="#unions">Unions</a><br>
      <a href="#nominal">Nominal typing</a>
      <a href="#typechecking">Typechecking</a>
    </div>
  </div>

  <div class="sidebar-section">
    <div class="sidebar-title"><span class="sidebar-name">Services</span></div>
    <div class="sidebar-sub">
      <a href="#service">Why services?</a><br>
      <a href="#errors">Error handling</a>
    </div>
  </div>

  <div class="sidebar-section">
    <div class="sidebar-title"><span class="sidebar-name">Std</span></div>
    <div class="sidebar-sub">
      <a href="#std">Beyond the core</a><br>
      <a href="#memory">Memory</a><br>
      <a href="#console">Console</a><br>
      <a href="#strings">Strings</a><br>
      <a href="#files">Files</a><br>
      <a href="#vectors">Vectors</a><br>
      <a href="#math">Math</a>
    </div>
  </div>
</div>




<div class="container">

<h1 id="quickstart">Quickstart <a href="#quickstart" class="anchor-link">üîó</a></h1>

<h3 id="about">About <a href="#about" class="anchor-link">üîó</a></h3>

<p><i>SmoŒª</i> (pronounced like "small" but with "o" instead of "a") is a low-level language with fast zero-cost abstractions that are organized 
into failsafe services. Its core is tiny ‚Äî really tiny! So tiny, in fact, that printing and basic
arithmetics are externally implemented in the standard library with a C/C++ interface.
Follow on <a href="https://github.com/maniospas/smol" target="_blank" title="repository">GitHub</a> to track progress.</p>


<p>Overall, there are two main constructs: </p>
<ul>
<li><code class="language-smolambda">def</code> - functions whose returned values are treated as named tuples (types).</li>
<li><code class="language-smolambda">service</code> - executed in parallel and handle internal failures gracefully.</li>
</ul>
<p></p>Use runtypes for speedy intermediate operations and the latter for error handling over large chunks of business logic.
</p><p>
The type system is algebraic with overloads, unions, and basic type inference - just enough to keep
code simple without hiding behavior. All code is fastly executed on the stack, but there are heap buffers to handle 
variadic data or exchange data between services.</p>


<h3 id="setup">Setup <a href="#setup" class="anchor-link">üîó</a></h3>

<p>Download <i>smoŒª</i> from its <a href="https://github.com/maniospas/smol/releases/latest">latest release</a>
or build it from source by cloning the repository and running <code class="bash">g++ src/smolang.cpp -o smol -O2 -std=c++23</code>.
The language is so lightweight that there is no need for a build system and its main executable consumes less than 300kB
... plus a GCC distribution if you want more optimizations. Make sure that the <i>smol</i> executable and GCC is in your system path.
Alternatively, add <code>--back tcc</code> to use <a href="https://www.bellard.org/tcc/">tiny C</a> or another lightweight compiler
as a backend. If you weave in raw C++ code instead of simple C, you can also use a compiler for that language.
</p>

<p>
A language server is provided as a VSCode extension named <i>smoŒª (smolambda)</i>;
search for <i>smolambda</i> in the extensions tab, or get the extension from 
<a href="https://marketplace.visualstudio.com/items?itemName=maniospas.smolambda">here</a>.
The language server offers tooltips, error traces, and jumping to definitions.</p>

<h3 id="interesting">Basic structure <a href="#interesting" class="anchor-link">üîó</a></h3>
<p>Look at an example of how <i>smoŒª</i> manages data structures:</p>

<pre><code class="language-smolambda">@include std.core

def Point(f64 x, f64 y) 
    return @args

def Field(nominal, Point start, Point end) 
    return @args

service main()
    // raw numbers you write are either 
    // f64 (floats) or u64 (unsigned ints)
    p = Point(3.0,5.0)
    f = nominal.Field(1.0,2.0,p)
    print(f.start.x + f.end.y) // 6
    end
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
6
</pre>

<p>First, <code class="language-smolambda">@include</code> brings code from
other files with the <i>.s</i> extension. Paths are separated by dots.
Here we include some basic operations from the <a href="#std">standard library</a> that we
are going to use, mainly arithmetic operations and printing. 
Nothing exciting yet. If, for example, you needed to bring only numbers and
associated operations, 
you could write <code class="language-smolambda">@include std.core return Number</code>.
</p>

<p>Next are some functions declared with the <code class="language-smolambda">def</code>
keyword. The outcomes of functions obtained from <code class="language-smolambda">return</code> 
are either single values or named tuples, 
where. If named variables are part of the returned tuple, they can be accessed as fields
from the result.zis a shorthand for
packing all arguments, and is useful for declaring structural data structures without functionality - though
those data may make runtime assertions.</p>

<p>In general, runtypes are structural in that they are identified by their primitive
layout. For example, <code class="language-smolambda">Point2D</code> is recognized at any place
where two <code class="language-smolambda">f64</code> values exist. You
can switch to nomal typing that ensures only a type-resolved version is applied by accepting and returning a
<code class="language-smolambda">nominal</code> first argument. This is a primitive that is removed during
compilation, but is needed in calls later on. The currying notation 
<code class="language-smolambda">:</code> passes a left-hand-side
value as the first argument of a runtype; <code class="language-smolambda">obj:method(args)</code> is
equivalent to <code class="language-smolambda">method(obj, args)</code>.</p>

<p>Write something like <code class="language-smolambda">p = Point(...)</code> 
to access all returned named variables using notation like
<code class="language-smolambda">p.x</code> and <code class="language-smolambda">p.y</code>.
Unpack the result directly in other runtype calls, provided that primitive types match. All arguments are flat
-tuples are unwrapped to more elements- and can be reinterpreted in various ways
as long as primitive types match. Safety options for this are presented later.</p>

<p>Put all main business logic inside a <code class="language-smolambda">service main()</code> definition.
Services "catch" internal errors, safely handling allocation and deallocation.
They are also intrinsically parallel, can call each other, and handle returned errors. But more on them later.
For now, the main service is the program and the <code class="language-smolambda">--</code> symbol at its end indicates no returns.</p>


<h3 id="cheatsheet">Cheatsheet <a href="#cheatsheet" class="anchor-link">üîó</a></h3>

<p>Here is a summary of the language's core. More operations, including string and file system manipulation, are
available in the standard library.
</p>

<table>
  <thead>
    <tr>
      <th>Symbol</th>
      <th>Description</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr class="section-header"><td colspan="3"><u>Declarations</u></td></tr>
    <tr>
      <td><code class="language-smolambda">smo</code></td>
      <td>Runtype definition</td>
      <td>Defines an inlined type-function hybrid</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">service</code></td>
      <td>Service definition</td>
      <td>Parallel, safe, error-capturing function</td>
    </tr>
    <tr>
        <td><code class="language-smolambda">union</code></td>
        <td>Type alternatives</td>
        <td>Enables compile-time type matching</td>
    </tr>
    <tr>
        <td><code class="language-smolambda">Type(values)</code></td>
        <td>Call/cast</td>
        <td>Values expand into primitives</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@include lib</code></td>
      <td>Import external file</td>
      <td>Dot-path notation used for `.s` files</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@release var</code></td>
      <td>Release all resources</td>
      <td>Invalidates any variables using those</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">.</code></td>
      <td>Field access or currying</td>
      <td>For named returns of runtypes</td>
    </tr>
    <tr class="section-header"><td colspan="3"><u>Returns</u></td></tr>
    <tr>
      <td><code class="language-smolambda">return</code></td>
      <td>Return value(s)</td>
      <td>Used to return from runtype or service</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">end</code></td>
      <td>Return with no value</td>
      <td>No return value, is an explicit terminator</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">|end</code></td>
      <td>Uplift one level</td>
      <td>Break from a loop or if-block</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">|return</code></td>
      <td>Uplift return one level</td>
      <td>Break from nested blocks</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">||return</code></td>
      <td>Uplift return two levels</td>
      <td>E.g., escape loops from inside conditions</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@args</code></td>
      <td>Return all inputs</td>
      <td>Prioritized on runtype conflicts</td>
    </tr>
    <tr>
        <td><code class="language-smolambda">value.err</code></td>
        <td>Check if service failed</td>
        <td>Omitted in tuple unpack</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@mut</code></td>
      <td>Allow mutation</td>
      <td>Placed before variable declaration</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@access</code></td>
      <td>Access mutable fields</td>
      <td>Those fields are hidden otherwise</td>
    </tr>
    <tr class="section-header"><td colspan="3"><u>Control flow</u></td></tr>
    <tr>
      <td><code class="language-smolambda">if</code></td>
      <td>Condition</td>
      <td>Can be used with <code class="language-smolambda">else</code>, can yield value</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">else</code></td>
      <td>Alternative</td>
      <td>Matches conditions</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">elif</code></td>
      <td>Alternate condition</td>
      <td>Shorthand for <code class="language-smolambda">else->if</code></td>
    </tr>
    <tr>
      <td><code class="language-smolambda">while</code></td>
      <td>Loop</td>
      <td>Can yield a value from internal returns</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">with</code></td>
      <td>Type conditioning</td>
      <td>Needs <code class="language-smolambda">else</code>, runs first compilable branch</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">fail(str message)</code></td>
      <td>Manual error trigger</td>
      <td>Causes service to fail and propagate error</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@next</code></td>
      <td>Deferred assignment</td>
      <td>Evaluated now, assigned at end of block</td>
    </tr>
    <tr class="section-header"><td colspan="3"><u>Primitives</u></td></tr>
    <tr>
      <td><code class="language-smolambda">nominal</code></td>
      <td>Nominal type checking</td>
      <td>Automatic unique value in arguments</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">i64, u64, f64, bool</code></td>
      <td>Builtin runtypes</td>
      <td>Can be called to convert to each other</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">[start to end]</code></td>
      <td>Slicing (exclusive end)</td>
      <td>Returns a view of contents</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">[start upto end]</code></td>
      <td>Slicing with inclusive end</td>
      <td>Variant of range slicing</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">[start lento count]</code></td>
      <td>Slicing by length</td>
      <td>Number of elements instead of end</td>
    </tr>
    <tr class="section-header"><td colspan="3"><u>C/C++ Unsafe Injection</u></td></tr>
    <tr>
      <td><code class="language-smolambda">@unsafe</code></td>
      <td>Enable non-safety</td>
      <td>Place at the beginning of file</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@body{...}</code></td>
      <td>Inline C/C++ code</td>
      <td>Foreign implementation segment</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@head{...}</code></td>
      <td>Include C/C++ headers</td>
      <td>Prepended once per program</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@fail{...}</code></td>
      <td>C/C++ for error handling</td>
      <td>Prefer <code class="language-smolambda">fail(str message)</code></td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@finally{...}</code></td>
      <td>C/C++ to free resources</td>
      <td>Can also tie the resources to a variable</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@noshare</code></td>
      <td>Mark as unsafe to share</td>
      <td>Prevents sharing to other services</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@noassign</code></td>
      <td>Mark as unsafe to assign</td>
      <td>Makes each declaration unique</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@nozero</code></td>
      <td>Mark as unsafe to zero-initialize</td>
      <td>Makes all initializations of the result as explicit</td>
    </tr>
    <tr>
      <td><code class="language-smolambda">@noother</code></td>
      <td>Mark as unsafe to zero-initialize</td>
      <td>Makes all initializations of the result as explicit</td>
    </tr>
  </tbody>
</table>




<h1 id="flow">Control Flow <a href="#flow" class="anchor-link">üîó</a></h1>

<h3 id="conditions">Conditions <a href="#conditions" class="anchor-link">üîó</a></h3>

<p>
<i>smoŒª</i> offers <code class="language-smolambda">if</code>-statements and 
<code class="language-smolambda">while</code> loops to respectively execute code blocks conditionally
and repeatedly. These return values per <code class="language-smolambda">return value</code>
or return with no values per <code class="language-smolambda">--</code>. Return statements
designate the end of code blocks. Below is an example, where 
<code class="language-smolambda">@mut i=0</code> means that the value stored in 
<code class="language-smolambda">i</code> can be freely modfied in subsequent code.
</p>

<p>
Conditions must always evaluate to booleans, as there 
are no implicit casts.
The <code class="language-smolambda">else</code> branch is optional.
Similarly, adding parentheses may help clarity but is not 
required because the end of expressions is always unique.
</p>

<pre><code class="language-smolambda">@include std.core

service main()
    @mut i = 0
    while i&lt;10
        if 0==i%2 
            return print("Even "+i:str)
        else
            return print("Odd "+i:str)
        i = i+1
    end end // ends `while` then `main` 
</code></pre>

<p>All branches of <code class="language-smolambda">if</code> statements
must return either the same runtype or nothing. 
Below is an exampe that demonstrates chained if-else statements. 
Use <code class="language-smolambda">:i64</code>
to convert numbers to signed integers (recalled that unsigned integers are the default)
and use the floating point version of numbers in corresponding operations. For example, 
we use <code class="language-smolambda">0.0</code> below.
Different types of numbers can be converted to each other but are normally
not allowed to mingle for safety.</p>

<pre><code class="language-smolambda">@include std.core

service main()
    x = f64:read // more on this syntax later
    sgn = 
        if x>0.0
            return 1:i64
        else->if x==0.0
            return 0:i64
        else 
            return 0:i64-1:i64
    print(sgn)
    end
</code></pre>

<p>Equivalently, replace the pattern <code class="language-smolambda">else->if</code> with the <code class="language-smolambda">elif</code>
keyword, which is more ergonomic. Below is the same example rewritten more concisely.</p>

<pre><code class="language-smolambda">@include std.core

service main()
    x = f64:read
    sgn = 
        if x>0.0
            return 1:i64
        elif x==0.0 
            return 0:i64
        else
            return 0:i64-1:i64
    print(sgn)
    end
</code></pre>

<p>Finally, <i>smol</i> supports logical operators <code class="language-smolambda">and</code> and
<code class="language-smolambda">or</code> that are applied on boolean values. These operators are
defined as part of the language and apply only on <code class="language-smolambda">bool</code> inputs.
They further short-circuit logic expressions. That is, they do not compute redundant segments, as shown
below.</p>

<pre><code class="language-smolambda">@include std.core

def test() 
  print("called") 
  return true

service main()
    print("Normal conditions") // prints
    true and test() // prints
    false or test() // prints
    print("The rest are short-circuited away")
    false and test()
    true or test()
    end
</code></pre>


<h3 id="loops">Loops <a href="#loops" class="anchor-link">üîó</a></h3>

<p>Loops are similar to conditions with the difference being that they
keep repeating as long as their condition does not evaluate to <code>false</code>
<i>and</i> nothing is returned. See the uplifting operation below on
understanding values returned by loops.
</p>

<p>To better organize conditions or loops of only one statement,
return a parsed expression like the variation below. There, prints
do not return values and you would therefore get an error if
you tried to return a value in one of the branches. Syntax is equivalent
to printing and then ending code blocks with <code class="language-smolambda">--</code>. 
</p>

<pre><code class="language-smolambda">@include std.core

service main()
    @mut i = 0
    while i&lt;10
        if 0==i%2
            return print("Even "+i:str)
        else
            return print("Odd "+i:str)
        i = i+1
    end end
</code></pre>


<h3 id="next">@next <a href="#next" class="anchor-link">üîó</a></h3>

<p>
You may want to compute a value but assign it at the variable at the
end of the current control flow's body, for example to denote the next value
in a loop. This is achieved with the <code class="language-smolambda">@next</code> 
instruction. The <i>@</i> prefix indicates that the instruction might affect
your code non-locally. Below is an example of using this construct to write
loops, although we will later see a simpler notation.
</p>


<pre><code class="language-smolambda">@include std.core

service main()
    @mut i=0 
    while i&lt;10 
        @next i = i+1
        @mut j=0 
        while j&lt;10 
            @next j = j+1
            print(i:str+" "+j:str)
    end end end
</code></pre>


<p>‚ÑπÔ∏è <i>The standard library promotes an iteration-based style
based on <a href="#currying">currying</a> into loops. Prefer using that 
when writing finite loops, as it is more resistant against mistakes.
As a sneak peek, printing numbers <i>0,1,...,9</i> looks like this:
</i><br><br>
<pre><code class="language-smolambda">range(10)
.while next(@mut u64 i) 
    print(i)
    end
</code></pre>
</p>


<p>Aside from loops, the same mechanism is useful for scrambling values;
below  <code class="language-smolambda">if true</code> 
is used to isolate the next values and intercept the internal return.
</p>

<pre><code class="language-smolambda">@include std.core

service main()
    @mut i = 1
    @mut j = 2
    if true
        @next i = j
        @next j = i
        end
    print(j) // 1
    end
</code></pre>
    



<h3 id="uplifting">Uplifting (breaking with a return) <a href="#uplifting" class="anchor-link">üîó</a></h3>


<p>
There are no break and continue statements for loops because these can be emulated.
First, as a styling choice, do not indent conditions that run from a position until the end of the loop's
body but instead put the end condition's and loop's ending together. An example is shown below. 
</p>
<p>
The example also demonstrates how to break loops by returning multiple
steps back. This operation is called <i>uplifting</i> and its syntax 
is to prepend <code class="language-smolambda">|</code> to returns.
You can uplift several times to escape from nested control flow.
For example, <code class="language-smolambda">|--</code> breaks
from a condition within a loop and <code class="language-smolambda">||return</code>
can be used to return a value from a condition within a loop. Next is 
a simple example.
</p>


<pre><code class="language-smolambda">@include std.core

service main()
    @mut i = 511 
    while i&lt;10 
        @next i = i+1
        if i%7==0 
            |-- // break
        if i%2==0 
            return print(i)
    end end // ends `while`, then `main`
</code></pre>

<p>
Below is another example, in which uplifting returns even more steps back.
Note that print returns no value, which would only create an error if
one tried to assign the value returned by the top loop to a variable.
</p>


<pre><code class="language-smolambda">@include std.core

service main()
    @mut i=0 
    while i&lt;10 
        @next i = i+1
        @mut j=0 
        while j&lt;10 
            @next j = j+1
            print(i:str+" "+j:str)
            if 5==i+j 
                |||return print("done") 
    end end end
</code></pre>



<h1 id="smo">Runtypes <a href="#smo" class="anchor-link">üîó</a></h1>

<h3 id="merge">Type+function <a href="#merge" class="anchor-link">üîó</a></h3>

<p>Types and functions are the same thing in <i>smoŒª</i>
and marked as <code class="language-smolambda">smo</code> followed by a name
and a parenthesis with some arguments.
We call the merged concept <i>runtypes</i>.
As an example, look at a definition from the standard library,
which also gives a taste of the C++ ABI:</p>

<pre><code class="language-smolambda">def add(f64 x, f64 y)
    @body{f64 z=x+y;}
    return z
</code></pre>

<p>This tells us that we are defining an 64-bit floating number runtype with the corresponding arguments.
When called from other code, the definition is inlined in an optimization-friendly way. For example,
despite the illusion of typing, everything consists of direct variable operations; under the hood, field access like
<code class="language-smolambda">f.start.x</code> is replaced with variables like <code class="language-smolambda">f__start__x</code>.</p>

<p>Return a value or tuple of values with <code class="language-smolambda">-&gt;</code>,
and use <code class="language-smolambda">@body</code> to write C/C++ code. The interaction is described
later, but for now notice that a basic scan is also made to expose primitive types from inside the ABI.
</p>
<p>
If you don't want to return anything, use <code class="language-smolambda">--</code>.
Return symbols act as visual barriers that are easy to spot while remaining ... small.
Note that <i>smoŒª</i> does not require semicolons becase boundaries are unique:
everything ends at return statements, at the end of file, or resides in-between
parentheses and commas.</p>

<h3 id="primitives">Primitives <a href="#primitives" class="anchor-link">üîó</a></h3>
<p>
<i>smoŒª</i> has several primitive types for building more complicated runtypes. 
The standard library implements several operations for primitives. The ones built in the language are 
64-bit integers, their unsigned version, and floats. These are respectively denoted by
<code class="language-smolambda">i64</code>, <code class="language-smolambda">u64</code>, and <code class="language-smolambda">f64</code>.
The last one is equivalent to C/C++'s <code class="language-smolambda">double</code> numbers.</p>

<p>The language also offers a <code class="language-smolambda">ptr</code> type as a means to represent 64-bit address. 
In most situations you will not use addresses, but they are useful for interweaving more complicated C/C++ code in ways
that the compiler can understand (this requires <i>a lot</i> of casts, though you can pack complicated bits in <i>.cpp</i>
files if you want).
</p>

<p>For convenience, you can find the <code class="language-smolambda">char</code> and <code class="language-smolambda">bool</code> primitives, 
which are the C equivalents. The <code class="language-smolambda">errcode</code> builtin
captures the error values of failing services. nder the hood, it is implemented as a C/C++ int to remain compatible with the operating system.</p> 

<h3 id="returns">Return <a href="#returns" class="anchor-link">üîó</a></h3>

<p>Values returned from runtypes are always organized into tuples. However, you can access named fields of that
tuple, given that internal variables are returned. In previous examples, this means that we could access fields like
<i>x,y,start,end</i> given that they have been internally assigned to variables.
</p>

<p>Field access works a little differently when there is only one value returned: in this case,
you get direct access to that value, without of treating it as a field.
An example of this concept is presented below, where the overloaded <i>Point</i>
runtype with no arguments directly returns a version constructed with two arguments.</p>

<pre><code class="language-smolambda">@include std.core

def Point(f64 x, f64 y) 
    return @args

def Point() 
    start = Point(0.0, 0.0)
    return start // as a single argument it is directly unpacked

service main()
    s = Point()
    print(s.x) // not s.start.x
    end
</code></pre>


<p>The assignment operator copies the outcome of function calls. This is usually
a so-called "deep" copy, up to the point of data residing in pointers. 
However, only returned symbols can be accessed as fields.
For example, below the input variable <code class="language-smolambda">x</code>
cannot be accessed after computations conclude.
We already saw that it may be convenient to unpack all runtype inputs with
<code class="language-smolambda">@args</code> to directly declare a structural type
without internal implementation.
</p>

<pre><code class="language-smolambda">@include std.core

def multi_out(u64 x)
    xinc = add(x,1)
    return xinc, x

def single_out(u64 x)
    x = add(x,1)
    return x

service main()
    p1 = multi_out(1)
    print(p1.x)        // 1
    print(p1.incx)     // 2
    p2 = single_out(1)
    print(p2)          // 2
    print(p2.x)        // CREATES AN ERROR
    end
</code></pre>


<h3 id="mutability">Mutability (call by reference) <a href="#mutability" class="anchor-link">üîó</a></h3>

<p>Runtypes are called by value,
that is, without internal computations affecting external arguments. You can make
calls occur by reference by prepending
<code class="language-smolambda">@mut</code> to arguments in the signature. In this case,
internal modifications are retained. Below is an example.</p>

<pre><code class="language-smolambda">@include std.core

def inc(@mut u64 x)
    x = add(x,1)
    end

service main()
    @mut x = 1
    inc(x) // requires x to be mutable for modification by inc
    print(x) // 2
    end
</code></pre>

<p>Mutable fields can be mutated only if arguments are mutable too.
This way, mutations are explicit. Below is an example where, due
to structural typing of the first <code>Point p</code>, 
its mutable fields can be Passed as mutable arguments. The same
DOES hold true for the nominally typed <code>Point pt</code>.</p>

<pre><code class="language-smolambda">
@include std.core

def Point(f64 px, f64 py)
    @mut x = px
    @mut y = py
    return x,y

def Point(nominal type, f64 px, f64 py)
    @mut x = px
    @mut y = py
    return type, x,y

def scale(@mut Point p, f64 factor) 
    // @mut in the signature is required to allow any modification
    // this is an overloaded method for both Point implementations
    p.x = p.x*factor
    p.y = p.y*factor
    end

service main()
    p = Point(1.0,1.0)  
    p.x = p.x + 1.0
    p:scale(5.0)
    print(p.x) // 10

    tp = nominal.Point(1.0,1.0)
    tp:scale(5.0) // creates an ERROR
    end
</code></pre>

<p>‚ÑπÔ∏è <i>As a rule of thumb, allow maximal extensibility and safety by only adding <code>@mut</code> 
if the compiler complains about mutability.</i></p>

<p>
A special rule is that <code class="language-smolambda">ptr</code> primitives that are not
mutables cannot be assigned to fields of mutable variables. This allows treating pointers
as the representation of memory contents, where mutability means that memory contents also
donnot change. The next example shows how the commented out 
<code class="language-smolambda">@mut mutmap = map</code> is not allowed, and in turn this
prevents the modification of the immutable <code>map</code>'s entries.
</p>

<pre><code class="language-smolambda">
@include std.core
@include std.map

service map_printer(Map map)
    with 
        map.Keys:is(str) 
        map.Values:is(u64)
        end
    //@mut mutmap = map // ERROR - cannot transfer immutable pointers
    //mutmap:put("123", 2) 
    print(map["123"])
    end

service main() 
    on Heap:dynamic // automatically pass dynamic memory as first argument
        @mut map = map(100, str, u64) // flatmap with 100 slots
        end
    map:put("123", 1)
    map:map_printer
    end
</code></pre>



<h3 id="currying">Currying <a href="#currying" class="anchor-link">üîó</a></h3>
<p>Runtype calls accept currying notation that transfers a precomputed value to the first argument.
The curry operator is <code class="language-smolambda">:</code> and can be chained. Furthermore, you can omit
parentheses if there is only one argument and you curry it. Below is an example, where this notation is used to
have as little nesting as possible.
</p>

<pre><code class="language-smolambda">@include std.core

service main()
    1:add(2):mul(3):print
    // equivalent to print(mul(add(1,2), 3))
    end
</code></pre>

<p>In general, runtypes are all first-class citizens of the language in that they cannot be set as variables.
However, you can pass a known or type as an argument to denote dummy empty objects.
Currying lets <i>smoŒª</i> avoid methods as fields, as the notation <code class="language-smolambda">obj:runtype(args)</code>
is conceptually similar. Note that mutability should be explicitly declared if you want <code class="language-smolambda">rt</code>
to have side-effects.
</p>

<p>If currying is followed by <code>if</code> or <code>while</code> then the curried expression result is transferred to
the condition. This enables runtypes that serve as iterators by modifying an
iterated value by reference. Below is an example, where <code class="language-smolambda">@mut u64 i</code> 
declares a zero-initialized variable to hold the iteration state. For safety, this pattern is available
only if <code>i</code> has not been declared. The standard library provides a richer <code>range</code>
based on the same principles.
</p>


<pre><code class="language-smolambda">@include std.core

def custom_range(u64 start, u64 end) 
    @mut pos = start
    return pos, end

def next(@mut custom_range r, @mut u64 current) 
    current = r.pos 
    r.pos = r.pos + 1
    return r.pos &lt;= r.end

service main()
    custom_range(0,10)
    .while next(@mut u64 i) 
        print(i) 
    end end
</code></pre>



<h1 id="typesystem">Type system <a href="#typesystem" class="anchor-link">üîó</a></h1>


<h3 id="overloading">Overloading <a href="#overloading" class="anchor-link">üîó</a></h3>

<p>Overload runtypes that are structurally
different when converted to a flat representation of primitives 
(<code class="language-smolambda">i64</code>, <code class="language-smolambda">u64</code>, <code class="language-smolambda">f64</code>, etc).
Consider nominal types presented later as primitives. For now, you can see the automatic application of the appropriate runtype.
Do note that conflicting definitions will create errors.

<pre><code class="language-smolambda">@include std.core 

def point(f64 x, f64 y)
    return @args

def circle(point center, f64 r)
    return @args

def print(point p)
    printin("point (") // print without changing line
    printin(p.x)
    printin(",")
    printin(p.y)
    print(")")
    end

def print(circle c)
    printin("circle radious ")
    printin(c.r)
    printin(" centered at ")
    print(c.center)
    end

def add(point a, point b) 
    return point(a.x+b.x, a.y+b.y)

def add(circle a, circle b) 
    return circle(a.center, a.r+b.r)

service main()
    p1 = point(1.0, 2.0)
    p2 = point(3.0, 4.0)
    c1 = circle(p1, 10.0)
    c2 = circle(p2, 10.0)
    print(add(p1,p2))
    print(add(c1,c2))
    print(0.0, 0.0, 0.0) // understood as a circle
    end
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
point (4.000000,6.000000)
circle radious 20.000000 centered at point (1.000000,2.000000)
circle radious 0.000000 centered at point (0.000000,0.000000)
</pre>

<h3 id="callbytype">Call by type <a href="#callbytype" class="anchor-link">üîó</a></h3>

<p>
You might want to choose a runtype's version based on another without actually passing data. For example,
something different should be called based on the expected outcome. In those cases, you can add signature
variable that does not have a name. Similarly, pass the type of the variable as an argument.
</p>
<p>
Below is a segment of the standard library that demonstrates how the correct version of
an evoked method is applied. Runtypes without
parentheses refer to zeroed out input data.
You can also use a value as reference - that would be ignored.</p>

<pre><code class="language-smolambda">def not(bool x) 
    @body{bool z=!x;} 
    return z

def print(f64 message)
    @head{#include &lt;stdio.h>}
    @body{printf("%.6f\n", message);}
    end

def read(i64)
    @head{#include &lt;stdio.h>}
    @body{i64 number = 0; bool success = scanf("%ld", &number);}
    if success:not 
        @fail{printf("Invalid integer\n");}
        end
    return number

def read(f64)
    @head{#include &lt;stdio.h>}
    @body{f64 number = 0; bool success = scanf("%lf", &number);}
    if success:not 
        @fail{printf("Invalid number\n");}
        end
    return number

service main()
    x = f64:read // x = read(f64)
    print(x)
    end
</code></pre>


<h3 id="nominal">Nominal typing <a href="#nominal" class="anchor-link">üîó</a></h3>

<p>Often we want runtypes to enforce certain relations between their values that
are registered on the runtype name. This is achieved by setting the runtype by 
providing a <code class="language-smolambda">nominal</code> first argument and
ensuring that this is returned. The returned tuple adheres to the so-called 
<i>nominal typing</i>. Do note that
<code class="language-smolambda">nominal</code>values are zero-cost in that they
do not consume runtime resources; they just enforce type comparisons.
</p>
<p>
Compilation outcomes ignore <code class="language-smolambda">nominal</code> (e.g., it 
does not take up storage), as it is mostly used for disambiguating between strucurally 
equivalent runtypes.
</p>

<pre><code class="language-smolambda">@include std.core

def Type1(nominal, f64 value) 
    return @args
    
def Type2(nominal, f64 value) 
    return @args

def recognize(Type1 p) 
    print("this is Type1") 
    end

def recognize(Type2 p) 
    print("this is Type2") 
    end

service main()
    p1 = nominal.Type1(1.0)
    p2 = nominal.Type2(2.0)
    recognize(p1) 
    recognize(p2) 
    end
</code></pre>


<p>Till now we used <code class="language-smolambda">->@args</code> returns as a shorthand for returning
input values. However, this also helps disambiguate overloading when there is no clear resolution. 
In particular, if exactly one of the competing runtypes
has this kind of return declaration or argument, that is used as the choice that breaks the stalemate.
</p>

<p>For example, consider the following very simple program that reads from the console and manipulates strings
with a standard library implementation. The <code class="language-smolambda">str</code> runtype is overloaded
to allow various conversions to other primitives. However, we are still able to identify a specific variation, 
which in turn is used to identify and call <code class="language-smolambda">str:read</code>.</p>

<pre><code class="language-smolambda">@include std.core
@include std.mem

service main()
    print("What's your name?")
    name = str:read
    // volatile memory buffer to make string allocations for addition
    on Stack:volatile(1024)
        print("Hi "+name+"!")
    end end
</code></pre>

<h3 id="unions">Unions <a href="#unions" class="anchor-link">üîó</a></h3>
<p>Sometimes, you want to define code that is automatically adjusted to different runtypes.
This can be achieved by declaring runtype unions, which are resolved to one of their
options. The resolution persists to dependent calls, so create separate unions for independent resolution.
Unions are resolved during compilation and, like many features of <i>smoŒª</i>, are zero-cost
abstractions. They can also contain other unions or nominal types.</p>

<p>
For example, the <code class="language-smolambda">Type</code> union
below is determined to be <code class="language-smolambda">f64</code> while
calling <code class="language-smolambda">inc</code> to match the <code class="language-smolambda">Point</code>
argument and carries over to the internal
implementation. Therefore, the <code class="language-smolambda">f64</code> primitive is used for reading, constructing
a two-dimensional point, for casting the value of <i>1</i> to the appropriate type,
and calling the corresponding overloaded addition.
Unions account for overloads of their options up to the point
where they are defined.</p>

<pre><code class="language-smolambda">@include std.core

union Type
    i64 
    f64 
    u64
    end

def Point(@mut Type x, @mut Type y) 
    return @args

def inc(Point &p)
    p.x = p.x+Point.Type(1)
    p.y = p.y+Point.Type(1)
    end

service main()
    printin("Give a value: ")
    value = f64:read // f64 will trickle to Point and inc
    p = Point(value, value)
    p:inc()
    print(p.x)
    end
</code></pre>


<h3 id="nominal">Buffers <a href="#buffers" class="anchor-link">üîó</a></h3>

<p>All types admit a buffered variation that can hold an arbitrary number of copies.
Declare buffers by appending type names with <code class="language-smolambda">[]</code>.
The language accepts three special runtypes: <code class="language-smolambda">push</code>
to grow the buffer with an additional item at its end, 
<code class="language-smolambda">at</code> that is also used for bracket-based
indexing, and <code class="language-smolambda">len</code> to count the number of elements
in the buffer. Below is a simple example:
</p>

<pre><code class="language-smolambda">@include std.core
@include std.mem

service main()
    boxes = str[]
    :push("buffer start":str)
    :push("buffer end":str)
    b = boxes[0]
    print(b) 
    end
</code></pre>

<pre style="background-color: #222; color: white;">> smol main.s
Buffer start
</pre>

<p><i>Immutable buffers have immutable contents</i>. This includes not allowing
retrieval of <code class="language-smolambda">ptr</code> data to accidentally 
place them on mutable variables. There is a lot of flexibility in defining your
own buffers, but <i>smoŒª</i> actively promotes the faster memory management of
its standard library
</p>

<pre><code class="language-smolambda">@include std.core

def strbuf(nominal, @mut str[] ref)
    return @args

def strbuf(String value)
    return nominal.strbuf(str[]:push(value:str))

def put(@mut strbuf buf, String value)
    return buf.ref:put(0, value:str)

def str(@mut strbuf buf)
    return buf.ref[0]:str

service main()
    @mut boxes = strbuf[]  // must be mutable to grant mutable access
    :push("first element":strbuf)
    :push("second element":strbuf)
    @mut b = boxes[0]
    // the line bellow is fancier than b:put("overwritten element")
    on b 
        return "overwritten element":put 
    print(b:str) 
    end
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
overwritten element
</pre>


<h3 id="typechecking">Typechecking <a href="#typechecking" class="anchor-link">üîó</a></h3>

<p>There is the option to perform compile-time typechecking. This capability is provided because
one of smoŒª's goals is to give the illusion of a higher-level counterpart despite providing fast 
zero cost abstractions over bare metal assembly.
</p>

<p>This feature tries to compile several alternative code blocks, picking up the first valid
one (validity is checked only in terms of runtype arguments). 
It does so by designating the start of a code block with  <code class="language-smolambda">with</code>
and having at least zero or more follow-up block designated by <code class="language-smolambda">else</code>.
</p>

<p>This feature is particularly useful with <code class="language-smolambda">union</code> types
that let you write the same generic code once and call it with various kinds of data. In those
cases, you might want to have code behave differently depending on the obtained data. Below
is a first glimpse on this dynamism, where <i>first</i> employs a different pattern depending on
the data it is called with. The implementation could also be overloaded, though code selection is an
ergonomic alternative. More on overloading later.</p>

<pre><code class="language-smolambda">@include std.core
@include std.vec // more on vectors later

def point(f64 x, f64 y) 
    return @args

union Elements 
    vec
    point
    f64
    i64
    end

def first(Elements elements)
    with 
        res = elements:vec[0]
        end
    else
        res = elements:point.x
        end
    else 
        res = elements:f64
    endreturn res

service main()
    x1 = vec:rand(10)
    print(x1:first)
    print(z:first)
    print(point(1.0,2.0):first)
    end
</code></pre>



<h1 id="service">Services <a href="#service" class="anchor-link">üîó</a></h1>


<h3 id="whysvc">Why services? <a href="#whysvc" class="anchor-link">üîó</a></h3>

<p>So far we have been writing <code class="language-smolambda">service main()</code> as the entrant
point of programs. Armed with the basics, we can now look at what that <i>service</i> keyword is all about. 
Functionally, services are runtypes. 
Below is an example of declaring and calling a service. Syntactically, this is near-identical to working
with runtypes so that it's easy to change your mind as you write code. 
You will often not notice anything different.
</p>

<pre><code class="language-smolambda">@include std.core

service square(f64 x) 
    return x*x

service main()
    y = square(2.0)
    print(y)
    end
</code></pre>

<p>Semantically, services are equivalent to runtypes with error handling and the restriction that they a)
do not accept arguments by reference, b) stop further mutation of mutables provided as arguments. 
However, they cost some additional operations per call, 
as they need to actually push the call to the stack and cascade
unhandled errors. So they are less efficient if you, say, call them millions of times per second.
</p>
<p>
That said, they have three distinct advantages. First, they run independently and in parallel. 
Second, they can call each other regardless of definition order, 
and even allow recursion (by comparison, simpler runtypes can only "see" previous declarations).
And, third, they provide a compartmentalized execution environment that does not let internal errors escape.
</p>

<h3 id="errors">Error handling <a href="#errors" class="anchor-link">üîó</a></h3>

<p>
The last point means that, after calling a service within another one,
you need to consider how to handle prospective errors. The pattern discussed 
so far blindly unpacks results into further service and runtime calls.
This elegantly fails if an error is returned: it is cascaded
through the service call stack until handled. Or it eventually terminates the 
main service. 
</p>


<pre><code class="language-smolambda">@include std.core

service square(f64 x) 
    fail("Don't wanna!") // manually fail
    return mul(x,x)

service main()
    y = square(2.0)
    print(y)
    end
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
Don't wanna!
Runtime error: `square y` contains an error
</pre>

<p>
You can check for the error code of services by accessing it from the result per
<code class="language-smolambda">result.err</code>. By convention, error codes are skipped
when unpacking values to let service returns be used interchangeably to runtypes in 
the hotpath.
</p>

<pre><code class="language-smolambda">@include std.core

service square(f64 x) 
    fail("Don't wanna!") // manually fail
    return mul(x,x)

service main()
    y = square(2.0)
    if y.err:bool return print("Something went wrong")
    else          return print(y)
    end
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
Don't wanna!
Something went wrong
</pre>

<p>
Services fail safely by deallocating resources, and in fact
<i>smoŒª</i> encourages letting services fail and retrying instead of 
creating hard-to-implement recovery. Below is an example, where a 
service is created to handle bug-prone inputs in an isolated environment.
You could also implement it as a runtype and then have the whole main
service fail too.
</p>


<pre><code class="language-smolambda">@include std.core

service get_age() 
    print("What's your age?")
    age = u64:read
    if age&lt;=1
        return fail("Too young for this stuff")
    if age<5
        return fail("Still too young")
    if age>=140 
        return fail("Too old for this stuff")
    return age

service main()
    while true
        age = get_age() 
        if age.err:bool:not 
            |--
        end
    on Heap:dynamic
        print("You've seen at least "+str(age-1)+" years gone by.")
    end end
</code></pre>
<pre style="background-color: #222; color: white;">> smol main.s
What's your age?
1000
Too old for this stuff
What's your age?
0
Too young for this stuff
What's your age?
10
You've seen at least 9 years gone by.
</pre>


<h1 id="std">Std <a href="#std" class="anchor-link">üîó</a></h1>

<h3 id="beyond">Beyond the core <a href="#beyond" class="anchor-link">üîó</a></h3>

<p>The standard library contains implementations for common programming needs.
Besides overloading pairswise numerical and comparison operators for basic arithmetic types and booleans, 
it also supports string handling and contains a backbone for memory management.
</p>


<h3 id="memory">Memory <a href="#memory" class="anchor-link">üîó</a></h3>
<p>Perhaps the most important set of operations in <i>smoŒª</i>'s standard library is its memory model.
This leverages functionality from the language's core to. Two types of memory are generally assumed:
<code>Stack</code> memory that is fastly allocated in the stack of services and <code>Heap</code>
memory that is a bit slower to manage (and access) but which resides in the main computer memory
and can be used for large chunks of data. These memory types are provided every time; in devices
where heap memory is not available, appropriate runtimes can still use a large static buffer under
the hood.</p>

<p>Memory operations are safe in that there are no memory errors, such as use-after-free or corruptions; 
  unused memory is released when services end or when resources are invaldiated with <code class="language-smolambda">@release</code>
  (see next). <b>The main language contract is that memory or other resources can be released only when services end.</b>
</p>


<h3 id="console">Console <a href="#console" class="anchor-link">üîó</a></h3>
<p>Basic functionalities are introduced for the console, namely reading and printing. These support all escape characters
C/C++ can support, including ANSI codes for colors. They have also been overloaded for integers, floats, and -as seen in the next
segment- strings. Reading failure fails the current service under <i>smoŒª</i>'s guidelines that services should fail completely and rerun
instead of trying to recover from invalid states. Here's an example:
</p>

<pre><code class="language-smolambda">@include std.core

service main()
    success = false
    x = f64:read()
    print(x)
    end
</code></pre>

<h3 id="strings">Strings <a href="#strings" class="anchor-link">üîó</a></h3>

<p>String manipulation is included from the builtin functionalities of the
standard library. Below is an example that demonstrates conversion from
primitives. Similarly overload <code class="language-smolambda">str(Type obj)</code> 
for custom types. Strings admit the following two optimizations under the hood to enable
very fast handling without creating excessive bloat when passed around:
a) they retain c-style strings for quoted characters, and b) they keep track of the first character
to enable fast comparison without going through heap data.
</p>

<pre><code class="language-smolambda">@include std.core

service main()
    i = 0
    while i&lt;=10 
        if 0==i%2 
            return print("Even "+i:str)
        else      
            return print("Odd  "+i:str)
        i = i+1
    end end // end while and main with no return
</code></pre>


<p>Buffers and standard library implementations, like strings, are
safe to return from services. In that case, deallocation instructions
are transferred upwards, but still performed 
on failure. Note that the C/C++ interface is generally unsafe
and requires extensive tests to demonstrate correctness. However, once
safe implementations are provided, you can reuse those.
</p>

<p>Strings are immutable and therefore allow for very fast operations
for obtaining substrings by increasing pointers and decreasing length
under the hood. Those operations apply bound checks but
do not copy memory and are therefore performant. Here is
an example of obtaining substrings with the slicing notation.</p>

<pre><code class="language-smolambda">@include std.core
service main()
    s = "I like bananas!"
    print(s[2 to 7])  // prints "like"
    end
</code></pre>

<p>
As a trade-off for performance and safety, manipulating individual characters
in strings can only be done by spliting and recombining them, which
may be computationally intensive by moving memory.
Manipulating characters at individual string positions without losing safety
will be covered in future versions of the standard library.
</p>

<pre><code class="language-smolambda">@include std.core

service add_service(str v1, str v2) 
    i = 0
    while i&lt;10
        v2 = v2+"c"
        i = i+1
    end-&gt; v1+v2

service main()
    r1 = "aa":str
    r2 = "bb":str
    r1 = add_service(r1,r2)
    print(r1)
    end
</code></pre>

<h3 id="files">Allocators <a href="#files" class="anchor-link">üîó</a></h3>

<p><i>Section under construction.</i></p>

<pre><code class="language-smolambda">@include std.core
@include std.mem

def zero(Memory, u64 n)
    v = nominal.allocate(Memory, n, f64)
    i = 0 
    while i&lt;n
        @next i = i+1
        v:put(i, 0.0)
    end-&gt; v
 
def dot(allocate x, allocate y)
    if x.size!=y.size return fail("Mismatching size")
    sum = x.Primitive:zero
    i = 0
    while i&lt;x.size
        @next i = i+1 
        with 
            sum = sum + x[i]*y[i]
            end
        else 
    end end-&gt; sum // all closing statements

service main()
    n = 10000
    x = heap:zero(n)
    y = heap:zero(n)
    x:put(0, 0.1)
    y:put(0, 0.2)
    print(dot(x,y))
    end
</code></pre>



<h3 id="files">Files <a href="#files" class="anchor-link">üîó</a></h3>

<p><i>Section under construction.</i></p>



<h3 id="vectors">Vectors <a href="#vectors" class="anchor-link">üîó</a></h3>
<b>Under construction.</b>

<p>Below is an example that demonstrates 
vector computations. These include the generation
of vectors with uniformly random elements.
</p>

<pre><code class="language-smolambda">@include std.core
@include std.vec
@include std.time

service main()
    n = 100000
    x1 = vec(n)
    x2 = vec(n)
    tic = time()
    z = dot(x1,x2)
    print("Elapsed \{time()-tic} sec")
    print(z)
    end
</code></pre>


<h3 id="math">Math <a href="#math" class="anchor-link">üîó</a></h3>

<p>Various trigonometric operations are available, namely <code>cos, sin, tan, acos, asin, atan</code>.
In addition to those, you can compute multiples of <code>œÄ=3.14159...</code> per <code class="language-smolambda">value:pi</code> like below.
</p>
<pre><code class="language-smolambda">@include std.core
@include std.math

service main()
    print("Give a number of radians")
    rads = f64:read:pi
    print("cos \{rads:cos}")
    print("sin \{rads:sin}")
    print("tan \{rads:tan}")
    end
</code></pre>
<o>
Furthermore, <code>exp,log,pow,sqrt</code> are also available. Importantly, the logarithm requires
a positive inputs, the square root requires non-negative input, and power computations require
non-negative base. 
</p>

    

</div>
<script src="vendor/prism/prism.min.js"></script>
<script>
Prism.languages.smolambda = {
  'comment': /\/\/.*/,
  'directive': {
    pattern: /@\w+/,
    alias: 'important'
  },
  'keyword': [
    {
      pattern: /\b(?:def|service|if|return|else|elif|with|include|do|while|union|to|upto|lento|len|and|or|end)\b/,
      greedy: true
    },
    {
      pattern: /(?:\|\|\|return|\|\|return|\|\|--|\|return|\|--|return|--|:|=)/,
      greedy: true
    }
  ],
  'special-amp': {
    pattern: /&/,
    alias: 'operator' // optional, gives Prism‚Äôs operator style too
  },
  'builtin': /\b(?:i64|u64|f64|ptr|cstr|nstr|str|buffer|main|copy|bool|not|cos|sin|tan|acos|asin|atan|pi|exp|log|pow|sqrt|add|mul|sub|div|nominal)\b/,
  'punctuation': /[{}();,\[\]]/,
  'number': /\b\d+\b/,
  'string': {
    pattern: /"(?:\\.|[^"\\])*"/,
    greedy: true
  }
};
</script>
<script>
  document.querySelectorAll('a.anchor-link').forEach(a =>
    a.addEventListener('click', e => {
      if(location.hash === a.getAttribute('href')) e.preventDefault()
    })
  )
</script>


</body>
</html>
