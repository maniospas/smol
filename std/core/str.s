// Written in 2025 by Emmanouil Krasanakis (maniospas@hotmail.com)
//
// To the extent possible under law, the author has dedicated all copyright
// and related and neighboring rights to this software to the public domain
// worldwide.
// 
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted.
// 
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
// IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 

@include std.core.num
@unsafe
@about "Standard library implementation of the extensible string model based on C pointers and an implementation for const char arrays."
@about str     "A memory allocated string and converters from constant strings and booleans to the type. Other standard library implementations provide more converters."
@about nstr    "A null-terminated variation of str. Many operation produce this string version, as it can be readily converted to str at no cost (for the inverse, you need to copy the string)"
@about String  "A union between <code>str</code>, <code>nstr</code>, and constant strings <code>cstr</code>. Constant strings are those that generated by default when enclosing some text in quotients and are stored in the program memory."
               "\n<br><br>Main usage is to abstract an argument's type by converting it to str. The conversion is a zero cost abstraction in that needless operations will be removed. But it still augments constant strings with length and first element inform <i>if these are needed</i>. Here is an example:"
               "\n<pre>def foo(String _s)"
               "\n    s = _s.str()"
               "\n    ..."
               "\n    end</pre>"
@about CString "A union between <code>nstr</code> and constant strings <code>cstr</code>."
               "\n<br><br>Main usage is to abstract an argument's type by converting it to nstr. The conversion is a zero cost abstraction in that needless operations will be removed. But it still augments constant strings with length and first element inform <i>if these are needed</i>. Here is an example:"
               "\n<pre>def foo(CString _s)"
               "\n    s = _s.nstr()"
               "\n    ..."
               "\n    end</pre>"
@about IndependentString "A copy of the String union that can be used when a second argument is needed for a string of a potentially different variation."
@about is      "Compile-time check of a String exact type matching compared to an arbitrary type.<br>Example usage."
               "<pre>def foo(String s)\n    with s.is(str)\n        ...\n        end else\n        ...\n    end end</pre>"
@about print   "Prints strings or bools to the console."
@about printin "Prints strings or bools to the console without evoking a new line at the end."
@about next    "Retrieves the next element over a Split string iteration. Example:"
               "<pre>Split(\"I like bananas\", \" \")\n.while next(@mut str word)\n    print(word)\n    end</pre>"
@about Split   "Splits a String given a query String. Optionally, you may also provide a starting position, where the default is 0. "
               "The result of the split can be iterated through with <code>next</code>. This does not allocate memory in that a substring is retrieved, so you might consider copying the splits - or store them on data structures like maps that automatically copy data if needed."
@about eq      "Checks for equality between String types when considering their contents. Implementation of this operation varies, "
               "ensuring that the cached first element of strings (not available for cstr) is compared first and then the lengths "
               "are taken into account to compare memory bytes. Example: <pre>if \"me\"==\"me\" return print(\"me!\")</pre>"
@about neq     "Equivalent to logical enversion of String <i>eq</i>. It is faster to write and run."
@about slice   "Obtains a substring slice out of a String. This always produces a <code>str</code> results, because null termination "
               "cannot be guaranteed for most results - and is dropped even if it could be guaranteed to save computations. "
               ""


def str (
        nominal, 
        ptr contents, 
        u64 length, 
        char first, 
        ptr memory
    ) 
    return @args

def nstr (
        nominal, 
        ptr contents, 
        u64 length, 
        char first, 
        ptr memory
    )  
    return @args

union CString = cstr or nstr
union String  = CString or str
union IndependentString = String

def is(String self, String) 
    return self

def str(nstr other)
    return nominal.str(other.contents, other.length, other.first, other.memory)

def str(@access cstr raw)
    @head{#include <string.h>}
    @body{
        u64 length=strlen(raw);
        ptr contents=(ptr)raw;
        char first=raw[0];
        ptr noptr=(ptr)noptr; // use this to indicate a cstr
    }
    return nominal.str(contents, length, first, noptr)

def nstr(@access cstr raw)
    @head{#include <string.h>}
    @body{
        u64 length=strlen(raw);
        ptr contents=(ptr)raw;
        char first=raw[0];
        ptr noptr = (ptr)noptr; // use this to indicate a cstr
    }
    return nominal.nstr(contents, length, first, noptr)

def str(@access bool value) 
    @head{cstr __truestr = "true";}
    @head{cstr __falsestr = "false";}
    if value @body{cstr _contents=__truestr;} --
    else @body{cstr _contents=__falsestr;} --
    return str(_contents)

def nstr(@access bool value)
    @head{cstr __truestr = "true";}
    @head{cstr __falsestr = "false";}
    if value @body{cstr _contents=__truestr;} --
    else @body{cstr _contents=__falsestr;} --
    return nstr(_contents)

def print(@access cstr message)
    @head{#include <stdio.h>}
    @body{printf("%s\n", message);}
    --

def print(@access nstr message)
    @head{#include <stdio.h>}
    @body{printf("%s\n", (char*)message__contents);}
    --

def print(@access str message)
    @head{#include <stdio.h>}
    @body{printf("%.*s\n", (int)message__length, (char*)message__contents);}
    --

def printin(@access cstr message)
    @head{#include <stdio.h>}
    @body{printf("%s", message);}
    --

def printin(@access nstr message)
    @head{#include <stdio.h>}
    @body{printf("%s", (char*)message__contents);}
    --

def printin(@access str message)
    @head{#include <stdio.h>}
    @body{printf("%.*s", (int)message__length, (char*)message__contents);}
    --

def eq(@access char x, char y)  
    @body{bool z=(x==y);} 
    return z

def neq(@access char x, char y)
    @body{bool z=(x!=y);}
    return z

def slice(@access String self, u64 from, u64 to) 
    s = self.str()
    if to<from 
        @fail{printf("String slice cannot end before it starts\n");} 
        --
    if to>s.length 
        @fail{printf("String slice must end at most at the length of the base string\n");} 
        --
    @body{
        ptr contents = (ptr)((char*)s__contents+from*sizeof(char));
        char first = from==to?0:((__builtin_constant_p(from) && from == 0) ? s__first : ((char*)s__contents)[from]);
    }
    return nominal.str(contents, to-from, first, s.contents)
    
def slice(@access String self, u64 from) 
    return self.slice(from, 0)

def strip(@access String _s)
    s = _s.str()
    @body{
        u64 start = 0;
        u64 endpos = s__length;
        while(start < endpos) {
            char c = ((char*)s__contents)[start];
            if(c == 32 || c == 9 || c == 13 || c == 10) 
                start++; // ' ', '\t', '\r', '\n'
            else break;
        }
        while(endpos > start) {
            char c = ((char*)s__contents)[endpos - 1];
            if(c == 32 || c == 9 || c == 13 || c == 10) 
                endpos--;
            else break;
        }
    }
    return s.slice(start, endpos)

def eq(@access String _x, IndependentString _y)
    x = _x.str()
    y = _y.str()
    @head{#include <string.h>}
    @body{bool z = x__first==y__first && (x__length == y__length) && (memcmp((char*)x__contents+1, (char*)y__contents+1, x__length-1) == 0);}
    return z

def neq(@access String _x, IndependentString _y)
    x = _x.str()
    y = _y.str()
    @head{#include <string.h>}
    @body{
        //printf("x. '%s', length. %zu\n", ((char*)x__contents), x__length - 1);
        //printf("y. '%s', length. %zu\n", ((char*)y__contents), y__length - 1);

        bool z = (x__first != y__first) 
                || (x__length != y__length) 
                || (memcmp((char*)x__contents + 1, (char*)y__contents + 1, x__length - 1) != 0);
    }
    return z

def len(@access str x) 
    return x.length

def len(@access nstr x) 
    return x.length

def len(@access cstr x)
    @head{#include <string.h>}
    @head{#include <stdlib.h>}
    @body{u64 z = strlen(x);}
    return z

def at(@access str x, u64 pos) 
    if x__length<=pos 
        @fail{printf("String index out of bounds\n");} 
        end
    // trying to help the compiler below, but maybe it's too clever and it can optimize that
    @body{char z= (__builtin_constant_p(pos) && pos == 0) ? x__first: ((char*)x__contents)[pos];} 
    return z

def at(@access nstr x, u64 pos) 
    return at(x.str(), pos)

def Split(nominal, 
        str query,
        str sep, 
        @mut u64 pos
    ) 
    return @args
    
def Split(@access String _query, @access IndependentString _sep) 
    return nominal.Split(_query.str(), _sep.str(), u64 &pos) // splits are str (not cstr or nstr)

def next(
        @access @mut Split self, 
        @mut str value
    )
    ret = self.pos<self.query.len()
    if ret 
        @mut searching = true
        prev = self.pos
        while(searching==true) and (self.pos<self.query.len()-self.sep.len())
            if self.sep==self.query[self.pos to self.pos+self.sep.len()] 
                if self.pos>prev value = self.query[prev to self.pos] searching = false --
                self.pos = self.pos+self.sep.len()
                -- 
            else 
                self.pos = self.pos+1
            end end
        if searching
            self.pos = self.query.len()
            value = self.query[prev to self.pos] 
        end end
    return ret


def print(@access str[] messages)
    @mut i = 0
    n = messages.len()
    while i<n
        print(messages[i])
        i = i+1
    end end
