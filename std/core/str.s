// Written in 2025 by Emmanouil Krasanakis (maniospas@hotmail.com)
//
// To the extent possible under law, the author has dedicated all copyright
// and related and neighboring rights to this software to the public domain
// worldwide.
// 
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted.
// 
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
// IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 

@include std.core.num
@unsafe

@about
"Standard library implementation of the extensible string model based on C "
"pointers and an implementation for const char arrays."

@about str
"A memory allocated string and converters from constant strings and booleans "
"to the type. Other standard library implementations provide more converters."

@about nstr
"A null-terminated variation of str. Many operation produce this string "
"version, as it can be readily converted to str at no cost (for the inverse, "
"you need to copy the string)"

@about String  
"A union between <code>str</code>, <code>nstr</code>, and constant strings "
"<code>cstr</code>. Constant strings are those that generated by default "
"when enclosing some text in quotients and are stored in the program memory."
"\n<br><br>Main usage is to abstract an argument's type by converting it to "
"str. The conversion is a zero cost abstraction in that needless operations "
"will be removed. But it still augments constant strings with length and first "
"element inform <i>if these are needed</i>. Example:"
"\n<pre>def foo(String _s)"
"\n    s = _s.str()"
"\n    ...</pre>"

@about CString 
"A union between <code>nstr</code> and constant strings <code>cstr</code>."
"\n<br><br>Main usage is to abstract an argument's type by converting it to "
"nstr. The conversion is a zero cost abstraction in that needless operations "
"will be removed. But it still augments constant strings with length and first "
"element inform <i>if these are needed</i>. Example:"
"\n<pre>def foo(CString _s)"
"\n    s = _s.nstr()"
"\n    ...</pre>"

@about IndependentString 
"A copy of the String union that can be used when a second argument is needed "
"for a string of a potentially different variation."

@about is
"Compile-time check of a String exact type matching compared to an arbitrary "
"type. <br>Example:"
"<pre>def foo(String s)"
"\n    case s.is(str)"
"\n        ..."
"\n    case s.is(cstr)"
"\n        ..."
"\n    qed</pre>"

@about print   
"Prints strings or bools to the console."

@about printin 
"Prints strings or bools to the console without evoking a new line at the end."

@about next    
"Retrieves the next element over a Split string iteration. Example:"
"<pre>Split(\"I like bananas\", \" \")"
"\n.while next(@mut str word)"
"\n    then print(word)</pre>"

@about Split   
"Splits a String given a query String. Optionally, you may also provide a "
"starting position, where the default is 0. The result of the split can be "
"iterated through with <code>next</code>. This does not allocate memory in "
"that a substring is retrieved, so you might consider copying the splits - "
"or store them on data structures like maps that automatically copy data if "
"needed."

@about eq      
"Checks for equality between String types when considering their contents. "
"Implementation of this operation varies, ensuring that the cached first "
"element of strings (not available for cstr) is compared first and then the "
"lengths are taken into account to compare memory bytes. Example: "
"<pre>if \"me\"==\"me\""
"\n    return print(\"me!\")</pre>"

@about neq
"Equivalent to logical inversion of String <i>eq</i>. It is faster to write "
"and run. Example:"
"<pre>if \"to be\"!=\"not to be\""
"\n    return print(\"dobedobedoo!\")</pre>"

@about slice   
"Obtains a substring slice out of a String, producing a <code>str</code> result. "
"Null termination cannot be guaranteed for most results - and is dropped even in "
"cases it could be guaranteed to reduce checks. This overloads the slicing operator. "
"Example: "
"<pre>s = \"I like bananas!\""
"\nprint(s[7 upto 14]) // prints `bananas`"
"\nprint(s[7 to 14])   // prints `banana`"
"</pre>"

@about getch
"Retrieves a character from the terminal without printing it. The result is a  "
"character encoded in i64 format. This is not stored as a char due to extra symbols, "
"but can be converted to an one-byte character. Example:"
"<pre>s = getch()"
"\nif s.is_char()"
"\n    print(s.to_char())</pre>"

@about strip
"Removes leading and trailing whitespace characters from a String, including "
"spaces, tabs, carriage returns, and newlines. Returns a substring without "
"allocating new memory. Example:"
"<pre>print(\"  hi!\t\".strip()) // prints `hi!`</pre>"

@about len
"Returns the length of a string. Works for <code>str</code>, <code>nstr</code>, "
"and <code>cstr</code>. Example:"
"<pre>print(len(\"banana\")) // prints 6</pre>"

@about at
"Retrieves a character from a string at a given position. Fails if the position "
"is out of bounds. Example:"
"<pre>print(\"abc\".at(1)) // prints `b`</pre>"

@about Split
"An iterator structure that splits a String by a separator. The split is lazy "
"and does not allocate memory, returning slices of the original string. Use "
"<code>next</code> to retrieve each part."

@about key
"Represents a keyboard key input captured through <code>getch</code>. "
"Encodes the key's integer representation in <code>data</code>."

@about is_printable
"Checks if a captured key represents a printable ASCII character."

@about is_left
"Checks if a captured key represents the left arrow key."

@about is_right
"Checks if a captured key represents the right arrow key."

@about is_up
"Checks if a captured key represents the up arrow key."

@about is_down
"Checks if a captured key represents the down arrow key."

@about is_tab
"Checks if a captured key represents the tab key."

@about is_enter
"Checks if a captured key represents the enter key."

@about is_delete
"Checks if a captured key represents the delete key."

@about is_backspace
"Checks if a captured key represents the backspace key."

@about is_char
"Checks if a key press corresponds to a printable ASCII character."

@about to_char
"Converts a <code>key</code> object representing a printable ASCII character "
"to its <code>char</code> value. Fails if the key is not a character."


def str (
    nominal, 
    ptr contents, 
    u64 length, 
    char first, 
    ptr memory
)
    return @args

def nstr (
    nominal, 
    ptr contents, 
    u64 length, 
    char first, 
    ptr memory
)
    @body{if(memory) (((char*)contents)[length]) = 0;}
    return @args

union CString = cstr or nstr
union String  = CString or str
union IndependentString = String

def is(@access String self, String) 
    return self

def str(@access nstr other)
    return nominal.str(other.contents, other.length, other.first, other.memory)

def str(@access cstr raw)
    @head{#include <string.h>}
    @body{
        u64 length=strlen(raw);
        ptr contents=(ptr)raw;
        char first=raw[0];
        ptr noptr=0; // use this to indicate a cstr
    }
    return nominal.str(contents, length, first, noptr)

def nstr(@access cstr raw)
    @head{#include <string.h>}
    @body{
        u64 length=strlen(raw);
        ptr contents=(ptr)raw;
        char first=raw[0];
        ptr noptr = 0; // use this to indicate a cstr
    }
    return nominal.nstr(contents, length, first, noptr)

def str(@access bool value) 
    @head{cstr __smol_true_str = "true";}
    @head{cstr __smol_false_str = "false";}
    if value 
        @body{cstr _contents=__smol_true_str;} 
    else 
        @body{cstr _contents=__smol_false_str;}
    return str(_contents)

def nstr(@access bool value)
    @head{cstr __smol_true_str = "true";}
    @head{cstr __smol_false_str = "false";}
    if value 
        @body{cstr _contents=__smol_true_str;} 
    else
        @body{cstr _contents=__smol_false_str;}
    return nstr(_contents)

def print(@access cstr message)
    @head{#include <stdio.h>}
    @body{printf("%s\n", message);}

def print(@access nstr message)
    @head{#include <stdio.h>}
    @body{printf("%.*s\n", (int)message__length, (char*)message__contents);}

def print(@access str message)
    @head{#include <stdio.h>}
    @body{printf("%.*s\n", (int)message__length, (char*)message__contents);}

def printin(@access cstr message)
    @head{#include <stdio.h>}
    @body{printf("%s", message);}

def printin(@access nstr message)
    @head{#include <stdio.h>}
    @body{printf("%.*s", (int)message__length, (char*)message__contents);}

def printin(@access str message)
    @head{#include <stdio.h>}
    @body{printf("%.*s", (int)message__length, (char*)message__contents);}

def eq(@access char x, char y)  
    @body{bool z=(x==y);} 
    return z

def neq(@access char x, char y)
    @body{bool z=(x!=y);}
    return z

def slice(@access String self, u64 from, u64 to) 
    s = self.str()
    if to<from 
        @fail{printf("String slice cannot end before it starts\n");} 
    if to>s.length
        @fail{printf("String slice must end at most at the length of the base string\n");} 
    @body{
        ptr contents = (ptr)((char*)s__contents+from*sizeof(char));
        char first = from==to?0:((__builtin_constant_p(from) && from == 0) ? s__first : ((char*)s__contents)[from]);
    }
    return nominal.str(contents, to-from, first, s.contents)
    
def slice(@access String self, u64 from) 
    return self.slice(from, 0)

def strip(@access String _s)
    s = _s.str()
    @body{
        u64 start = 0;
        u64 end_pos = s__length;
        while(start < end_pos) {
            char c = ((char*)s__contents)[start];
            if(c == 32 || c == 9 || c == 13 || c == 10) 
                start++; // ' ', '\t', '\r', '\n'
            else break;
        }
        while(end_pos > start) {
            char c = ((char*)s__contents)[end_pos - 1];
            if(c == 32 || c == 9 || c == 13 || c == 10) 
                end_pos--;
            else break;
        }
    }
    return s.slice(start, end_pos)

def eq(@access String _x, IndependentString _y)
    x = _x.str()
    y = _y.str()
    @head{#include <string.h>}
    @body{bool z = x__first==y__first && (x__length == y__length) && (memcmp((char*)x__contents+1, (char*)y__contents+1, x__length-1) == 0);}
    return z

def neq(@access String _x, IndependentString _y)
    x = _x.str()
    y = _y.str()
    @head{#include <string.h>}
    @body{
        //printf("x. '%s', length. %zu\n", ((char*)x__contents), x__length - 1);
        //printf("y. '%s', length. %zu\n", ((char*)y__contents), y__length - 1);

        bool z = (x__first != y__first) 
            || (x__length != y__length) 
            || (memcmp((char*)x__contents + 1, (char*)y__contents + 1, x__length - 1) != 0);
    }
    return z

def len(@access str x) 
    return x.length

def len(@access nstr x) 
    return x.length

def len(@access cstr x)
    @head{#include <string.h>}
    @head{#include <stdlib.h>}
    @body{u64 z = strlen(x);}
    return z

def at(@access str x, u64 pos) 
    if x__length<=pos 
        @fail{printf("String index out of bounds\n");}
    // trying to help the compiler below, but maybe it's too clever and it can optimize that
    @body{char z= (__builtin_constant_p(pos) && pos == 0) ? x__first: ((char*)x__contents)[pos];} 
    return z

def at(@access nstr x, u64 pos) 
    return at(x.str(), pos)

def Split(nominal, 
    str query,
    str sep, 
    @mut u64 pos
)
    return @args
    
def Split(@access String _query, @access IndependentString _sep) 
    return nominal.Split(_query.str(), _sep.str(), u64 &pos) // splits are str (not cstr or nstr)

def next(
    @access @mut Split self, 
    @mut str value
)
    if self.pos>=self.query.len() 
        return false
    @mut prev = self.pos
    while self.pos<self.query.len()-self.sep.len()
        if self.sep!=self.query[self.pos to self.pos+self.sep.len()]
            self.pos = self.pos + 1
        elif self.pos<=prev
            //TODO: first find is unoptimized but added in the loop here
            self.pos = self.pos+self.sep.len()
            prev = self.pos
        else
            value = self.query[prev to self.pos]
            return true
    // if found nothing, return the ending and make next call yield false
    self.pos = self.query.len()
    value = self.query[prev to self.pos]
    return true


def print(@access str[] messages)
    @mut i = 0
    n = messages.len()
    while i<n
        print(messages[i])
        i = i+1

def key(nominal, i64 data)
    return @args

def getch()
    @head{#include "std/oscommon.h"}
    @body{i64 ch = __smo_next_key_press();}
    return nominal.key(ch)

def is_enter(key input)
    return input.data==i64(10)

def is_left(key input)
    return input.data==i64(1792836)
    
def is_right(key input)
    return input.data==i64(1792835)

def is_up(key input)
    return input.data==i64(1792833)

def is_down(key input)
    return input.data==i64(1792834)

def is_tab(key input)
    return input.data==i64(9)

def is_delete(key input)
    return input.data==i64(126)

def is_backspace(key input)
    return input.data==i64(127)

def is_char(key input)
    ret = (input.data>=i64(0))and(input.data<i64(255))
    return ret
    
def to_char(key input)
    if(input.data<i64(0))or(input.data>=i64(255)) 
        @fail{printf("Cannot convert a non-character key input to a characters\n");}
    return char(input.data)

def is_printable(key input)
    // Printable ASCII range: 32 (' ') to 126 ('~')
    ret = (input.data>=i64(32))and(input.data<=i64(126))
    return ret